//========================================================================
// This conversion was produced by the Free Edition of
// C++ to C# Converter courtesy of Tangible Software Solutions.
// Order the Premium Edition at https://www.tangiblesoftwaresolutions.com
//========================================================================

#define LUA_COMPAT_OPENLIB
#define LUA_COMPAT_VARARG
#define LUA_COMPAT_LSTR
#define LUA_COMPAT_MOD
#define LUA_DL_DLOPEN
#define LUA_DL_DLL
#define LUA_DL_DYLD
#define LUA_COMPAT_GFIND
#define LUAI_BITSINT
#define luaL_setn
#define luac_c
#define lua_assert

public static class GlobalMembers
{
	/*
	** $Id: lapi.c,v 2.55.1.5 2008/07/04 18:41:18 roberto Exp $
	** Lua API
	** See Copyright Notice in lua.h
	*/




	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)

	/*
	** $Id: lapi.h,v 2.2.1.1 2007/12/27 13:02:25 roberto Exp $
	** Auxiliary functions from Lua API
	** See Copyright Notice in lua.h
	*/



	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_SIZET ((size_t)(~(size_t)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_LUMEM ((lu_mem)(~(lu_mem)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_INT (INT_MAX-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IntPoint(p) ((unsigned int)(lu_mem)(p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (lua_assert(c), (e))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check(l,e) lua_assert(e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(c) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check luai_apicheck
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define UNUSED(x) ((void)(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast(t, exp) ((t)(exp))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_byte(i) cast(lu_byte, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_num(i) cast(lua_Number, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_int(i) cast(int, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_lock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unlock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_threadyield(L) {lua_unlock(L); lua_lock(L);}
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) x
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LAST_TAG LUA_TTHREAD
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NUM_TAGS (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TPROTO (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TUPVAL (LAST_TAG+2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TDEADKEY (LAST_TAG+3)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define CommonHeader GCObject *next; lu_byte tt; lu_byte marked
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define TValuefields Value value; int tt
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnil(o) (ttype(o) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnumber(o) (ttype(o) == LUA_TNUMBER)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisstring(o) (ttype(o) == LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttistable(o) (ttype(o) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisfunction(o) (ttype(o) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisboolean(o) (ttype(o) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisuserdata(o) (ttype(o) == LUA_TUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisthread(o) (ttype(o) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttislightuserdata(o) (ttype(o) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttype(o) ((o)->tt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gcvalue(o) check_exp(iscollectable(o), (o)->value.gc)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pvalue(o) check_exp(ttislightuserdata(o), (o)->value.p)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define nvalue(o) check_exp(ttisnumber(o), (o)->value.n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawtsvalue(o) check_exp(ttisstring(o), &(o)->value.gc->ts)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define tsvalue(o) (&rawtsvalue(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawuvalue(o) check_exp(ttisuserdata(o), &(o)->value.gc->u)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define uvalue(o) (&rawuvalue(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define clvalue(o) check_exp(ttisfunction(o), &(o)->value.gc->cl)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define hvalue(o) check_exp(ttistable(o), &(o)->value.gc->h)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bvalue(o) check_exp(ttisboolean(o), (o)->value.b)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define thvalue(o) check_exp(ttisthread(o), &(o)->value.gc->th)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_isfalse(o) (ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkconsistency(obj) lua_assert(!iscollectable(obj) || (ttype(obj) == (obj)->value.gc->gch.tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkliveness(g,obj) lua_assert(!iscollectable(obj) || ((ttype(obj) == (obj)->value.gc->gch.tt) && !isdead(g, (obj)->value.gc)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnilvalue(obj) ((obj)->tt=LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnvalue(obj,x) { TValue *i_o=(obj); i_o->value.n=(x); i_o->tt=LUA_TNUMBER; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setpvalue(obj,x) { TValue *i_o=(obj); i_o->value.p=(x); i_o->tt=LUA_TLIGHTUSERDATA; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbvalue(obj,x) { TValue *i_o=(obj); i_o->value.b=(x); i_o->tt=LUA_TBOOLEAN; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TSTRING; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setuvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TUSERDATA; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setthvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTHREAD; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setclvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TFUNCTION; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTABLE; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TPROTO; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj(L,obj1,obj2) { const TValue *o2=(obj2); TValue *o1=(obj1); o1->value = o2->value; o1->tt=o2->tt; checkliveness(G(L),o1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjs2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2s setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue2s sethvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue2s setptvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjt2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2n setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2n setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setttype(obj, tt) (ttype(obj) = (tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscollectable(o) (ttype(o) >= LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getstr(ts) cast(const char *, (ts) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define svalue(o) getstr(rawtsvalue(o))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ClosureHeader CommonHeader; lu_byte isC; lu_byte nupvalues; GCObject *gclist; struct Table *env
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscfunction(o) (ttype(o) == LUA_TFUNCTION && clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLfunction(o) (ttype(o) == LUA_TFUNCTION && !clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lmod(s,size) (check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define twoto(x) (1<<(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizenode(t) (twoto((t)->lsizenode))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaO_nilobject (&luaO_nilobject_)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ceillog2(x) (luaO_log2((x)-1) + 1)


	public static void luaA_pushobject(lua_State L, lua_TValue o)
	{
	  {
		  lua_TValue o2 = (o);
		  lua_TValue o1 = (L.top);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
		  o1.value.CopyFrom(o2.value);
		  o1.tt = o2.tt;
		  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
  };
  {
		  luai_apicheck(L, L.top < L.ci.top);
		  L.top++;
  };
	}


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gfasttm(g,et,e) ((et) == NULL ? NULL : ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define fasttm(l,et,e) gfasttm(G(l), et, e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocv(L,b,on,n,e) ((cast(size_t, (n)+1) <= MAX_SIZET/(e)) ? luaM_realloc_(L, (b), (on)*(e), (n)*(e)) : luaM_toobig(L))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freemem(L, b, s) luaM_realloc_(L, (b), (s), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_free(L, b) luaM_realloc_(L, (b), sizeof(*(b)), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freearray(L, b, n, t) luaM_reallocv(L, (b), n, 0, sizeof(t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_malloc(L,t) luaM_realloc_(L, NULL, 0, (t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_new(L,t) cast(t *, luaM_malloc(L, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_newvector(L,n,t) cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_growvector(L,v,nelems,size,t,limit,e) if ((nelems)+1 > (size)) ((v)=cast(t *, luaM_growaux_(L,v,&(size),sizeof(t),limit,e)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocvector(L, v,oldn,n,t) ((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define char2int(c) cast(int, cast(unsigned char, (c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define zgetc(z) (((z)->n--)>0 ? char2int(*(z)->p++) : luaZ_fill(z))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_buffer(buff) ((buff)->buffer)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_sizebuffer(buff) ((buff)->buffsize)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_bufflen(buff) ((buff)->n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resetbuffer(buff) ((buff)->n = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resizebuffer(L, buff, size) (luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), (buff)->buffsize = size)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_freebuffer(L, buff) luaZ_resizebuffer(L, buff, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gt(L) (&L->l_gt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define registry(L) (&G(L)->l_registry)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BASIC_STACK_SIZE (2*LUA_MINSTACK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define curr_func(L) (clvalue(L->ci->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ci_func(ci) (clvalue((ci)->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define f_isLua(ci) (!ci_func(ci)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLua(ci) (ttisfunction((ci)->func) && f_isLua(ci))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define G(L) (L->l_G)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2ts(o) check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2ts(o) (&rawgco2ts(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2u(o) check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2u(o) (&rawgco2u(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2cl(o) check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2h(o) check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2p(o) check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2uv(o) check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ngcotouv(o) check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2th(o) check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define obj2gco(v) (cast(GCObject *, (v)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pcRel(pc, p) (cast(int, (pc) - (p)->code) - 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getline(f,pc) (((f)->lineinfo) ? (f)->lineinfo[pc] : 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resethookcount(L) (L->hookcount = L->basehookcount)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaD_checkstack(L,n) if ((char *)L->stack_last - (char *)L->top <= (n)*(int)sizeof(TValue)) luaD_growstack(L, n); else condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define incr_top(L) {luaD_checkstack(L,1); L->top++;}
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define savestack(L,p) ((char *)(p) - (char *)L->stack)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define restorestack(L,n) ((TValue *)((char *)L->stack + (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define saveci(L,p) ((char *)(p) - (char *)L->base_ci)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define restoreci(L,n) ((CallInfo *)((char *)L->base_ci + (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeCclosure(n) (cast(int, sizeof(CClosure)) + cast(int, sizeof(TValue)*((n)-1)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeLclosure(n) (cast(int, sizeof(LClosure)) + cast(int, sizeof(TValue *)*((n)-1)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbits(x,m) ((x) &= cast(lu_byte, ~(m)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbits(x,m) ((x) |= (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbits(x,m) ((x) & (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bitmask(b) (1<<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bit2mask(b1,b2) (bitmask(b1) | bitmask(b2))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_setbit(x,b) setbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbit(x,b) resetbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbit(x,b) testbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define set2bits(x,b1,b2) setbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define reset2bits(x,b1,b2) resetbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define test2bits(x,b1,b2) testbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define WHITEBITS bit2mask(WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iswhite(x) test2bits((x)->gch.marked, WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isblack(x) testbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isgray(x) (!isblack(x) && !iswhite(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define otherwhite(g) (g->currentwhite ^ WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isdead(g,v) ((v)->gch.marked & otherwhite(g) & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define changewhite(x) ((x)->gch.marked ^= WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gray2black(x) l_setbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define valiswhite(x) (iscollectable(x) && iswhite(gcvalue(x)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_white(g) cast(lu_byte, (g)->currentwhite & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_checkGC(L) { condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1)); if (G(L)->totalbytes >= G(L)->GCthreshold) luaC_step(L); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),gcvalue(v)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barriert(L,t,v) { if (valiswhite(v) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarrier(L,p,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),obj2gco(o)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarriert(L,t,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizestring(s) (sizeof(union TString)+((s)->len+1)*sizeof(char))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeudata(u) (sizeof(union Udata)+(u)->len)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_new(L, s) (luaS_newlstr(L, s, strlen(s)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_newliteral(L, s) (luaS_newlstr(L, "" s, (sizeof(s)/sizeof(char))-1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_fix(s) l_setbit((s)->tsv.marked, FIXEDBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gnode(t,i) (&(t)->node[i])
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gkey(n) (&(n)->i_key.nk)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gval(n) (&(n)->i_val)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gnext(n) ((n)->i_key.nk.next)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define key2tval(n) (&(n)->i_key.tvk)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define tostring(L,o) ((ttype(o) == LUA_TSTRING) || (luaV_tostring(L, o)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define tonumber(o,n) (ttype(o) == LUA_TNUMBER || (((o) = luaV_tonumber(o,n)) != NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define equalobj(L,o1,o2) (ttype(o1) == ttype(o2) && luaV_equalval(L, o1, o2))



	public const string lua_ident = "$Lua: " DefineConstants.LUA_RELEASE " " DefineConstants.LUA_COPYRIGHT " $\n" + "$Authors: " DefineConstants.LUA_AUTHORS " $\n" + "$URL: www.lua.org $\n";



	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_checknelems(L, n) api_check(L, (n) <= (L->top - L->base))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_checkvalidindex(L, i) api_check(L, (i) != luaO_nilobject)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_incr_top(L) {api_check(L, L->top < L->ci->top); L->top++;}



	internal static lua_TValue index2adr(lua_State L, int idx)
	{
	  if (idx > 0)
	  {
		lua_TValue o = L.@base + (idx - 1);
		luai_apicheck(L, idx <= L.ci.top - L.@base);
		if (o >= L.top)
		{
			return ((lua_TValue)((luaO_nilobject_)));
		}
		else
		{
			return o;
		}
	  }
	  else if (idx > DefineConstants.LUA_REGISTRYINDEX)
	  {
		luai_apicheck(L, idx != 0 && -idx <= L.top - L.@base);
		return L.top + idx;
	  }
	  else
	  {
		  switch (idx)
		  { // pseudo-indices
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		case DefineConstants.LUA_REGISTRYINDEX:
			return ((L.l_G).l_registry);
		case DefineConstants.LUA_ENVIRONINDEX:
		{
		  Closure func = (check_exp((((L.ci.func).tt) == DefineConstants.LUA_TFUNCTION), (L.ci.func).value.gc.cl));
		  {
			  lua_TValue i_o = (L.env);
			  i_o.value.gc = ((union GCObject)((func.c.env)));
			  i_o.tt = DefineConstants.LUA_TTABLE;
			  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		  };
		  return L.env;
		}
		case DefineConstants.LUA_GLOBALSINDEX:
			return (L.l_gt);
		default:
		{
		  Closure func = (check_exp((((L.ci.func).tt) == DefineConstants.LUA_TFUNCTION), (L.ci.func).value.gc.cl));
		  idx = DefineConstants.LUA_GLOBALSINDEX - idx;
		  return (idx <= func.c.nupvalues) ? func.c.upvalue[idx - 1] : ((lua_TValue)((luaO_nilobject_)));
		}
		  }
	  }
	}


	internal static Table getcurrenv(lua_State L)
	{
	  if (L.ci == L.base_ci) // no enclosing function?
	  {
		return check_exp(((((L.l_gt)).tt) == DefineConstants.LUA_TTABLE), ((L.l_gt)).value.gc.h); // use global table as environment
	  }
	  else
	  {
		Closure func = (check_exp((((L.ci.func).tt) == DefineConstants.LUA_TFUNCTION), (L.ci.func).value.gc.cl));
		return func.c.env;
	  }
	}


	public static int lua_checkstack(lua_State L, int size)
	{
	  int res = 1;
	  (L)(0)(L);
	  if (size > DefineConstants.LUAI_MAXCSTACK || (L.top - L.@base + size) > DefineConstants.LUAI_MAXCSTACK)
	  {
		res = 0; // stack overflow
	  }
	  else if (size > 0)
	  {
		if ((string)L.stack_last - (string)L.top <= (size) * (int)sizeof(lua_TValue) != null)
		{
			luaD_growstack(L, size);
		}
		else
		{
			(x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
		}
		if (L.ci.top < L.top + size)
		{
		  L.ci.top = L.top + size;
		}
	  }
	  (L)(0)(L);
	  return res;
	}


	public static void lua_xmove(lua_State from, lua_State to, int n)
	{
	  int i;
	  if (from == to)
	  {
		  return;
	  }
	  (L)(0)(to);
	  luai_apicheck(from, (n) <= (from.top - from.@base));
	  luai_apicheck(from, (from.l_G) == (to.l_G));
	  luai_apicheck(from, to.ci.top - to.top >= n);
	  from.top -= n;
	  for (i = 0; i < n; i++)
	  {
		{
			lua_TValue o2 = (from.top + i);
			lua_TValue o1 = (to.top++);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
			o1.value.CopyFrom(o2.value);
			o1.tt = o2.tt;
			(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((to.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	};
	  }
	  (L)(0)(to);
	}


	public static void lua_setlevel(lua_State from, lua_State to)
	{
	  to.nCcalls = from.nCcalls;
	}


	public static lua_CFunction lua_atpanic(lua_State L, lua_CFunction panicf)
	{
	  lua_CFunction old;
	  (L)(0)(L);
	  old = (L.l_G).panic;
	  (L.l_G).panic = panicf;
	  (L)(0)(L);
	  return old;
	}


	public static lua_State lua_newthread(lua_State L)
	{
	  lua_State L1;
	  (L)(0)(L);
	  {
		  (x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
		  if ((L.l_G).totalbytes >= (L.l_G).GCthreshold)
		  {
			  luaC_step(L);
		  }
	  };
	  L1 = luaE_newthread(L);
	  {
		  lua_TValue i_o = (L.top);
		  i_o.value.gc = ((union GCObject)((L1)));
		  i_o.tt = DefineConstants.LUA_TTHREAD;
		  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  {
		  luai_apicheck(L, L.top < L.ci.top);
		  L.top++;
  };
	  (L)(0)(L);
	  (L);
	  return L1;
	}



	/*
	** basic stack manipulation
	*/


	public static int lua_gettop(lua_State L)
	{
	  return ((int)((L.top - L.@base)));
	}


	public static void lua_settop(lua_State L, int idx)
	{
	  (L)(0)(L);
	  if (idx >= 0)
	  {
		luai_apicheck(L, idx <= L.stack_last - L.@base);
		while (L.top < L.@base + idx)
		{
		  ((L.top++).tt = DefineConstants.LUA_TNIL);
		}
		L.top = L.@base + idx;
	  }
	  else
	  {
		luai_apicheck(L, -(idx + 1) <= (L.top - L.@base));
		L.top += idx + 1; // `subtract' index (index is negative)
	  }
	  (L)(0)(L);
	}


	public static void lua_remove(lua_State L, int idx)
	{
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  lua_TValue * p = new lua_TValue();
	  (L)(0)(L);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: p = index2adr(L, idx);
	  p.CopyFrom(index2adr(L, idx));
	  luai_apicheck(L, (p) != (luaO_nilobject_));
	  while (++p < L.top)
	  {
		  lua_TValue o2 = (p);
		  lua_TValue o1 = (p - 1);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
		  o1.value.CopyFrom(o2.value);
		  o1.tt = o2.tt;
		  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  L.top--;
	  (L)(0)(L);
	}


	public static void lua_insert(lua_State L, int idx)
	{
	  lua_TValue p;
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  lua_TValue * q = new lua_TValue();
	  (L)(0)(L);
	  p = index2adr(L, idx);
	  luai_apicheck(L, (p) != (luaO_nilobject_));
	  for (q = L.top; q > p; q--)
	  {
		  lua_TValue o2 = (q - 1);
		  lua_TValue o1 = (q);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
		  o1.value.CopyFrom(o2.value);
		  o1.tt = o2.tt;
		  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  {
		  lua_TValue o2 = (L.top);
		  lua_TValue o1 = (p);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
		  o1.value.CopyFrom(o2.value);
		  o1.tt = o2.tt;
		  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
  };
	  (L)(0)(L);
	}


	public static void lua_replace(lua_State L, int idx)
	{
	  lua_TValue o;
	  (L)(0)(L);
	  /* explicit test for incompatible code */
	  if (idx == DefineConstants.LUA_ENVIRONINDEX && L.ci == L.base_ci)
	  {
		luaG_runerror(L, "no calling environment");
	  }
	  luai_apicheck(L, (1) <= (L.top - L.@base));
	  o = index2adr(L, idx);
	  luai_apicheck(L, (o) != (luaO_nilobject_));
	  if (idx == DefineConstants.LUA_ENVIRONINDEX)
	  {
		Closure func = (check_exp((((L.ci.func).tt) == DefineConstants.LUA_TFUNCTION), (L.ci.func).value.gc.cl));
		luai_apicheck(L, (((L.top - 1).tt) == DefineConstants.LUA_TTABLE));
		func.c.env = check_exp((((L.top - 1).tt) == DefineConstants.LUA_TTABLE), (L.top - 1).value.gc.h);
		{
			if (((((L.top - 1).tt) >= DefineConstants.LUA_TSTRING) && (((check_exp((((L.top - 1).tt) >= DefineConstants.LUA_TSTRING), (L.top - 1).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))) && ((((((union GCObject)((func))))).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))))
			{
				luaC_barrierf(L, (((union GCObject)((func)))), check_exp((((L.top - 1).tt) >= DefineConstants.LUA_TSTRING), (L.top - 1).value.gc));
			}
		};
	  }
	  else
	  {
		{
			lua_TValue o2 = (L.top - 1);
			lua_TValue o1 = (o);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
			o1.value.CopyFrom(o2.value);
			o1.tt = o2.tt;
			(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	};
		if (idx < DefineConstants.LUA_GLOBALSINDEX) // function upvalue?
		{
			  if (((((L.top - 1).tt) >= DefineConstants.LUA_TSTRING) && (((check_exp((((L.top - 1).tt) >= DefineConstants.LUA_TSTRING), (L.top - 1).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))) && ((((((union GCObject)(((check_exp((((L.ci.func).tt) == DefineConstants.LUA_TFUNCTION), (L.ci.func).value.gc.cl))))))).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))))
			  {
				  luaC_barrierf(L, (((union GCObject)(((check_exp((((L.ci.func).tt) == DefineConstants.LUA_TFUNCTION), (L.ci.func).value.gc.cl)))))), check_exp((((L.top - 1).tt) >= DefineConstants.LUA_TSTRING), (L.top - 1).value.gc));
			  }
		};
	  }
	  L.top--;
	  (L)(0)(L);
	}


	public static void lua_pushvalue(lua_State L, int idx)
	{
	  (L)(0)(L);
	  {
		  lua_TValue o2 = (index2adr(L, idx));
		  lua_TValue o1 = (L.top);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
		  o1.value.CopyFrom(o2.value);
		  o1.tt = o2.tt;
		  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  {
		  luai_apicheck(L, L.top < L.ci.top);
		  L.top++;
  };
	  (L)(0)(L);
	}



	/*
	** access functions (stack -> C)
	*/


	public static int lua_type(lua_State L, int idx)
	{
	  lua_TValue o = index2adr(L, idx);
	  return (o == (luaO_nilobject_)) ? DefineConstants.LUA_TNONE : ((o).tt);
	}


	public static string lua_typename(lua_State L, int t)
	{
	  ((L));
	  return (t == DefineConstants.LUA_TNONE) ? "no value" : luaT_typenames[t];
	}


	public static int lua_iscfunction(lua_State L, int idx)
	{
	  lua_TValue o = index2adr(L, idx);
	  return (((o).tt) == DefineConstants.LUA_TFUNCTION && check_exp((ttype(o) == DefineConstants.LUA_TFUNCTION), (o).value.gc.cl).c.isC);
	}


	public static int lua_isnumber(lua_State L, int idx)
	{
	  lua_TValue n = new lua_TValue();
	  lua_TValue o = index2adr(L, idx);
	  return (((o).tt) == DefineConstants.LUA_TNUMBER || (((o) = luaV_tonumber(o, n)) != null));
	}


	public static int lua_isstring(lua_State L, int idx)
	{
	  int t = lua_type(L, idx);
	  return (t == DefineConstants.LUA_TSTRING || t == DefineConstants.LUA_TNUMBER);
	}


	public static int lua_isuserdata(lua_State L, int idx)
	{
	  lua_TValue o = index2adr(L, idx);
	  return ((((o).tt) == DefineConstants.LUA_TUSERDATA) || (((o).tt) == DefineConstants.LUA_TLIGHTUSERDATA));
	}


	public static int lua_rawequal(lua_State L, int index1, int index2)
	{
	  lua_TValue o1 = index2adr(L, index1);
	  lua_TValue o2 = index2adr(L, index2);
	  return (o1 == (luaO_nilobject_) || o2 == (luaO_nilobject_)) ? 0 : luaO_rawequalObj(o1, o2);
	}


	public static int lua_equal(lua_State L, int index1, int index2)
	{
	  lua_TValue o1;
	  lua_TValue o2;
	  int i;
	  (L)(0)(L); // may call tag method
	  o1 = index2adr(L, index1);
	  o2 = index2adr(L, index2);
	  i = (o1 == (luaO_nilobject_) || o2 == (luaO_nilobject_)) ? 0 : (((o1).tt) == ((o2).tt) && luaV_equalval(L, o1, o2) != 0);
	  (L)(0)(L);
	  return i;
	}


	public static int lua_lessthan(lua_State L, int index1, int index2)
	{
	  lua_TValue o1;
	  lua_TValue o2;
	  int i;
	  (L)(0)(L); // may call tag method
	  o1 = index2adr(L, index1);
	  o2 = index2adr(L, index2);
	  i = (o1 == (luaO_nilobject_) || o2 == (luaO_nilobject_)) ? 0 : luaV_lessthan(L, o1, o2);
	  (L)(0)(L);
	  return i;
	}



	public static double lua_tonumber(lua_State L, int idx)
	{
	  lua_TValue n = new lua_TValue();
	  lua_TValue o = index2adr(L, idx);
	  if ((((o).tt) == DefineConstants.LUA_TNUMBER || (((o) = luaV_tonumber(o, n)) != null)))
	  {
		return check_exp((((o).tt) == DefineConstants.LUA_TNUMBER), (o).value.n);
	  }
	  else
	  {
		return 0;
	  }
	}


	public static ptrdiff_t lua_tointeger(lua_State L, int idx)
	{
	  lua_TValue n = new lua_TValue();
	  lua_TValue o = index2adr(L, idx);
	  if ((((o).tt) == DefineConstants.LUA_TNUMBER || (((o) = luaV_tonumber(o, n)) != null)))
	  {
		ptrdiff_t res = new ptrdiff_t();
		double num = check_exp((((o).tt) == DefineConstants.LUA_TNUMBER), (o).value.n);
		((res) = (ptrdiff_t)(num));
		return res;
	  }
	  else
	  {
		return 0;
	  }
	}


	public static int lua_toboolean(lua_State L, int idx)
	{
	  lua_TValue o = index2adr(L, idx);
	  return !((((o).tt) == DefineConstants.LUA_TNIL) || ((((o).tt) == DefineConstants.LUA_TBOOLEAN) && check_exp(ttisboolean(o), (o).value.b) == 0));
	}


	public static string lua_tolstring(lua_State L, int idx, size_t len)
	{
	  lua_TValue o = index2adr(L, idx);
	  if (!(((o).tt) == DefineConstants.LUA_TSTRING))
	  {
		(L)(0)(L); // `luaV_tostring' may create a new string
		if (luaV_tostring(L, o) == 0)
		{ // conversion failed?
		  if (len != null)
		  {
			  len = null;
		  }
		  (L)(0)(L);
		  return null;
		}
		{
			(x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
			if ((L.l_G).totalbytes >= (L.l_G).GCthreshold)
			{
				luaC_step(L);
			}
	};
		o = index2adr(L, idx); // previous call may reallocate the stack
		(L)(0)(L);
	  }
	  if (len != null)
	  {
		  len = (check_exp((((o).tt) == DefineConstants.LUA_TSTRING), (o).value.gc.ts).tsv).len;
	  }
	  return ((string)((check_exp((((o).tt) == DefineConstants.LUA_TSTRING), (o).value.gc.ts)) + 1));
	}


	public static size_t lua_objlen(lua_State L, int idx)
	{
	  lua_TValue o = index2adr(L, idx);
	  switch (((o).tt))
	  {
		case DefineConstants.LUA_TSTRING:
			return (check_exp((((o).tt) == DefineConstants.LUA_TSTRING), (o).value.gc.ts).tsv).len;
		case DefineConstants.LUA_TUSERDATA:
			return (check_exp((((o).tt) == DefineConstants.LUA_TUSERDATA), (o).value.gc.u).uv).len;
		case DefineConstants.LUA_TTABLE:
			return luaH_getn(check_exp((((o).tt) == DefineConstants.LUA_TTABLE), (o).value.gc.h));
		case DefineConstants.LUA_TNUMBER:
		{
		  size_t l = new size_t();
		  (L)(0)(L); // `luaV_tostring' may create a new string
		  l = (luaV_tostring(L, o) != 0 ? (check_exp((((o).tt) == DefineConstants.LUA_TSTRING), (o).value.gc.ts).tsv).len : 0);
		  (L)(0)(L);
		  return l;
		}
		default:
			return 0;
	  }
	}


	public static lua_CFunction lua_tocfunction(lua_State L, int idx)
	{
	  lua_TValue o = index2adr(L, idx);
	  return (!(((o).tt) == DefineConstants.LUA_TFUNCTION && clvalue(o).c.isC)) ? null : check_exp((((o).tt) == DefineConstants.LUA_TFUNCTION), (o).value.gc.cl).c.f;
	}


	public static object lua_touserdata(lua_State L, int idx)
	{
	  lua_TValue o = index2adr(L, idx);
	  switch (((o).tt))
	  {
		case DefineConstants.LUA_TUSERDATA:
			return (check_exp((((o).tt) == DefineConstants.LUA_TUSERDATA), (o).value.gc.u) + 1);
		case DefineConstants.LUA_TLIGHTUSERDATA:
			return check_exp((((o).tt) == DefineConstants.LUA_TLIGHTUSERDATA), (o).value.p);
		default:
			return null;
	  }
	}


	public static lua_State lua_tothread(lua_State L, int idx)
	{
	  lua_TValue o = index2adr(L, idx);
	  return (!(((o).tt) == DefineConstants.LUA_TTHREAD)) ? null : check_exp(ttisthread(o), (o).value.gc.th);
	}


	public static object lua_topointer(lua_State L, int idx)
	{
	  lua_TValue o = index2adr(L, idx);
	  switch (((o).tt))
	  {
		case DefineConstants.LUA_TTABLE:
			return check_exp((((o).tt) == DefineConstants.LUA_TTABLE), (o).value.gc.h);
		case DefineConstants.LUA_TFUNCTION:
			return check_exp((((o).tt) == DefineConstants.LUA_TFUNCTION), (o).value.gc.cl);
		case DefineConstants.LUA_TTHREAD:
			return check_exp((((o).tt) == DefineConstants.LUA_TTHREAD), (o).value.gc.th);
		case DefineConstants.LUA_TUSERDATA:
		case DefineConstants.LUA_TLIGHTUSERDATA:
		  return lua_touserdata(L, idx);
		default:
			return null;
	  }
	}



	/*
	** push functions (C -> stack)
	*/


	public static void lua_pushnil(lua_State L)
	{
	  (L)(0)(L);
	  ((L.top).tt = DefineConstants.LUA_TNIL);
	  {
		  luai_apicheck(L, L.top < L.ci.top);
		  L.top++;
	  };
	  (L)(0)(L);
	}


	public static void lua_pushnumber(lua_State L, double n)
	{
	  (L)(0)(L);
	  {
		  lua_TValue i_o = (L.top);
		  i_o.value.n = (n);
		  i_o.tt = DefineConstants.LUA_TNUMBER;
	  };
	  {
		  luai_apicheck(L, L.top < L.ci.top);
		  L.top++;
  };
	  (L)(0)(L);
	}


	public static void lua_pushinteger(lua_State L, ptrdiff_t n)
	{
	  (L)(0)(L);
	  {
		  lua_TValue i_o = (L.top);
		  i_o.value.n = (((double)((n))));
		  i_o.tt = DefineConstants.LUA_TNUMBER;
	  };
	  {
		  luai_apicheck(L, L.top < L.ci.top);
		  L.top++;
  };
	  (L)(0)(L);
	}


	public static void lua_pushlstring(lua_State L, string s, size_t len)
	{
	  (L)(0)(L);
	  {
		  (x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
		  if ((L.l_G).totalbytes >= (L.l_G).GCthreshold)
		  {
			  luaC_step(L);
		  }
	  };
	  {
		  lua_TValue i_o = (L.top);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: i_o->value.gc=((union GCObject *)((luaS_newlstr(L, s, len))));
		  i_o.value.gc = ((union GCObject)(luaS_newlstr(L, s, new size_t(len))));
		  i_o.tt = DefineConstants.LUA_TSTRING;
		  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
  };
  {
		  luai_apicheck(L, L.top < L.ci.top);
		  L.top++;
  };
	  (L)(0)(L);
	}


	public static void lua_pushstring(lua_State L, string s)
	{
	  if (s == null)
	  {
		lua_pushnil(L);
	  }
	  else
	  {
		lua_pushlstring(L, s, s.Length);
	  }
	}


	public static string lua_pushvfstring(lua_State L, string fmt, va_list argp)
	{
	  string ret;
	  (L)(0)(L);
	  {
		  (x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
		  if ((L.l_G).totalbytes >= (L.l_G).GCthreshold)
		  {
			  luaC_step(L);
		  }
	  };
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: ret = luaO_pushvfstring(L, fmt, argp);
	  ret = luaO_pushvfstring(L, fmt, new va_list(argp));
	  (L)(0)(L);
	  return ret;
	}


	public static string lua_pushfstring(lua_State L, string fmt, params object[] LegacyParamArray)
	{
	  string ret;
	//  va_list argp;
	  (L)(0)(L);
	  {
		  (x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
		  if ((L.l_G).totalbytes >= (L.l_G).GCthreshold)
		  {
			  luaC_step(L);
		  }
	  };
  int ParamCount = -1;
	//  va_start(argp, fmt);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: ret = luaO_pushvfstring(L, fmt, argp);
	  ret = luaO_pushvfstring(L, fmt, new va_list(argp));
	//  va_end(argp);
	  (L)(0)(L);
	  return ret;
	}


	public static void lua_pushcclosure(lua_State L, lua_CFunction fn, int n)
	{
	  Closure cl;
	  (L)(0)(L);
	  {
		  (x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
		  if ((L.l_G).totalbytes >= (L.l_G).GCthreshold)
		  {
			  luaC_step(L);
		  }
	  };
	  luai_apicheck(L, (n) <= (L.top - L.@base));
	  cl = luaF_newCclosure(L, n, getcurrenv(L));
	  cl.c.f = fn;
	  L.top -= n;
	  while (n-- != 0)
	  {
			lua_TValue o2 = (L.top + n);
			lua_TValue o1 = (cl.c.upvalue[n]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
			o1.value.CopyFrom(o2.value);
			o1.tt = o2.tt;
			(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  {
		  lua_TValue i_o = (L.top);
		  i_o.value.gc = ((union GCObject)((cl)));
		  i_o.tt = DefineConstants.LUA_TFUNCTION;
		  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
  };
	  (c)(0)(((((((union GCObject)((cl))))).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))));
	  {
		  luai_apicheck(L, L.top < L.ci.top);
		  L.top++;
	  };
	  (L)(0)(L);
	}


	public static void lua_pushboolean(lua_State L, int b)
	{
	  (L)(0)(L);
	  {
		  lua_TValue i_o = (L.top);
		  i_o.value.b = ((b != 0));
		  i_o.tt = DefineConstants.LUA_TBOOLEAN;
	  }; // ensure that true is 1
	  {
		  luai_apicheck(L, L.top < L.ci.top);
		  L.top++;
  };
	  (L)(0)(L);
	}


//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'p', so pointers on this parameter are left unchanged:
	public static void lua_pushlightuserdata(lua_State L, object * p)
	{
	  (L)(0)(L);
	  {
		  lua_TValue i_o = (L.top);
		  i_o.value.p = (p);
		  i_o.tt = DefineConstants.LUA_TLIGHTUSERDATA;
	  };
	  {
		  luai_apicheck(L, L.top < L.ci.top);
		  L.top++;
  };
	  (L)(0)(L);
	}


	public static int lua_pushthread(lua_State L)
	{
	  (L)(0)(L);
	  {
		  lua_TValue i_o = (L.top);
		  i_o.value.gc = ((union GCObject)((L)));
		  i_o.tt = DefineConstants.LUA_TTHREAD;
		  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  {
		  luai_apicheck(L, L.top < L.ci.top);
		  L.top++;
  };
	  (L)(0)(L);
	  return ((L.l_G).mainthread == L);
	}



	/*
	** get functions (Lua -> stack)
	*/


	public static void lua_gettable(lua_State L, int idx)
	{
	  lua_TValue t;
	  (L)(0)(L);
	  t = index2adr(L, idx);
	  luai_apicheck(L, (t) != (luaO_nilobject_));
	  luaV_gettable(L, t, L.top - 1, L.top - 1);
	  (L)(0)(L);
	}


	public static void lua_getfield(lua_State L, int idx, string k)
	{
	  lua_TValue t;
	  lua_TValue key = new lua_TValue();
	  (L)(0)(L);
	  t = index2adr(L, idx);
	  luai_apicheck(L, (t) != (luaO_nilobject_));
	  {
		  lua_TValue i_o = (key);
		  i_o.value.gc = ((union GCObject)((luaS_newlstr(L, k, k.Length))));
		  i_o.tt = DefineConstants.LUA_TSTRING;
		  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  luaV_gettable(L, t, key, L.top);
	  {
		  luai_apicheck(L, L.top < L.ci.top);
		  L.top++;
	  };
	  (L)(0)(L);
	}


	public static void lua_rawget(lua_State L, int idx)
	{
	  lua_TValue t;
	  (L)(0)(L);
	  t = index2adr(L, idx);
	  luai_apicheck(L, (((t).tt) == DefineConstants.LUA_TTABLE));
	  {
		  lua_TValue o2 = (luaH_get(check_exp((((t).tt) == DefineConstants.LUA_TTABLE), (t).value.gc.h), L.top - 1));
		  lua_TValue o1 = (L.top - 1);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
		  o1.value.CopyFrom(o2.value);
		  o1.tt = o2.tt;
		  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  (L)(0)(L);
	}


	public static void lua_rawgeti(lua_State L, int idx, int n)
	{
	  lua_TValue o;
	  (L)(0)(L);
	  o = index2adr(L, idx);
	  luai_apicheck(L, (((o).tt) == DefineConstants.LUA_TTABLE));
	  {
		  lua_TValue o2 = (luaH_getnum(check_exp((((o).tt) == DefineConstants.LUA_TTABLE), (o).value.gc.h), n));
		  lua_TValue o1 = (L.top);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
		  o1.value.CopyFrom(o2.value);
		  o1.tt = o2.tt;
		  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  {
		  luai_apicheck(L, L.top < L.ci.top);
		  L.top++;
  };
	  (L)(0)(L);
	}


	public static void lua_createtable(lua_State L, int narray, int nrec)
	{
	  (L)(0)(L);
	  {
		  (x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
		  if ((L.l_G).totalbytes >= (L.l_G).GCthreshold)
		  {
			  luaC_step(L);
		  }
	  };
	  {
		  lua_TValue i_o = (L.top);
		  i_o.value.gc = ((union GCObject)(luaH_new(L, narray, nrec)));
		  i_o.tt = DefineConstants.LUA_TTABLE;
		  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
  };
  {
		  luai_apicheck(L, L.top < L.ci.top);
		  L.top++;
  };
	  (L)(0)(L);
	}


	public static int lua_getmetatable(lua_State L, int objindex)
	{
	  lua_TValue obj;
	  Table[] mt = null;
	  int res;
	  (L)(0)(L);
	  obj = index2adr(L, objindex);
	  switch (((obj).tt))
	  {
		case DefineConstants.LUA_TTABLE:
		  mt = check_exp((((obj).tt) == DefineConstants.LUA_TTABLE), (obj).value.gc.h).metatable;
		  break;
		case DefineConstants.LUA_TUSERDATA:
		  mt = (check_exp((((obj).tt) == DefineConstants.LUA_TUSERDATA), (obj).value.gc.u).uv).metatable;
		  break;
		default:
		  mt = (L.l_G).mt[((obj).tt)];
		  break;
	  }
	  if (mt == null)
	  {
		res = 0;
	  }
	  else
	  {
		{
			lua_TValue i_o = (L.top);
			i_o.value.gc = ((union GCObject)((mt)));
			i_o.tt = DefineConstants.LUA_TTABLE;
			(c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	};
	{
			luai_apicheck(L, L.top < L.ci.top);
			L.top++;
	};
		res = 1;
	  }
	  (L)(0)(L);
	  return res;
	}


	public static void lua_getfenv(lua_State L, int idx)
	{
	  lua_TValue o;
	  (L)(0)(L);
	  o = index2adr(L, idx);
	  luai_apicheck(L, (o) != (luaO_nilobject_));
	  switch (((o).tt))
	  {
		case DefineConstants.LUA_TFUNCTION:
		{
			  lua_TValue i_o = (L.top);
			  i_o.value.gc = ((union GCObject)((check_exp((((o).tt) == DefineConstants.LUA_TFUNCTION), (o).value.gc.cl).c.env)));
			  i_o.tt = DefineConstants.LUA_TTABLE;
			  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		};
		  break;
		case DefineConstants.LUA_TUSERDATA:
		{
			  lua_TValue i_o = (L.top);
			  i_o.value.gc = ((union GCObject)(((check_exp((((o).tt) == DefineConstants.LUA_TUSERDATA), (o).value.gc.u).uv).env)));
			  i_o.tt = DefineConstants.LUA_TTABLE;
			  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		};
		  break;
		case DefineConstants.LUA_TTHREAD:
		{
			  lua_TValue o2 = ((check_exp((((o).tt) == DefineConstants.LUA_TTHREAD), (o).value.gc.th).l_gt));
			  lua_TValue o1 = (L.top);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
			  o1.value.CopyFrom(o2.value);
			  o1.tt = o2.tt;
			  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		};
		  break;
		default:
		  ((L.top).tt = DefineConstants.LUA_TNIL);
		  break;
	  }
	  {
		  luai_apicheck(L, L.top < L.ci.top);
		  L.top++;
  };
	  (L)(0)(L);
	}


	/*
	** set functions (stack -> Lua)
	*/


	public static void lua_settable(lua_State L, int idx)
	{
	  lua_TValue t;
	  (L)(0)(L);
	  luai_apicheck(L, (2) <= (L.top - L.@base));
	  t = index2adr(L, idx);
	  luai_apicheck(L, (t) != (luaO_nilobject_));
	  luaV_settable(L, t, L.top - 2, L.top - 1);
	  L.top -= 2; // pop index and value
	  (L)(0)(L);
	}


	public static void lua_setfield(lua_State L, int idx, string k)
	{
	  lua_TValue t;
	  lua_TValue key = new lua_TValue();
	  (L)(0)(L);
	  luai_apicheck(L, (1) <= (L.top - L.@base));
	  t = index2adr(L, idx);
	  luai_apicheck(L, (t) != (luaO_nilobject_));
	  {
		  lua_TValue i_o = (key);
		  i_o.value.gc = ((union GCObject)((luaS_newlstr(L, k, k.Length))));
		  i_o.tt = DefineConstants.LUA_TSTRING;
		  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  luaV_settable(L, t, key, L.top - 1);
	  L.top--; // pop value
	  (L)(0)(L);
	}


	public static void lua_rawset(lua_State L, int idx)
	{
	  lua_TValue t;
	  (L)(0)(L);
	  luai_apicheck(L, (2) <= (L.top - L.@base));
	  t = index2adr(L, idx);
	  luai_apicheck(L, (((t).tt) == DefineConstants.LUA_TTABLE));
	  {
		  lua_TValue o2 = (L.top - 1);
		  lua_TValue o1 = (luaH_set(L, check_exp((((t).tt) == DefineConstants.LUA_TTABLE), (t).value.gc.h), L.top - 2));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
		  o1.value.CopyFrom(o2.value);
		  o1.tt = o2.tt;
		  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  {
		  if (((((L.top - 1).tt) >= DefineConstants.LUA_TSTRING) && (((check_exp((((L.top - 1).tt) >= DefineConstants.LUA_TSTRING), (L.top - 1).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))) && ((((((union GCObject)((check_exp((((t).tt) == DefineConstants.LUA_TTABLE), (t).value.gc.h)))))).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))))
		  {
			  luaC_barrierback(L, check_exp((((t).tt) == DefineConstants.LUA_TTABLE), (t).value.gc.h));
		  }
  };
	  L.top -= 2;
	  (L)(0)(L);
	}


	public static void lua_rawseti(lua_State L, int idx, int n)
	{
	  lua_TValue o;
	  (L)(0)(L);
	  luai_apicheck(L, (1) <= (L.top - L.@base));
	  o = index2adr(L, idx);
	  luai_apicheck(L, (((o).tt) == DefineConstants.LUA_TTABLE));
	  {
		  lua_TValue o2 = (L.top - 1);
		  lua_TValue o1 = (luaH_setnum(L, check_exp((((o).tt) == DefineConstants.LUA_TTABLE), (o).value.gc.h), n));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
		  o1.value.CopyFrom(o2.value);
		  o1.tt = o2.tt;
		  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  {
		  if (((((L.top - 1).tt) >= DefineConstants.LUA_TSTRING) && (((check_exp((((L.top - 1).tt) >= DefineConstants.LUA_TSTRING), (L.top - 1).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))) && ((((((union GCObject)((check_exp((((o).tt) == DefineConstants.LUA_TTABLE), (o).value.gc.h)))))).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))))
		  {
			  luaC_barrierback(L, check_exp((((o).tt) == DefineConstants.LUA_TTABLE), (o).value.gc.h));
		  }
  };
	  L.top--;
	  (L)(0)(L);
	}


	public static int lua_setmetatable(lua_State L, int objindex)
	{
	  lua_TValue obj;
	  Table mt;
	  (L)(0)(L);
	  luai_apicheck(L, (1) <= (L.top - L.@base));
	  obj = index2adr(L, objindex);
	  luai_apicheck(L, (obj) != (luaO_nilobject_));
	  if ((((L.top - 1).tt) == DefineConstants.LUA_TNIL))
	  {
		mt = null;
	  }
	  else
	  {
		luai_apicheck(L, (((L.top - 1).tt) == DefineConstants.LUA_TTABLE));
		mt = check_exp((((L.top - 1).tt) == DefineConstants.LUA_TTABLE), (L.top - 1).value.gc.h);
	  }
	  switch (((obj).tt))
	  {
		case DefineConstants.LUA_TTABLE:
		{
		  check_exp((((obj).tt) == DefineConstants.LUA_TTABLE), (obj).value.gc.h).metatable = mt;
		  if (mt != null)
		  {
				if (((((((union GCObject)((mt))))).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))) && ((((((union GCObject)((check_exp((((obj).tt) == DefineConstants.LUA_TTABLE), (obj).value.gc.h)))))).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))))
				{
					luaC_barrierback(L, check_exp((((obj).tt) == DefineConstants.LUA_TTABLE), (obj).value.gc.h));
				}
		  };
		  break;
		}
		case DefineConstants.LUA_TUSERDATA:
		{
		  (check_exp((((obj).tt) == DefineConstants.LUA_TUSERDATA), (obj).value.gc.u).uv).metatable = mt;
		  if (mt != null)
		  {
				if (((((((union GCObject)((mt))))).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))) && ((((((union GCObject)((check_exp((((obj).tt) == DefineConstants.LUA_TUSERDATA), (obj).value.gc.u)))))).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))))
				{
					luaC_barrierf(L, (((union GCObject)((check_exp((((obj).tt) == DefineConstants.LUA_TUSERDATA), (obj).value.gc.u))))), (((union GCObject)((mt)))));
				}
		  };
		  break;
		}
		default:
		{
		  (L.l_G).mt[((obj).tt)] = mt;
		  break;
		}
	  }
	  L.top--;
	  (L)(0)(L);
	  return 1;
	}


	public static int lua_setfenv(lua_State L, int idx)
	{
	  lua_TValue o;
	  int res = 1;
	  (L)(0)(L);
	  luai_apicheck(L, (1) <= (L.top - L.@base));
	  o = index2adr(L, idx);
	  luai_apicheck(L, (o) != (luaO_nilobject_));
	  luai_apicheck(L, (((L.top - 1).tt) == DefineConstants.LUA_TTABLE));
	  switch (((o).tt))
	  {
		case DefineConstants.LUA_TFUNCTION:
		  check_exp((((o).tt) == DefineConstants.LUA_TFUNCTION), (o).value.gc.cl).c.env = check_exp((((L.top - 1).tt) == DefineConstants.LUA_TTABLE), (L.top - 1).value.gc.h);
		  break;
		case DefineConstants.LUA_TUSERDATA:
		  (check_exp((ttype(o) == DefineConstants.LUA_TUSERDATA), (o).value.gc.u).uv).env = check_exp((((L.top - 1).tt) == DefineConstants.LUA_TTABLE), (L.top - 1).value.gc.h);
		  break;
		case DefineConstants.LUA_TTHREAD:
		{
			  lua_TValue i_o = ((check_exp((((o).tt) == DefineConstants.LUA_TTHREAD), (o).value.gc.th).l_gt));
			  i_o.value.gc = ((union GCObject)((check_exp((((L.top - 1).tt) == DefineConstants.LUA_TTABLE), (L.top - 1).value.gc.h))));
			  i_o.tt = DefineConstants.LUA_TTABLE;
			  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		};
		  break;
		default:
		  res = 0;
		  break;
	  }
	  if (res != 0)
	  {
		  if (((((((union GCObject)((check_exp((((L.top - 1).tt) == DefineConstants.LUA_TTABLE), (L.top - 1).value.gc.h)))))).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))) && ((((((union GCObject)((check_exp((((check_exp((((L.top - 1).tt) == DefineConstants.LUA_TTABLE), (L.top - 1).value.gc.h)).tt) >= DefineConstants.LUA_TSTRING), (check_exp((((L.top - 1).tt) == DefineConstants.LUA_TTABLE), (L.top - 1).value.gc.h)).value.gc)))))).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))))
		  {
			  luaC_barrierf(L, (((union GCObject)((check_exp((((check_exp((((L.top - 1).tt) == DefineConstants.LUA_TTABLE), (L.top - 1).value.gc.h)).tt) >= DefineConstants.LUA_TSTRING), (check_exp((((L.top - 1).tt) == DefineConstants.LUA_TTABLE), (L.top - 1).value.gc.h)).value.gc))))), (((union GCObject)((check_exp((((L.top - 1).tt) == DefineConstants.LUA_TTABLE), (L.top - 1).value.gc.h))))));
		  }
	  };
	  L.top--;
	  (L)(0)(L);
	  return res;
	}


	/*
	** `load' and `call' functions (run Lua code)
	*/


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define adjustresults(L,nres) { if (nres == LUA_MULTRET && L->top >= L->ci->top) L->ci->top = L->top; }


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkresults(L,na,nr) api_check(L, (nr) == LUA_MULTRET || (L->ci->top - L->top >= (nr) - (na)))


	public static void lua_call(lua_State L, int nargs, int nresults)
	{
	  lua_TValue func;
	  (L)(0)(L);
	  luai_apicheck(L, (nargs + 1) <= (L.top - L.@base));
	  luai_apicheck(L, (nresults) == DefineConstants.LUA_MULTRET || (L.ci.top - L.top >= (nresults) - (nargs)));
	  func = L.top - (nargs + 1);
	  luaD_call(L, func, nresults);
	  {
		  if (nresults == DefineConstants.LUA_MULTRET && L.top >= L.ci.top)
		  {
			  L.ci.top = L.top;
		  }
	  };
	  (L)(0)(L);
	}


	internal static void f_call(lua_State L, object ud)
	{
	  CallS c = ((CallS)(ud));
	  luaD_call(L, c.func, c.nresults);
	}



	public static int lua_pcall(lua_State L, int nargs, int nresults, int errfunc)
	{
	  CallS c = new CallS();
	  int status;
	  ptrdiff_t func = new ptrdiff_t();
	  (L)(0)(L);
	  luai_apicheck(L, (nargs + 1) <= (L.top - L.@base));
	  luai_apicheck(L, (nresults) == DefineConstants.LUA_MULTRET || (L.ci.top - L.top >= (nresults) - (nargs)));
	  if (errfunc == 0)
	  {
		func = 0;
	  }
	  else
	  {
		lua_TValue o = index2adr(L, errfunc);
		luai_apicheck(L, (o) != (luaO_nilobject_));
		func = ((string)(o) - (string)L.stack);
	  }
	  c.func = L.top - (nargs + 1); // function to be called
	  c.nresults = nresults;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: status = luaD_pcall(L, f_call, &c, ((sbyte *)(c.func) - (sbyte *)L->stack), func);
	  status = luaD_pcall(L, f_call, c, ((string)(c.func) - (string)L.stack), new ptrdiff_t(func));
	  {
		  if (nresults == DefineConstants.LUA_MULTRET && L.top >= L.ci.top)
		  {
			  L.ci.top = L.top;
		  }
	  };
	  (L)(0)(L);
	  return status;
	}


	internal static void f_Ccall(lua_State L, object ud)
	{
	  CCallS c = ((CCallS)(ud));
	  Closure cl;
	  cl = luaF_newCclosure(L, 0, getcurrenv(L));
	  cl.c.f = c.func;
	  {
		  lua_TValue i_o = (L.top);
		  i_o.value.gc = ((union GCObject)((cl)));
		  i_o.tt = DefineConstants.LUA_TFUNCTION;
		  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  }; // push function
	  {
		  luai_apicheck(L, L.top < L.ci.top);
		  L.top++;
  };
  {
		  lua_TValue i_o = (L.top);
		  i_o.value.p = (c.ud);
		  i_o.tt = DefineConstants.LUA_TLIGHTUSERDATA;
  }; // push only argument
  {
		  luai_apicheck(L, L.top < L.ci.top);
		  L.top++;
  };
	  luaD_call(L, L.top - 2, 0);
	}


	public static int lua_cpcall(lua_State L, lua_CFunction func, object ud)
	{
	  CCallS c = new CCallS();
	  int status;
	  (L)(0)(L);
	  c.func = func;
	  c.ud = ud;
	  status = luaD_pcall(L, f_Ccall, c, ((string)(L.top) - (string)L.stack), 0);
	  (L)(0)(L);
	  return status;
	}


	public static int lua_load(lua_State L, lua_Reader reader, object data, string chunkname)
	{
	  Zio z = new Zio();
	  int status;
	  (L)(0)(L);
	  if (chunkname == 0)
	  {
		  chunkname = "?";
	  }
	  luaZ_init(L, z, reader, data);
	  status = luaD_protectedparser(L, z, chunkname);
	  (L)(0)(L);
	  return status;
	}


	public static int lua_dump(lua_State L, lua_Writer writer, object data)
	{
	  int status;
	  lua_TValue o;
	  (L)(0)(L);
	  luai_apicheck(L, (1) <= (L.top - L.@base));
	  o = L.top - 1;
	  if ((((o).tt) == DefineConstants.LUA_TFUNCTION && !check_exp((ttype(o) == DefineConstants.LUA_TFUNCTION), (o).value.gc.cl).c.isC))
	  {
		status = luaU_dump(L, check_exp((((o).tt) == DefineConstants.LUA_TFUNCTION), (o).value.gc.cl).l.p, writer, data, 0);
	  }
	  else
	  {
		status = 1;
	  }
	  (L)(0)(L);
	  return status;
	}


	public static int lua_status(lua_State L)
	{
	  return L.status;
	}


	/*
	** Garbage-collection function
	*/

	public static int lua_gc(lua_State L, int what, int data)
	{
	  int res = 0;
	  global_State g;
	  (L)(0)(L);
	  g = (L.l_G);
	  switch (what)
	  {
		case DefineConstants.LUA_GCSTOP:
		{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: g->GCthreshold = ((LUAI_UMEM)(~(LUAI_UMEM)0)-2);
		  g.GCthreshold.CopyFrom(((LUAI_UMEM)(~(LUAI_UMEM)0) - 2));
		  break;
		}
		case DefineConstants.LUA_GCRESTART:
		{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: g->GCthreshold = g->totalbytes;
		  g.GCthreshold.CopyFrom(g.totalbytes);
		  break;
		}
		case DefineConstants.LUA_GCCOLLECT:
		{
		  luaC_fullgc(L);
		  break;
		}
		case DefineConstants.LUA_GCCOUNT:
		{
		  /* GC values are expressed in Kbytes: #bytes/2^10 */
		  res = ((int)((g.totalbytes >> 10)));
		  break;
		}
		case DefineConstants.LUA_GCCOUNTB:
		{
		  res = ((int)((g.totalbytes & 0x3ff)));
		  break;
		}
		case DefineConstants.LUA_GCSTEP:
		{
		  LUAI_UMEM a = (((LUAI_UMEM)(data)) << 10);
		  if (a <= g.totalbytes)
		  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: g->GCthreshold = g->totalbytes - a;
			g.GCthreshold.CopyFrom(g.totalbytes - a);
		  }
		  else
		  {
			g.GCthreshold = 0;
		  }
		  while (g.GCthreshold <= g.totalbytes)
		  {
			luaC_step(L);
			if (g.gcstate == DefineConstants.GCSpause)
			{ // end of cycle?
			  res = 1; // signal it
			  break;
			}
		  }
		  break;
		}
		case DefineConstants.LUA_GCSETPAUSE:
		{
		  res = g.gcpause;
		  g.gcpause = data;
		  break;
		}
		case DefineConstants.LUA_GCSETSTEPMUL:
		{
		  res = g.gcstepmul;
		  g.gcstepmul = data;
		  break;
		}
		default:
			res = -1; // invalid option
		break;
	  }
	  (L)(0)(L);
	  return res;
	}



	/*
	** miscellaneous functions
	*/


	public static int lua_error(lua_State L)
	{
	  (L)(0)(L);
	  luai_apicheck(L, (1) <= (L.top - L.@base));
	  luaG_errormsg(L);
	  (L)(0)(L);
	  return 0; // to avoid warnings
	}


	public static int lua_next(lua_State L, int idx)
	{
	  lua_TValue t;
	  int more;
	  (L)(0)(L);
	  t = index2adr(L, idx);
	  luai_apicheck(L, (((t).tt) == DefineConstants.LUA_TTABLE));
	  more = luaH_next(L, check_exp((((t).tt) == DefineConstants.LUA_TTABLE), (t).value.gc.h), L.top - 1);
	  if (more != 0)
	  {
		{
			luai_apicheck(L, L.top < L.ci.top);
			L.top++;
	};
	  }
	  else // no more elements
	  {
		L.top -= 1; // remove key
	  }
	  (L)(0)(L);
	  return more;
	}


	public static void lua_concat(lua_State L, int n)
	{
	  (L)(0)(L);
	  luai_apicheck(L, (n) <= (L.top - L.@base));
	  if (n >= 2)
	  {
		{
			(x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
			if ((L.l_G).totalbytes >= (L.l_G).GCthreshold)
			{
				luaC_step(L);
			}
	};
		luaV_concat(L, n, ((int)((L.top - L.@base))) - 1);
		L.top -= (n - 1);
	  }
	  else if (n == 0)
	  { // push empty string
	  {
			lua_TValue i_o = (L.top);
			i_o.value.gc = ((union GCObject)(luaS_newlstr(L, "", 0)));
			i_o.tt = DefineConstants.LUA_TSTRING;
			(c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	};
	{
			luai_apicheck(L, L.top < L.ci.top);
			L.top++;
	};
	  }
	  /* else n == 1; nothing to do */
	  (L)(0)(L);
	}


	public static lua_Alloc lua_getallocf(lua_State L, object[] ud)
	{
	  lua_Alloc f;
	  (L)(0)(L);
	  if (ud != null)
	  {
		  ud[0] = (L.l_G).ud;
	  }
	  f = (L.l_G).frealloc;
	  (L)(0)(L);
	  return f;
	}


	public static void lua_setallocf(lua_State L, lua_Alloc f, object ud)
	{
	  (L)(0)(L);
	  (L.l_G).ud = ud;
	  (L.l_G).frealloc = f;
	  (L)(0)(L);
	}


	public static object lua_newuserdata(lua_State L, size_t size)
	{
	  Udata u;
	  (L)(0)(L);
	  {
		  (x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
		  if ((L.l_G).totalbytes >= (L.l_G).GCthreshold)
		  {
			  luaC_step(L);
		  }
	  };
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: u = luaS_newudata(L, size, getcurrenv(L));
	  u = luaS_newudata(L, new size_t(size), getcurrenv(L));
	  {
		  lua_TValue i_o = (L.top);
		  i_o.value.gc = ((union GCObject)((u)));
		  i_o.tt = DefineConstants.LUA_TUSERDATA;
		  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  {
		  luai_apicheck(L, L.top < L.ci.top);
		  L.top++;
  };
	  (L)(0)(L);
	  return u + 1;
	}




	internal static string aux_upvalue(lua_TValue fi, int n, lua_TValue[] val)
	{
	  Closure f;
	  if (!(((fi).tt) == DefineConstants.LUA_TFUNCTION))
	  {
		  return null;
	  }
	  f = check_exp((((fi).tt) == DefineConstants.LUA_TFUNCTION), (fi).value.gc.cl);
	  if (f.c.isC != 0)
	  {
		if (!(1 <= n != 0 && n <= f.c.nupvalues))
		{
			return null;
		}
		val[0] = f.c.upvalue[n - 1];
		return "";
	  }
	  else
	  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: Proto *p = f->l.p;
		Proto[] p = new Proto(f.l.p);
		if (!(1 <= n != 0 && n <= p.sizeupvalues))
		{
			return null;
		}
		val[0] = f.l.upvals[n - 1].v;
		return ((string)((p.upvalues[n - 1]) + 1));
	  }
	}


	public static string lua_getupvalue(lua_State L, int funcindex, int n)
	{
	  string name;
	  lua_TValue val;
	  (L)(0)(L);
	  name = aux_upvalue(index2adr(L, funcindex), n, val);
	  if (name != 0)
	  {
		{
			lua_TValue o2 = (val);
			lua_TValue o1 = (L.top);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
			o1.value.CopyFrom(o2.value);
			o1.tt = o2.tt;
			(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	};
	{
			luai_apicheck(L, L.top < L.ci.top);
			L.top++;
	};
	  }
	  (L)(0)(L);
	  return name;
	}


	public static string lua_setupvalue(lua_State L, int funcindex, int n)
	{
	  string name;
	  lua_TValue val;
	  lua_TValue fi;
	  (L)(0)(L);
	  fi = index2adr(L, funcindex);
	  luai_apicheck(L, (1) <= (L.top - L.@base));
	  name = aux_upvalue(fi, n, val);
	  if (name != 0)
	  {
		L.top--;
		{
			lua_TValue o2 = (L.top);
			lua_TValue o1 = (val);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
			o1.value.CopyFrom(o2.value);
			o1.tt = o2.tt;
			(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		};
		{
			if (((ttype(L.top) >= DefineConstants.LUA_TSTRING) && (((check_exp((ttype(L.top) >= DefineConstants.LUA_TSTRING), (L.top).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))) && ((((((union GCObject)((check_exp((((fi).tt) == DefineConstants.LUA_TFUNCTION), (fi).value.gc.cl)))))).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))))
			{
				luaC_barrierf(L, (((union GCObject)((check_exp((((fi).tt) == DefineConstants.LUA_TFUNCTION), (fi).value.gc.cl))))), check_exp((((L.top).tt) >= DefineConstants.LUA_TSTRING), (L.top).value.gc));
			}
	};
	  }
	  (L)(0)(L);
	  return name;
	}


	/*
	** $Id: lauxlib.c,v 1.159.1.3 2008/01/21 13:20:51 roberto Exp $
	** Auxiliary functions for building Lua libraries
	** See Copyright Notice in lua.h
	*/




	/* This file uses only the official API of Lua.
	** Any function declared here could be written as an application function.
	*/


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)

	/*
	** $Id: lauxlib.h,v 1.88.1.1 2007/12/27 13:02:25 roberto Exp $
	** Auxiliary functions for building Lua libraries
	** See Copyright Notice in lua.h
	*/







	#if LUA_COMPAT_GETN
	extern int(luaL_getn)(struct lua_State * L, int t);
	extern void(luaL_setn)(struct lua_State * L, int t, int n);
	#else
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getn(L,i) ((int)lua_objlen(L, i))
	#define luaL_getn
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_setn(L,i,j) ((void)0)
	#define luaL_setn
	#endif

	#if LUA_COMPAT_OPENLIB
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaI_openlib luaL_openlib
	#define luaI_openlib
	#endif



	extern void(luaL_openlib)(struct lua_State * L, const sbyte * libname, const luaL_Reg * l, int nup);
	extern void(luaL_register)(struct lua_State * L, const sbyte * libname, const luaL_Reg * l);
	extern int(luaL_getmetafield)(struct lua_State * L, int obj, const sbyte * e);
	extern int(luaL_callmeta)(struct lua_State * L, int obj, const sbyte * e);
	extern int(luaL_typerror)(struct lua_State * L, int narg, const sbyte * tname);
	extern int(luaL_argerror)(struct lua_State * L, int numarg, const sbyte * extramsg);
	extern const sbyte * (luaL_checklstring)(struct lua_State * L, int numArg, size_t * l);
	extern const sbyte * (luaL_optlstring)(struct lua_State * L, int numArg, const sbyte * def, size_t * l);
	extern double(luaL_checknumber)(struct lua_State * L, int numArg);
	extern double(luaL_optnumber)(struct lua_State * L, int nArg, double def);

	extern ptrdiff_t(luaL_checkinteger)(struct lua_State * L, int numArg);
	extern ptrdiff_t(luaL_optinteger)(struct lua_State * L, int nArg, ptrdiff_t def);

	extern void(luaL_checkstack)(struct lua_State * L, int sz, const sbyte * msg);
	extern void(luaL_checktype)(struct lua_State * L, int narg, int t);
	extern void(luaL_checkany)(struct lua_State * L, int narg);

	extern int(luaL_newmetatable)(struct lua_State * L, const sbyte * tname);
	extern object * (luaL_checkudata)(struct lua_State * L, int ud, const sbyte * tname);

	extern void(luaL_where)(struct lua_State * L, int lvl);
	extern int(luaL_error)(struct lua_State * L, const sbyte * fmt, ...);

	extern int(luaL_checkoption)(struct lua_State * L, int narg, const sbyte * def, const sbyte * const lst[]);

	extern int(luaL_ref)(struct lua_State * L, int t);
	extern void(luaL_unref)(struct lua_State * L, int t, int @ref);

	extern int(luaL_loadfile)(struct lua_State * L, const sbyte * filename);
	extern int(luaL_loadbuffer)(struct lua_State * L, const sbyte * buff, size_t sz, const sbyte * name);
	extern int(luaL_loadstring)(struct lua_State * L, const sbyte * s);

	extern struct lua_State * (luaL_newstate)();


	extern const sbyte * (luaL_gsub)(struct lua_State * L, const sbyte * s, const sbyte * p, const sbyte * r);

	extern const sbyte * (luaL_findtable)(struct lua_State * L, int idx, const sbyte * fname, int szhint);

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addchar(B,c) ((void)((B)->p < ((B)->buffer+LUAL_BUFFERSIZE) || luaL_prepbuffer(B)), (*(B)->p++ = (char)(c)))

	/* compatibility only */
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_putchar(B,c) luaL_addchar(B,c)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addsize(B,n) ((B)->p += (n))

	extern void(luaL_buffinit)(struct lua_State * L, luaL_Buffer * B);
	extern sbyte * (luaL_prepbuffer)(luaL_Buffer * B);
	extern void(luaL_addlstring)(luaL_Buffer * B, const sbyte * s, size_t l);
	extern void(luaL_addstring)(luaL_Buffer * B, const sbyte * s);
	extern void(luaL_addvalue)(luaL_Buffer * B);
	extern void(luaL_pushresult)(luaL_Buffer * B);


	/* }====================================================== */


	/* compatibility with ref system */

	/* pre-defined references */

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_ref(L,lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : (lua_pushstring(L, "unlocked references are obsolete"), lua_error(L), 0))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unref(L,ref) luaL_unref(L, LUA_REGISTRYINDEX, (ref))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getref(L,ref) lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_reg luaL_Reg








	/* convert a stack index to positive */
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define abs_index(L, i) ((i) > 0 || (i) <= LUA_REGISTRYINDEX ? (i) : lua_gettop(L) + (i) + 1)


	/*
	** {======================================================
	** Error-report functions
	** =======================================================
	*/


	public static int luaL_argerror(lua_State L, int narg, string extramsg)
	{
	  lua_Debug ar = new lua_Debug();
	  if (lua_getstack(L, 0, ar) == 0) // no stack frame?
	  {
		return luaL_error(L, "bad argument #%d (%s)", narg, extramsg);
	  }
	  lua_getinfo(L, "n", ar);
	  if (string.Compare(ar.namewhat, "method") == 0)
	  {
		narg--; // do not count `self'
		if (narg == 0) // error is in the self argument itself?
		{
		  return luaL_error(L, "calling " "'" "%s" "'" " on bad self (%s)", ar.name, extramsg);
		}
	  }
	  if (ar.name == null)
	  {
		ar.name = "?";
	  }
	  return luaL_error(L, "bad argument #%d to " "'" "%s" "'" " (%s)", narg, ar.name, extramsg);
	}


	public static int luaL_typerror(lua_State L, int narg, string tname)
	{
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *msg = lua_pushfstring(L, "%s expected, got %s", tname, lua_typename(L, lua_type(L,(narg))));
	  sbyte msg = lua_pushfstring(L, "%s expected, got %s", tname, lua_typename(L, lua_type(L,(narg))));
	  return luaL_argerror(L, narg, msg);
	}


	internal static void tag_error(lua_State L, int narg, int tag)
	{
	  luaL_typerror(L, narg, lua_typename(L, tag));
	}


	public static void luaL_where(lua_State L, int level)
	{
	  lua_Debug ar = new lua_Debug();
	  if (lua_getstack(L, level, ar) != 0)
	  { // check function at level
		lua_getinfo(L, "Sl", ar); // get info about it
		if (ar.currentline > 0)
		{ // is there info?
		  lua_pushfstring(L, "%s:%d: ", ar.short_src, ar.currentline);
		  return;
		}
	  }
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "", (sizeof("")/sizeof(sbyte))-1);
	  lua_pushlstring(L, "" "", (("").Length) - 1); // else, no information available...
	}


	public static int luaL_error(lua_State L, string fmt, params object[] LegacyParamArray)
	{
	//  va_list argp;
  int ParamCount = -1;
	//  va_start(argp, fmt);
	  luaL_where(L, 1);
	  lua_pushvfstring(L, fmt, argp);
	//  va_end(argp);
	  lua_concat(L, 2);
	  return lua_error(L);
	}

	/* }====================================================== */


	public static int luaL_checkoption(lua_State L, int narg, string def, string[] lst)
	{
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *name = (def) ? (luaL_optlstring(L, (narg), (def), null)) : (luaL_checklstring(L, (narg), null));
	  sbyte name = (def) != 0 ? (luaL_optlstring(L, (narg), (def), null)) : (luaL_checklstring(L, (narg), null));
	  int i;
	  for (i = 0; lst[i] != null; i++)
	  {
		if (string.Compare(lst[i], name) == 0)
		{
		  return i;
		}
	  }
	  return luaL_argerror(L, narg, lua_pushfstring(L, "invalid option " "'" "%s" "'", name));
	}


	public static int luaL_newmetatable(lua_State L, string tname)
	{
	  lua_getfield(L, DefineConstants.LUA_REGISTRYINDEX, tname); // get registry.name
	  if (!(lua_type(L, (-1)) == DefineConstants.LUA_TNIL)) // name already in use?
	  {
		return 0; // leave previous value on top, but return 0
	  }
	  lua_settop(L, -(1) - 1);
	  lua_createtable(L, 0, 0); // create metatable
	  lua_pushvalue(L, -1);
	  lua_setfield(L, DefineConstants.LUA_REGISTRYINDEX, tname); // registry.name = metatable
	  return 1;
	}


	public static object luaL_checkudata(lua_State L, int ud, string tname)
	{
	  object p = lua_touserdata(L, ud);
	  if (p != null)
	  { // value is a userdata?
		if (lua_getmetatable(L, ud))
		{ // does it have a metatable?
		  lua_getfield(L, DefineConstants.LUA_REGISTRYINDEX, tname); // get correct metatable
		  if (lua_rawequal(L, -1, -2))
		  { // does it have the correct mt?
			lua_settop(L, -(2) - 1); // remove both metatables
			return p;
		  }
		}
	  }
	  luaL_typerror(L, ud, tname); // else error
	  return null; // to avoid warnings
	}


	public static void luaL_checkstack(lua_State L, int space, string mes)
	{
	  if (!lua_checkstack(L, space))
	  {
		luaL_error(L, "stack overflow (%s)", mes);
	  }
	}


	public static void luaL_checktype(lua_State L, int narg, int t)
	{
	  if (lua_type(L, narg) != t)
	  {
		tag_error(L, narg, t);
	  }
	}


	public static void luaL_checkany(lua_State L, int narg)
	{
	  if (lua_type(L, narg) == DefineConstants.LUA_TNONE)
	  {
		luaL_argerror(L, narg, "value expected");
	  }
	}


	public static string luaL_checklstring(lua_State L, int narg, size_t len)
	{
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *s = lua_tolstring(L, narg, len);
	  sbyte s = lua_tolstring(L, narg, len);
	  if (s == 0)
	  {
		  tag_error(L, narg, DefineConstants.LUA_TSTRING);
	  }
	  return s;
	}


	public static string luaL_optlstring(lua_State L, int narg, string def, size_t len)
	{
	  if ((lua_type(L, (narg)) <= 0))
	  {
		if (len != null)
		{
		  len = (def != 0 ? def.Length : 0);
		}
		return def;
	  }
	  else
	  {
		  return luaL_checklstring(L, narg, len);
	  }
	}


	public static double luaL_checknumber(lua_State L, int narg)
	{
	  double d = lua_tonumber(L, narg);
	  if (d == 0 && !lua_isnumber(L, narg)) // avoid extra test when d is not 0
	  {
		tag_error(L, narg, DefineConstants.LUA_TNUMBER);
	  }
	  return d;
	}


	public static double luaL_optnumber(lua_State L, int narg, double def)
	{
	  return ((lua_type(L, ((narg))) <= 0) ? (def) : luaL_checknumber(L, (narg)));
	}


	public static ptrdiff_t luaL_checkinteger(lua_State L, int narg)
	{
	  ptrdiff_t d = lua_tointeger(L, narg);
	  if (d == 0 && !lua_isnumber(L, narg)) // avoid extra test when d is not 0
	  {
		tag_error(L, narg, DefineConstants.LUA_TNUMBER);
	  }
	  return d;
	}


	public static ptrdiff_t luaL_optinteger(lua_State L, int narg, ptrdiff_t def)
	{
	  return ((lua_type(L, ((narg))) <= 0) ? (def) : luaL_checkinteger(L, (narg)));
	}


	private extern int luaL_getmetafield(struct lua_State * L, int obj, const sbyte * event)
	{
	  if (!lua_getmetatable(L, obj)) // no metatable?
	  {
		return 0;
	  }
	  lua_pushstring(L, event);
	  lua_rawget(L, -2);
	  if ((lua_type(L, (-1)) == DefineConstants.LUA_TNIL))
	  {
		lua_settop(L, -(2) - 1); // remove metatable and metafield
		return 0;
	  }
	  else
	  {
		lua_remove(L, -2); // remove only metatable
		return 1;
	  }
	}


	private extern int luaL_callmeta(struct lua_State * L, int obj, const sbyte * event)
	{
	  obj = ((obj) > 0 || (obj) <= DefineConstants.LUA_REGISTRYINDEX ? (obj) : lua_gettop(L) + (obj) + 1);
	  if (!luaL_getmetafield(L, obj, event)) // no metafield?
	  {
		return 0;
	  }
	  lua_pushvalue(L, obj);
	  lua_call(L, 1, 1);
	  return 1;
	}


	public static extern void(luaL_register UnnamedParameter)(struct lua_State * L, const sbyte * libname, const luaL_Reg * l)
	{
	  luaL_openlib(L, libname, l, 0);
	}


//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'l', so pointers on this parameter are left unchanged:
	internal static int libsize(luaL_Reg * l)
	{
	  int size = 0;
	  for (; l.name != 0; l++)
	  {
		  size++;
	  }
	  return size;
	}


//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'l', so pointers on this parameter are left unchanged:
	public static void luaL_openlib(lua_State L, string libname, luaL_Reg * l, int nup)
	{
	  if (libname != 0)
	  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: int size = libsize(l);
		int size = libsize(new luaL_Reg(l));
		/* check whether lib already exists */
		luaL_findtable(L, DefineConstants.LUA_REGISTRYINDEX, "_LOADED", 1);
		lua_getfield(L, -1, libname); // get _LOADED[libname]
		if (!(lua_type(L, (-1)) == DefineConstants.LUA_TTABLE))
		{ // not found?
		  lua_settop(L, -(1) - 1); // remove previous result
		  /* try global variable (and create one if it does not exist) */
		  if (luaL_findtable(L, DefineConstants.LUA_GLOBALSINDEX, libname, size) != null)
		  {
			luaL_error(L, "name conflict for module " "'" "%s" "'", libname);
		  }
		  lua_pushvalue(L, -1);
		  lua_setfield(L, -3, libname); // _LOADED[libname] = new table
		}
		lua_remove(L, -2); // remove _LOADED table
		lua_insert(L, -(nup + 1)); // move library table to below upvalues
	  }
	  for (; l.name != 0; l++)
	  {
		int i;
		for (i = 0; i < nup; i++) // copy upvalues to the top
		{
		  lua_pushvalue(L, -nup);
		}
		lua_pushcclosure(L, l.func, nup);
		lua_setfield(L, -(nup + 2), l.name);
	  }
	  lua_settop(L, -(nup) - 1); // remove upvalues
	}



	/*
	** {======================================================
	** getn-setn: size for arrays
	** =======================================================
	*/

	#if LUA_COMPAT_GETN

	internal static int checkint(lua_State L, int topop)
	{
	  int n = (lua_type(L, -1) == DefineConstants.LUA_TNUMBER) ? lua_tointeger(L, -1) : -1;
	  lua_settop(L, -(topop) - 1);
	  return n;
	}


	internal static void getsizes(lua_State L)
	{
	  lua_getfield(L, DefineConstants.LUA_REGISTRYINDEX, "LUA_SIZES");
	  if ((lua_type(L, (-1)) == DefineConstants.LUA_TNIL))
	  { // no `size' table?
		lua_settop(L, -(1) - 1); // remove nil
		lua_createtable(L, 0, 0); // create it
		lua_pushvalue(L, -1); // `size' will be its own metatable
		lua_setmetatable(L, -2);
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "kv", (sizeof("kv")/sizeof(sbyte))-1);
		lua_pushlstring(L, "" "kv", (("kv").Length) - 1);
		lua_setfield(L, -2, "__mode"); // metatable(N).__mode = "kv"
		lua_pushvalue(L, -1);
		lua_setfield(L, DefineConstants.LUA_REGISTRYINDEX, "LUA_SIZES"); // store in register
	  }
	}


//C++ TO C# CONVERTER TODO TASK: The following method format was not recognized, possibly due to an unrecognized macro:
	extern void(0)
	{
	  t = ((t) > 0 || (t) <= DefineConstants.LUA_REGISTRYINDEX ? (t) : lua_gettop(L) + (t) + 1);
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "n", (sizeof("n")/sizeof(sbyte))-1);
	  lua_pushlstring(L, "" "n", (("n").Length) - 1);
	  lua_rawget(L, t);
	  if (checkint(L, 1) >= 0)
	  { // is there a numeric field `n'?
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "n", (sizeof("n")/sizeof(sbyte))-1);
		lua_pushlstring(L, "" "n", (("n").Length) - 1); // use it
		lua_pushinteger(L, n);
		lua_rawset(L, t);
	  }
	  else
	  { // use `sizes'
		getsizes(L);
		lua_pushvalue(L, t);
		lua_pushinteger(L, n);
		lua_rawset(L, -3); // sizes[t] = n
		lua_settop(L, -(1) - 1); // remove `sizes'
	  }
	}


	public static int((int)lua_objlen(struct lua_State * L, int t))
	{
	  int n;
	  t = ((t) > 0 || (t) <= DefineConstants.LUA_REGISTRYINDEX ? (t) : lua_gettop(L) + (t) + 1);
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "n", (sizeof("n")/sizeof(sbyte))-1);
	  lua_pushlstring(L, "" "n", (("n").Length) - 1); // try t.n
	  lua_rawget(L, t);
	  if ((n = checkint(L, 1)) >= 0)
	  {
		  return n;
	  }
	  getsizes(L); // else try sizes[t]
	  lua_pushvalue(L, t);
	  lua_rawget(L, -2);
	  if ((n = checkint(L, 2)) >= 0)
	  {
		  return n;
	  }
	  return (int)lua_objlen(L, t);
	}

	#endif

	/* }====================================================== */



	public static string luaL_gsub(lua_State L, string s, string p, string r)
	{
	  string wild;
	  size_t l = p.Length;
	  luaL_Buffer b = new luaL_Buffer();
	  luaL_buffinit(L, b);
	  while ((wild = StringFunctions.StrStr(s, p)) != null)
	  {
		luaL_addlstring(b, s, wild - s); // push prefix
		luaL_addstring(b, r); // push replacement in place of pattern
		s = wild + l; // continue after `p'
	  }
	  luaL_addstring(b, s); // push last suffix
	  luaL_pushresult(b);
	  return lua_tolstring(L, (-1), null);
	}


	public static string luaL_findtable(lua_State L, int idx, string fname, int szhint)
	{
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  sbyte * e;
	  lua_pushvalue(L, idx);
	  do
	  {
		e = StringFunctions.StrChr(fname, '.');
		if (e == null)
		{
			e = fname.Substring(fname.Length);
		}
		lua_pushlstring(L, fname, e - fname);
		lua_rawget(L, -2);
		if ((lua_type(L, (-1)) == DefineConstants.LUA_TNIL))
		{ // no such field?
		  lua_settop(L, -(1) - 1); // remove this nil
		  lua_createtable(L, 0, (*e == (sbyte)'.' ? 1 : szhint)); // new table for field
		  lua_pushlstring(L, fname, e - fname);
		  lua_pushvalue(L, -2);
		  lua_settable(L, -4); // set new table into field
		}
		else if (!(lua_type(L, (-1)) == DefineConstants.LUA_TTABLE))
		{ // field has a non-table value?
		  lua_settop(L, -(2) - 1); // remove table and value
		  return fname; // return problematic part of the name
		}
		lua_remove(L, -2); // remove previous table
		fname = e + 1;
	  } while (*e == (sbyte)'.');
	  return null;
	}



	/*
	** {======================================================
	** Generic Buffer manipulation
	** =======================================================
	*/


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bufflen(B) ((B)->p - (B)->buffer)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bufffree(B) ((size_t)(LUAL_BUFFERSIZE - bufflen(B)))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LIMIT (LUA_MINSTACK/2)


	internal static int emptybuffer(luaL_Buffer B)
	{
	  size_t l = ((B).p - (B).buffer);
	  if (l == 0)
	  {
		  return 0; // put nothing on stack
	  }
	  else
	  {
		lua_pushlstring(B.L, B.buffer, l);
		B.p = B.buffer;
		B.lvl++;
		return 1;
	  }
	}


	internal static void adjuststack(luaL_Buffer B)
	{
	  if (B.lvl > 1)
	  {
		lua_State L = B.L;
		int toget = 1; // number of levels to concat
		size_t toplen = lua_objlen(L, (-1));
		do
		{
		  size_t l = lua_objlen(L, (-(toget + 1)));
		  if (B.lvl - toget + 1 >= (DefineConstants.LUA_MINSTACK / 2) || toplen > l)
		  {
			toplen += l;
			toget++;
		  }
		  else
		  {
			  break;
		  }
		} while (toget < B.lvl);
		lua_concat(L, toget);
		B.lvl = B.lvl - toget + 1;
	  }
	}


	public static string luaL_prepbuffer(luaL_Buffer B)
	{
	  if (emptybuffer(B) != 0)
	  {
		adjuststack(B);
	  }
	  return B.buffer;
	}


//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 's', so pointers on this parameter are left unchanged:
	public static void luaL_addlstring(luaL_Buffer B, sbyte * s, size_t l)
	{
	  while (l-- != null)
	  {
		(((B).p < ((B).buffer + BUFSIZ) || luaL_prepbuffer(B) != 0), (*(B).p ++= (sbyte)(*s++)));
	  }
	}


	public static void luaL_addstring(luaL_Buffer B, string s)
	{
	  luaL_addlstring(B, s, s.Length);
	}


	public static void luaL_pushresult(luaL_Buffer B)
	{
	  emptybuffer(B);
	  lua_concat(B.L, B.lvl);
	  B.lvl = 1;
	}


	public static void luaL_addvalue(luaL_Buffer B)
	{
	  lua_State L = B.L;
	  size_t vl = new size_t();
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *s = lua_tolstring(L, -1, &vl);
	  sbyte s = lua_tolstring(L, -1, vl);
	  if (vl <= ((size_t)(BUFSIZ - ((B).p - (B).buffer))))
	  { // fit into buffer?
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(B.p, s, vl); // put it there
		B.p += vl;
		lua_settop(L, -(1) - 1); // remove from stack
	  }
	  else
	  {
		if (emptybuffer(B) != 0)
		{
		  lua_insert(L, -2); // put buffer before new value
		}
		B.lvl++; // add new value into B stack
		adjuststack(B);
	  }
	}


	public static void luaL_buffinit(lua_State L, luaL_Buffer B)
	{
	  B.L = L;
	  B.p = B.buffer;
	  B.lvl = 0;
	}

	/* }====================================================== */


	public static int luaL_ref(lua_State L, int t)
	{
	  int @ref;
	  t = ((t) > 0 || (t) <= DefineConstants.LUA_REGISTRYINDEX ? (t) : lua_gettop(L) + (t) + 1);
	  if ((lua_type(L, (-1)) == DefineConstants.LUA_TNIL))
	  {
		lua_settop(L, -(1) - 1); // remove from stack
		return DefineConstants.LUA_REFNIL; // `nil' has a unique fixed reference
	  }
	  lua_rawgeti(L, t, DefineConstants.FREELIST_REF); // get first free element
	  @ref = (int)lua_tointeger(L, -1); // ref = t[FREELIST_REF]
	  lua_settop(L, -(1) - 1); // remove it from stack
	  if (@ref != 0)
	  { // any free element?
		lua_rawgeti(L, t, @ref); // remove it from list
		lua_rawseti(L, t, DefineConstants.FREELIST_REF); // (t[FREELIST_REF] = t[ref])
	  }
	  else
	  { // no free elements
		@ref = (int)lua_objlen(L, t);
		@ref++; // create new reference
	  }
	  lua_rawseti(L, t, @ref);
	  return @ref;
	}


	public static void luaL_unref(lua_State L, int t, int @ref)
	{
	  if (@ref >= 0)
	  {
		t = ((t) > 0 || (t) <= DefineConstants.LUA_REGISTRYINDEX ? (t) : lua_gettop(L) + (t) + 1);
		lua_rawgeti(L, t, DefineConstants.FREELIST_REF);
		lua_rawseti(L, t, @ref); // t[ref] = t[FREELIST_REF]
		lua_pushinteger(L, @ref);
		lua_rawseti(L, t, DefineConstants.FREELIST_REF); // t[FREELIST_REF] = ref
	  }
	}


	internal static string getF(lua_State L, object ud, size_t size)
	{
	  LoadF lf = (LoadF)ud;
	  L;
	  if (lf.extraline != 0)
	  {
		lf.extraline = 0;
		size = 1;
		return "\n";
	  }
	  if (feof(lf.f))
	  {
		  return null;
	  }
	  size = fread(lf.buff, 1, sizeof(sbyte), lf.f);
	  return (size > 0) ? lf.buff : null;
	}


	internal static int errfile(lua_State L, string what, int fnameindex)
	{
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *serr = strerror(errno);
	  sbyte serr = strerror(errno);
	  string filename = lua_tolstring(L, (fnameindex), null) + 1;
	  lua_pushfstring(L, "cannot %s %s: %s", what, filename, serr);
	  lua_remove(L, fnameindex);
	  return (DefineConstants.LUA_ERRERR + 1);
	}


	public static int luaL_loadfile(lua_State L, string filename)
	{
	  LoadF lf = new LoadF();
	  int status;
	  int readstatus;
	  int c;
	  int fnameindex = lua_gettop(L) + 1; // index of filename on the stack
	  lf.extraline = 0;
	  if (filename == null)
	  {
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "=stdin", (sizeof("=stdin")/sizeof(sbyte))-1);
		lua_pushlstring(L, "" "=stdin", (("=stdin").Length) - 1);
		lf.f = stdin;
	  }
	  else
	  {
		lua_pushfstring(L, "@%s", filename);
		lf.f = fopen(filename, "r");
		if (lf.f == null)
		{
			return errfile(L, "open", fnameindex);
		}
	  }
	  c = getc(lf.f);
	  if (c == '#')
	  { // Unix exec. file?
		lf.extraline = 1;
//C++ TO C# CONVERTER TODO TASK: Variables cannot be declared in if/while/switch conditions in C#:
		while ((c = getc(lf.f)) != EOF && c != '\n') // skip first line
		{
			;
		}
		if (c == '\n')
		{
			c = getc(lf.f);
		}
	  }
	  if (c == DefineConstants.LUA_SIGNATURE[0] && filename != 0)
	  { // binary file?
		lf.f = freopen(filename, "rb", lf.f); // reopen in binary mode
		if (lf.f == null)
		{
			return errfile(L, "reopen", fnameindex);
		}
		/* skip eventual `#!...' */
//C++ TO C# CONVERTER TODO TASK: Variables cannot be declared in if/while/switch conditions in C#:
	   while ((c = getc(lf.f)) != EOF && c != DefineConstants.LUA_SIGNATURE[0])
	   {
		   ;
	   }
		lf.extraline = 0;
	  }
	  ungetc(c, lf.f);
	  status = lua_load(L, getF, lf, lua_tolstring(L, (-1), null));
	  readstatus = ferror(lf.f);
	  if (filename != 0)
	  {
		  fclose(lf.f); // close file (even in case of errors)
	  }
	  if (readstatus != 0)
	  {
		lua_settop(L, fnameindex); // ignore results from `lua_load'
		return errfile(L, "read", fnameindex);
	  }
	  lua_remove(L, fnameindex);
	  return status;
	}


	internal static string getS(lua_State L, object ud, size_t size)
	{
	  LoadS ls = (LoadS)ud;
	  L;
	  if (ls.size == 0)
	  {
		  return null;
	  }
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: *size = ls->size;
	  size.CopyFrom(ls.size);
	  ls.size = 0;
	  return ls.s;
	}


	public static int luaL_loadbuffer(lua_State L, string buff, size_t size, string name)
	{
	  LoadS ls = new LoadS();
	  ls.s = buff;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: ls.size = size;
	  ls.size.CopyFrom(size);
	  return lua_load(L, getS, ls, name);
	}


	public static extern int(luaL_loadstring UnnamedParameter)(struct lua_State * L, const sbyte * s)
	{
	  return luaL_loadbuffer(L, s, s.Length, s);
	}



	/* }====================================================== */


	internal static object l_alloc(object ud, object ptr, size_t osize, size_t nsize)
	{
	  ud;
	  osize;
	  if (nsize == 0)
	  {
//C++ TO C# CONVERTER TODO TASK: The memory management function 'free' has no equivalent in C#:
		free(ptr);
		return null;
	  }
	  else
	  {
//C++ TO C# CONVERTER TODO TASK: The memory management function 'realloc' has no equivalent in C#:
		return realloc(ptr, nsize);
	  }
	}


	internal static int panic(lua_State L)
	{
	  L; // to avoid warnings
	  Console.Error.Write("PANIC: unprotected error in call to Lua API ({0})\n", lua_tolstring(L, (-1), null));
	  return 0;
	}


	public static lua_State luaL_newstate()
	{
	  lua_State L = lua_newstate(l_alloc, null);
	  if (L != null)
	  {
		  lua_atpanic(L, panic);
	  }
	  return L;
	}


	/*
	** $Id: lbaselib.c,v 1.191.1.6 2008/02/14 16:46:22 roberto Exp $
	** Basic library
	** See Copyright Notice in lua.h
	*/





	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_OPENLIB
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getn(L,i) ((int)lua_objlen(L, i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_setn(L,i,j) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaI_openlib luaL_openlib
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_ERRFILE (LUA_ERRERR+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_argcheck(L, cond,numarg,extramsg) ((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkstring(L,n) (luaL_checklstring(L, (n), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optstring(L,n,d) (luaL_optlstring(L, (n), (d), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkint(L,n) ((int)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optint(L,n,d) ((int)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checklong(L,n) ((long)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optlong(L,n,d) ((long)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_typename(L,i) lua_typename(L, lua_type(L,(i)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dofile(L, fn) (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dostring(L, s) (luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getmetatable(L,n) (lua_getfield(L, LUA_REGISTRYINDEX, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_opt(L,f,n,d) (lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addchar(B,c) ((void)((B)->p < ((B)->buffer+LUAL_BUFFERSIZE) || luaL_prepbuffer(B)), (*(B)->p++ = (char)(c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_putchar(B,c) luaL_addchar(B,c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addsize(B,n) ((B)->p += (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_ref(L,lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : (lua_pushstring(L, "unlocked references are obsolete"), lua_error(L), 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unref(L,ref) luaL_unref(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getref(L,ref) lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_reg luaL_Reg
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(x) ((void)0)




	/*
	** If your system does not support `stdout', you can just remove this function.
	** If you need, you can define your own `print' function, following this
	** model but changing `fputs' to put the strings at a proper place
	** (a console window or a log file, for instance).
	*/
	internal static int luaB_print(lua_State L)
	{
	  int n = lua_gettop(L); // number of arguments
	  int i;
	  lua_getfield(L, DefineConstants.LUA_GLOBALSINDEX, ("tostring"));
	  for (i = 1; i <= n; i++)
	  {
		string s;
		lua_pushvalue(L, -1); // function to be called
		lua_pushvalue(L, i); // value to print
		lua_call(L, 1, 1);
		s = lua_tolstring(L, (-1), null); // get result
		if (s == null)
		{
		  return luaL_error(L, "'" "tostring" "'" " must return a string to " "'" "print" "'");
		}
		if (i > 1)
		{
			fputs("\t", stdout);
		}
		fputs(s, stdout);
		lua_settop(L, -(1) - 1); // pop result
	  }
	  fputs("\n", stdout);
	  return 0;
	}


	internal static int luaB_tonumber(lua_State L)
	{
	  int @base = ((int)luaL_optinteger(L, (2), (10)));
	  if (@base == 10)
	  { // standard conversion
		luaL_checkany(L, 1);
		if (lua_isnumber(L, 1))
		{
		  lua_pushnumber(L, lua_tonumber(L, 1));
		  return 1;
		}
	  }
	  else
	  {
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *s1 = (luaL_checklstring(L, (1), null));
		sbyte s1 = (luaL_checklstring(L, (1), null));
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
		sbyte * s2;
		uint n;
		(((2 <= @base != 0 && @base <= 36) || luaL_argerror(L, (2), ("base out of range"))));
		n = strtoul(s1, s2, @base);
		if (s1 != s2)
		{ // at least one valid digit?
		  while (isspace((byte)(*s2)))
		  {
			  s2++; // skip trailing spaces
		  }
		  if (*s2 == (sbyte)'\0')
		  { // no invalid trailing characters?
			lua_pushnumber(L, (double)n);
			return 1;
		  }
		}
	  }
	  lua_pushnil(L); // else not a number
	  return 1;
	}


	internal static int luaB_error(lua_State L)
	{
	  int level = ((int)luaL_optinteger(L, (2), (1)));
	  lua_settop(L, 1);
	  if (lua_isstring(L, 1) && level > 0)
	  { // add extra information?
		luaL_where(L, level);
		lua_pushvalue(L, 1);
		lua_concat(L, 2);
	  }
	  return lua_error(L);
	}


	internal static int luaB_getmetatable(lua_State L)
	{
	  luaL_checkany(L, 1);
	  if (!lua_getmetatable(L, 1))
	  {
		lua_pushnil(L);
		return 1; // no metatable
	  }
	  luaL_getmetafield(L, 1, "__metatable");
	  return 1; // returns either __metatable field (if present) or metatable
	}


	internal static int luaB_setmetatable(lua_State L)
	{
	  int t = lua_type(L, 2);
	  luaL_checktype(L, 1, DefineConstants.LUA_TTABLE);
	  (((t == DefineConstants.LUA_TNIL || t == DefineConstants.LUA_TTABLE) || luaL_argerror(L, (2), ("nil or table expected"))));
	  if (luaL_getmetafield(L, 1, "__metatable"))
	  {
		luaL_error(L, "cannot change a protected metatable");
	  }
	  lua_settop(L, 2);
	  lua_setmetatable(L, 1);
	  return 1;
	}


	internal static void getfunc(lua_State L, int opt)
	{
	  if ((lua_type(L, (1)) == DefineConstants.LUA_TFUNCTION))
	  {
		  lua_pushvalue(L, 1);
	  }
	  else
	  {
		lua_Debug ar = new lua_Debug();
		int level = opt != 0 ? ((int)luaL_optinteger(L, (1), (1))) : ((int)luaL_checkinteger(L, (1)));
		(((level >= 0) || luaL_argerror(L, (1), ("level must be non-negative"))));
		if (lua_getstack(L, level, ar) == 0)
		{
		  luaL_argerror(L, 1, "invalid level");
		}
		lua_getinfo(L, "f", ar);
		if ((lua_type(L, (-1)) == DefineConstants.LUA_TNIL))
		{
		  luaL_error(L, "no function environment for tail call at level %d", level);
		}
	  }
	}


	internal static int luaB_getfenv(lua_State L)
	{
	  getfunc(L, 1);
	  if (lua_iscfunction(L, -1)) // is a C function?
	  {
		lua_pushvalue(L, DefineConstants.LUA_GLOBALSINDEX); // return the thread's global env.
	  }
	  else
	  {
		lua_getfenv(L, -1);
	  }
	  return 1;
	}


	internal static int luaB_setfenv(lua_State L)
	{
	  luaL_checktype(L, 2, DefineConstants.LUA_TTABLE);
	  getfunc(L, 0);
	  lua_pushvalue(L, 2);
	  if (lua_isnumber(L, 1) && lua_tonumber(L, 1) == 0)
	  {
		/* change environment of current thread */
		lua_pushthread(L);
		lua_insert(L, -2);
		lua_setfenv(L, -2);
		return 0;
	  }
	  else if (lua_iscfunction(L, -2) || lua_setfenv(L, -2) == 0)
	  {
		luaL_error(L, "'" "setfenv" "'" " cannot change environment of given object");
	  }
	  return 1;
	}


	internal static int luaB_rawequal(lua_State L)
	{
	  luaL_checkany(L, 1);
	  luaL_checkany(L, 2);
	  lua_pushboolean(L, lua_rawequal(L, 1, 2));
	  return 1;
	}


	internal static int luaB_rawget(lua_State L)
	{
	  luaL_checktype(L, 1, DefineConstants.LUA_TTABLE);
	  luaL_checkany(L, 2);
	  lua_settop(L, 2);
	  lua_rawget(L, 1);
	  return 1;
	}

	internal static int luaB_rawset(lua_State L)
	{
	  luaL_checktype(L, 1, DefineConstants.LUA_TTABLE);
	  luaL_checkany(L, 2);
	  luaL_checkany(L, 3);
	  lua_settop(L, 3);
	  lua_rawset(L, 1);
	  return 1;
	}


	internal static int luaB_gcinfo(lua_State L)
	{
	  lua_pushinteger(L, lua_gc(L, DefineConstants.LUA_GCCOUNT, 0));
	  return 1;
	}


	internal static int luaB_collectgarbage(lua_State L)
	{
	  string[] opts = {"stop", "restart", "collect", "count", "step", "setpause", "setstepmul", null};
	  int[] optsnum = {DefineConstants.LUA_GCSTOP, DefineConstants.LUA_GCRESTART, DefineConstants.LUA_GCCOLLECT, DefineConstants.LUA_GCCOUNT, DefineConstants.LUA_GCSTEP, DefineConstants.LUA_GCSETPAUSE, DefineConstants.LUA_GCSETSTEPMUL};
	  int o = luaL_checkoption(L, 1, "collect", opts);
	  int ex = ((int)luaL_optinteger(L, (2), (0)));
	  int res = lua_gc(L, optsnum[o], ex);
	  switch (optsnum[o])
	  {
		case DefineConstants.LUA_GCCOUNT:
		{
		  int b = lua_gc(L, DefineConstants.LUA_GCCOUNTB, 0);
		  lua_pushnumber(L, res + ((double)b / 1024));
		  return 1;
		}
		case DefineConstants.LUA_GCSTEP:
		{
		  lua_pushboolean(L, res);
		  return 1;
		}
		default:
		{
		  lua_pushnumber(L, res);
		  return 1;
		}
	  }
	}


	internal static int luaB_type(lua_State L)
	{
	  luaL_checkany(L, 1);
	  lua_pushstring(L, lua_typename(L, lua_type(L,(1))));
	  return 1;
	}


	internal static int luaB_next(lua_State L)
	{
	  luaL_checktype(L, 1, DefineConstants.LUA_TTABLE);
	  lua_settop(L, 2); // create a 2nd argument if there isn't one
	  if (lua_next(L, 1))
	  {
		return 2;
	  }
	  else
	  {
		lua_pushnil(L);
		return 1;
	  }
	}


	internal static int luaB_pairs(lua_State L)
	{
	  luaL_checktype(L, 1, DefineConstants.LUA_TTABLE);
	  lua_pushvalue(L, (DefineConstants.LUA_GLOBALSINDEX - (1))); // return generator,
	  lua_pushvalue(L, 1); // state,
	  lua_pushnil(L); // and initial value
	  return 3;
	}


	internal static int ipairsaux(lua_State L)
	{
	  int i = ((int)luaL_checkinteger(L, (2)));
	  luaL_checktype(L, 1, DefineConstants.LUA_TTABLE);
	  i++; // next value
	  lua_pushinteger(L, i);
	  lua_rawgeti(L, 1, i);
	  return ((lua_type(L, (-1)) == DefineConstants.LUA_TNIL)) ? 0 : 2;
	}


	internal static int luaB_ipairs(lua_State L)
	{
	  luaL_checktype(L, 1, DefineConstants.LUA_TTABLE);
	  lua_pushvalue(L, (DefineConstants.LUA_GLOBALSINDEX - (1))); // return generator,
	  lua_pushvalue(L, 1); // state,
	  lua_pushinteger(L, 0); // and initial value
	  return 3;
	}


	internal static int load_aux(lua_State L, int status)
	{
	  if (status == 0) // OK?
	  {
		return 1;
	  }
	  else
	  {
		lua_pushnil(L);
		lua_insert(L, -2); // put before error message
		return 2; // return nil plus error message
	  }
	}


	internal static int luaB_loadstring(lua_State L)
	{
	  size_t l = new size_t();
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *s = luaL_checklstring(L, 1, &l);
	  sbyte s = luaL_checklstring(L, 1, l);
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *chunkname = (luaL_optlstring(L, (2), (s), null));
	  sbyte chunkname = (luaL_optlstring(L, (2), (s), null));
	  return load_aux(L, luaL_loadbuffer(L, s, l, chunkname));
	}


	internal static int luaB_loadfile(lua_State L)
	{
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *fname = (luaL_optlstring(L, (1), (null), null));
	  sbyte fname = (luaL_optlstring(L, (1), (null), null));
	  return load_aux(L, luaL_loadfile(L, fname));
	}


	/*
	** Reader for generic `load' function: `lua_load' uses the
	** stack for internal stuff, so the reader cannot change the
	** stack top. Instead, it keeps its resulting string in a
	** reserved slot inside the stack.
	*/
	internal static string generic_reader(lua_State L, object ud, size_t size)
	{
	  ud; // to avoid warnings
	  luaL_checkstack(L, 2, "too many nested functions");
	  lua_pushvalue(L, 1); // get function
	  lua_call(L, 0, 1); // call it
	  if ((lua_type(L, (-1)) == DefineConstants.LUA_TNIL))
	  {
		size = null;
		return null;
	  }
	  else if (lua_isstring(L, -1))
	  {
		lua_replace(L, 3); // save string in a reserved stack slot
		return lua_tolstring(L, 3, size);
	  }
	  else
	  {
		  luaL_error(L, "reader function must return a string");
	  }
	  return null; // to avoid warnings
	}


	internal static int luaB_load(lua_State L)
	{
	  int status;
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *cname = (luaL_optlstring(L, (2), ("=(load)"), null));
	  sbyte cname = (luaL_optlstring(L, (2), ("=(load)"), null));
	  luaL_checktype(L, 1, DefineConstants.LUA_TFUNCTION);
	  lua_settop(L, 3); // function, eventual name, plus one reserved slot
	  status = lua_load(L, generic_reader, null, cname);
	  return load_aux(L, status);
	}


	internal static int luaB_dofile(lua_State L)
	{
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *fname = (luaL_optlstring(L, (1), (null), null));
	  sbyte fname = (luaL_optlstring(L, (1), (null), null));
	  int n = lua_gettop(L);
	  if (luaL_loadfile(L, fname) != 0)
	  {
		  lua_error(L);
	  }
	  lua_call(L, 0, DefineConstants.LUA_MULTRET);
	  return lua_gettop(L) - n;
	}


	internal static int luaB_assert(lua_State L)
	{
	  luaL_checkany(L, 1);
	  if (!lua_toboolean(L, 1))
	  {
		return luaL_error(L, "%s", (luaL_optlstring(L, (2), ("assertion failed!"), null)));
	  }
	  return lua_gettop(L);
	}


	internal static int luaB_unpack(lua_State L)
	{
	  int i;
	  int e;
	  int n;
	  luaL_checktype(L, 1, DefineConstants.LUA_TTABLE);
	  i = ((int)luaL_optinteger(L, (2), (1)));
	  e = ((lua_type(L, ((3))) <= 0) ? (((int)lua_objlen(L, 1))) : ((int)luaL_checkinteger(L, ((3)))));
	  if (i > e)
	  {
		  return 0; // empty range
	  }
	  n = e - i + 1; // number of elements
	  if (n <= 0 || !lua_checkstack(L, n)) // n <= 0 means arith. overflow
	  {
		return luaL_error(L, "too many results to unpack");
	  }
	  lua_rawgeti(L, 1, i); // push arg[i] (avoiding overflow problems)
	  while (i++ < e) // push arg[i + 1...e]
	  {
		lua_rawgeti(L, 1, i);
	  }
	  return n;
	}


	internal static int luaB_select(lua_State L)
	{
	  int n = lua_gettop(L);
	  if (lua_type(L, 1) == DefineConstants.LUA_TSTRING && *lua_tolstring(L, (1), null) == '#')
	  {
		lua_pushinteger(L, n - 1);
		return 1;
	  }
	  else
	  {
		int i = ((int)luaL_checkinteger(L, (1)));
		if (i < 0)
		{
			i = n + i;
		}
		else if (i > n)
		{
			i = n;
		}
		(((1 <= i) || luaL_argerror(L, (1), ("index out of range"))));
		return n - i;
	  }
	}


	internal static int luaB_pcall(lua_State L)
	{
	  int status;
	  luaL_checkany(L, 1);
	  status = lua_pcall(L, lua_gettop(L) - 1, DefineConstants.LUA_MULTRET, 0);
	  lua_pushboolean(L, (status == 0));
	  lua_insert(L, 1);
	  return lua_gettop(L); // return status + all results
	}


	internal static int luaB_xpcall(lua_State L)
	{
	  int status;
	  luaL_checkany(L, 2);
	  lua_settop(L, 2);
	  lua_insert(L, 1); // put error function under function to be called
	  status = lua_pcall(L, 0, DefineConstants.LUA_MULTRET, 1);
	  lua_pushboolean(L, (status == 0));
	  lua_replace(L, 1);
	  return lua_gettop(L); // return status + all results
	}


	internal static int luaB_tostring(lua_State L)
	{
	  luaL_checkany(L, 1);
	  if (luaL_callmeta(L, 1, "__tostring")) // is there a metafield?
	  {
		return 1; // use its value
	  }
	  switch (lua_type(L, 1))
	  {
		case DefineConstants.LUA_TNUMBER:
		  lua_pushstring(L, lua_tolstring(L, (1), null));
		  break;
		case DefineConstants.LUA_TSTRING:
		  lua_pushvalue(L, 1);
		  break;
		case DefineConstants.LUA_TBOOLEAN:
		  lua_pushstring(L, (lua_toboolean(L, 1) ? "true" : "false"));
		  break;
		case DefineConstants.LUA_TNIL:
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "nil", (sizeof("nil")/sizeof(sbyte))-1);
		  lua_pushlstring(L, "" "nil", (("nil").Length) - 1);
		  break;
		default:
		  lua_pushfstring(L, "%s: %p", lua_typename(L, lua_type(L,(1))), lua_topointer(L, 1));
		  break;
	  }
	  return 1;
	}


	internal static int luaB_newproxy(lua_State L)
	{
	  lua_settop(L, 1);
	  lua_newuserdata(L, 0); // create proxy
	  if (lua_toboolean(L, 1) == 0)
	  {
		return 1; // no metatable
	  }
	  else if ((lua_type(L, (1)) == DefineConstants.LUA_TBOOLEAN))
	  {
		lua_createtable(L, 0, 0); // create a new metatable `m' ...
		lua_pushvalue(L, -1); // ... and mark `m' as a valid metatable
		lua_pushboolean(L, 1);
		lua_rawset(L, (DefineConstants.LUA_GLOBALSINDEX - (1))); // weaktable[m] = true
	  }
	  else
	  {
		int validproxy = 0; // to check if weaktable[metatable(u)] == true
		if (lua_getmetatable(L, 1))
		{
		  lua_rawget(L, (DefineConstants.LUA_GLOBALSINDEX - (1)));
		  validproxy = lua_toboolean(L, -1);
		  lua_settop(L, -(1) - 1); // remove value
		}
		(((validproxy) != 0 || luaL_argerror(L, (1), ("boolean or proxy expected"))));
		lua_getmetatable(L, 1); // metatable is valid; get it
	  }
	  lua_setmetatable(L, 2);
	  return 1;
	}


	internal luaL_Reg[] base_funcs =
	{
		new luaL_Reg("assert", luaB_assert),
		new luaL_Reg("collectgarbage", luaB_collectgarbage),
		new luaL_Reg("dofile", luaB_dofile),
		new luaL_Reg("error", luaB_error),
		new luaL_Reg("gcinfo", luaB_gcinfo),
		new luaL_Reg("getfenv", luaB_getfenv),
		new luaL_Reg("getmetatable", luaB_getmetatable),
		new luaL_Reg("loadfile", luaB_loadfile),
		new luaL_Reg("load", luaB_load),
		new luaL_Reg("loadstring", luaB_loadstring),
		new luaL_Reg("next", luaB_next),
		new luaL_Reg("pcall", luaB_pcall),
		new luaL_Reg("print", luaB_print),
		new luaL_Reg("rawequal", luaB_rawequal),
		new luaL_Reg("rawget", luaB_rawget),
		new luaL_Reg("rawset", luaB_rawset),
		new luaL_Reg("select", luaB_select),
		new luaL_Reg("setfenv", luaB_setfenv),
		new luaL_Reg("setmetatable", luaB_setmetatable),
		new luaL_Reg("tonumber", luaB_tonumber),
		new luaL_Reg("tostring", luaB_tostring),
		new luaL_Reg("type", luaB_type),
		new luaL_Reg("unpack", luaB_unpack),
		new luaL_Reg("xpcall", luaB_xpcall),
		new luaL_Reg(null, null)
	};


	/*
	** {======================================================
	** Coroutine library
	** =======================================================
	*/


	internal string[] statnames = {"running", "suspended", "normal", "dead"};

	internal static int costatus(lua_State L, lua_State co)
	{
	  if (L == co)
	  {
		  return DefineConstants.CO_RUN;
	  }
	  switch (lua_status(co))
	  {
		case DefineConstants.LUA_YIELD:
		  return DefineConstants.CO_SUS;
		case 0:
		{
		  lua_Debug ar = new lua_Debug();
		  if (lua_getstack(co, 0, ar) > 0) // does it have frames?
		  {
			return DefineConstants.CO_NOR; // it is running
		  }
		  else if (lua_gettop(co) == 0)
		  {
			  return DefineConstants.CO_DEAD;
		  }
		  else
		  {
			return DefineConstants.CO_SUS; // initial state
		  }
		}
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		default: // some error occured
		  return DefineConstants.CO_DEAD;
	  }
	}


	internal static int luaB_costatus(lua_State L)
	{
	  lua_State co = lua_tothread(L, 1);
	  (((co) != null || luaL_argerror(L, (1), ("coroutine expected"))));
	  lua_pushstring(L, statnames[costatus(L, co)]);
	  return 1;
	}


	internal static int auxresume(lua_State L, lua_State co, int narg)
	{
	  int status = costatus(L, co);
	  if (!lua_checkstack(co, narg))
	  {
		luaL_error(L, "too many arguments to resume");
	  }
	  if (status != DefineConstants.CO_SUS)
	  {
		lua_pushfstring(L, "cannot resume %s coroutine", statnames[status]);
		return -1; // error flag
	  }
	  lua_xmove(L, co, narg);
	  lua_setlevel(L, co);
	  status = lua_resume(co, narg);
	  if (status == 0 || status == DefineConstants.LUA_YIELD)
	  {
		int nres = lua_gettop(co);
		if (!lua_checkstack(L, nres + 1))
		{
		  luaL_error(L, "too many results to resume");
		}
		lua_xmove(co, L, nres); // move yielded values
		return nres;
	  }
	  else
	  {
		lua_xmove(co, L, 1); // move error message
		return -1; // error flag
	  }
	}


	internal static int luaB_coresume(lua_State L)
	{
	  lua_State co = lua_tothread(L, 1);
	  int r;
	  (((co) != null || luaL_argerror(L, (1), ("coroutine expected"))));
	  r = auxresume(L, co, lua_gettop(L) - 1);
	  if (r < 0)
	  {
		lua_pushboolean(L, 0);
		lua_insert(L, -2);
		return 2; // return false + error message
	  }
	  else
	  {
		lua_pushboolean(L, 1);
		lua_insert(L, -(r + 1));
		return r + 1; // return true + `resume' returns
	  }
	}


	internal static int luaB_auxwrap(lua_State L)
	{
	  lua_State co = lua_tothread(L, (DefineConstants.LUA_GLOBALSINDEX - (1)));
	  int r = auxresume(L, co, lua_gettop(L));
	  if (r < 0)
	  {
		if (lua_isstring(L, -1))
		{ // error object is a string?
		  luaL_where(L, 1); // add extra info
		  lua_insert(L, -2);
		  lua_concat(L, 2);
		}
		lua_error(L); // propagate error
	  }
	  return r;
	}


	internal static int luaB_cocreate(lua_State L)
	{
	  lua_State NL = lua_newthread(L);
	  ((((lua_type(L, (1)) == DefineConstants.LUA_TFUNCTION) && !lua_iscfunction(L, 1)) || luaL_argerror(L, (1), ("Lua function expected"))));
	  lua_pushvalue(L, 1); // move function to top
	  lua_xmove(L, NL, 1); // move function from L to NL
	  return 1;
	}


	internal static int luaB_cowrap(lua_State L)
	{
	  luaB_cocreate(L);
	  lua_pushcclosure(L, luaB_auxwrap, 1);
	  return 1;
	}


	internal static int luaB_yield(lua_State L)
	{
	  return lua_yield(L, lua_gettop(L));
	}


	internal static int luaB_corunning(lua_State L)
	{
	  if (lua_pushthread(L))
	  {
		lua_pushnil(L); // main thread is not a coroutine
	  }
	  return 1;
	}


	internal luaL_Reg[] co_funcs =
	{
		new luaL_Reg("create", luaB_cocreate),
		new luaL_Reg("resume", luaB_coresume),
		new luaL_Reg("running", luaB_corunning),
		new luaL_Reg("status", luaB_costatus),
		new luaL_Reg("wrap", luaB_cowrap),
		new luaL_Reg("yield", luaB_yield),
		new luaL_Reg(null, null)
	};

	/* }====================================================== */


	internal static void auxopen(lua_State L, string name, lua_CFunction f, lua_CFunction u)
	{
	  lua_pushcclosure(L, (u), 0);
	  lua_pushcclosure(L, f, 1);
	  lua_setfield(L, -2, name);
	}


	internal static void base_open(lua_State L)
	{
	  /* set global _G */
	  lua_pushvalue(L, DefineConstants.LUA_GLOBALSINDEX);
	  lua_setfield(L, DefineConstants.LUA_GLOBALSINDEX, ("_G"));
	  /* open lib into global table */
	  luaL_register(L, "_G", base_funcs);
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" DefineConstants.LUA_VERSION, (sizeof(DefineConstants.LUA_VERSION)/sizeof(sbyte))-1);
	  lua_pushlstring(L, "" DefineConstants.LUA_VERSION, (DefineConstants.LUA_VERSION.Length) - 1);
	  lua_setfield(L, DefineConstants.LUA_GLOBALSINDEX, ("_VERSION")); // set global _VERSION
	  /* `ipairs' and `pairs' need auxliliary functions as upvalues */
	  auxopen(L, "ipairs", luaB_ipairs, ipairsaux);
	  auxopen(L, "pairs", luaB_pairs, luaB_next);
	  /* `newproxy' needs a weaktable as upvalue */
	  lua_createtable(L, 0, 1); // new table `w'
	  lua_pushvalue(L, -1); // `w' will be its own metatable
	  lua_setmetatable(L, -2);
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "kv", (sizeof("kv")/sizeof(sbyte))-1);
	  lua_pushlstring(L, "" "kv", (("kv").Length) - 1);
	  lua_setfield(L, -2, "__mode"); // metatable(w).__mode = "kv"
	  lua_pushcclosure(L, luaB_newproxy, 1);
	  lua_setfield(L, DefineConstants.LUA_GLOBALSINDEX, ("newproxy")); // set global `newproxy'
	}


	public static int luaopen_base(lua_State L)
	{
	  base_open(L);
	  luaL_register(L, DefineConstants.LUA_COLIBNAME, co_funcs);
	  return 2;
	}




	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getcode(fs,e) ((fs)->f->code[(e)->u.s.info])

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaK_codeAsBx(fs,o,A,sBx) luaK_codeABx(fs,o,A,(sBx)+MAXARG_sBx)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaK_setmultret(fs,e) luaK_setreturns(fs, e, LUA_MULTRET)

	public static int luaK_codeABx(FuncState fs, OpCode o, int a, uint bc)
	{
	  (c)(0)((((OpMode)(luaP_opmodes[(int)o] & 3))) == OpMode.iABx || (((OpMode)(luaP_opmodes[(int)o] & 3))) == OpMode.iAsBx);
	  (c)(0)((((OpArgMask)((luaP_opmodes[(int)o] >> 2) & 3))) == OpArgMask.OpArgN);
	  return luaK_code(fs, ((((LUAI_UINT32)(o)) << DefineConstants.POS_OP) | (((LUAI_UINT32)(a)) << (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) | (((LUAI_UINT32)(bc)) << (POS_A + DefineConstants.SIZE_A))), fs.ls.lastline);
	}
	public static int luaK_codeABC(FuncState fs, OpCode o, int a, int b, int c)
	{
	  (c)(0)((((OpMode)(luaP_opmodes[(int)o] & 3))) == OpMode.iABC);
	  (c)(0)((((OpArgMask)((luaP_opmodes[(int)o] >> 4) & 3))) != OpArgMask.OpArgN || b == 0);
	  (c)(0)((((OpArgMask)((luaP_opmodes[(int)o] >> 2) & 3))) != OpArgMask.OpArgN || c == 0);
	  return luaK_code(fs, ((((LUAI_UINT32)(o)) << DefineConstants.POS_OP) | (((LUAI_UINT32)(a)) << (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) | (((LUAI_UINT32)(b)) << (POS_C + DefineConstants.SIZE_C)) | (((LUAI_UINT32)(c)) << (POS_A + DefineConstants.SIZE_A))), fs.ls.lastline);
	}
	public static void luaK_fixline(FuncState fs, int line)
	{
	  fs.f.lineinfo[fs.pc - 1] = line;
	}
	public static void luaK_nil(FuncState fs, int from, int n)
	{
	  LUAI_UINT32 previous;
	  if (fs.pc > fs.lasttarget)
	  { // no jumps to current position?
		if (fs.pc == 0)
		{ // function start?
		  if (from >= fs.nactvar)
		  {
			return; // positions are already clean
		  }
		}
		else
		{
		  previous = fs.f.code[fs.pc - 1];
		  if ((((OpCode)((previous >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))) == OpCode.OP_LOADNIL)
		  {
			int pfrom = (((int)((previous >> (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_A)) << 0))));
			int pto = (((int)((previous >> (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))));
			if (pfrom <= from != 0 && from <= pto + 1)
			{ // can connect both?
			  if (from + n - 1 > pto)
			  {
				(previous = ((previous & (~MASK1(DefineConstants.SIZE_B,(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)))) | ((((LUAI_UINT32)(from + n - 1)) << (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)))));
			  }
			  return;
			}
		  }
		}
	  }
	  luaK_codeABC(fs, OpCode.OP_LOADNIL, from, from + n - 1, 0); // else no optimization
	}
	public static void luaK_reserveregs(FuncState fs, int n)
	{
	  luaK_checkstack(fs, n);
	  fs.freereg += n;
	}
	public static void luaK_checkstack(FuncState fs, int n)
	{
	  int newstack = fs.freereg + n;
	  if (newstack > fs.f.maxstacksize)
	  {
		if (newstack >= DefineConstants.MAXSTACK)
		{
		  luaX_syntaxerror(fs.ls, "function or expression too complex");
		}
		fs.f.maxstacksize = ((byte)((newstack)));
	  }
	}
	public static int luaK_stringK(FuncState fs, TString s)
	{
	  lua_TValue o = new lua_TValue();
	  {
		  lua_TValue i_o = (o);
		  i_o.value.gc = ((union GCObject)((s)));
		  i_o.tt = DefineConstants.LUA_TSTRING;
		  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((fs.L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  return addk(fs, o, o);
	}
	public static int luaK_numberK(FuncState fs, double r)
	{
	  lua_TValue o = new lua_TValue();
	  {
		  lua_TValue i_o = (o);
		  i_o.value.n = (r);
		  i_o.tt = DefineConstants.LUA_TNUMBER;
	  };
	  return addk(fs, o, o);
	}
	public static void luaK_dischargevars(FuncState fs, expdesc e)
	{
	  switch (e.k)
	  {
		case expkind.VLOCAL:
		{
		  e.k = expkind.VNONRELOC;
		  break;
		}
		case expkind.VUPVAL:
		{
		  e.u.s.info = luaK_codeABC(fs, OpCode.OP_GETUPVAL, 0, e.u.s.info, 0);
		  e.k = expkind.VRELOCABLE;
		  break;
		}
		case expkind.VGLOBAL:
		{
		  e.u.s.info = luaK_codeABx(fs, OpCode.OP_GETGLOBAL, 0, e.u.s.info);
		  e.k = expkind.VRELOCABLE;
		  break;
		}
		case expkind.VINDEXED:
		{
		  freereg(fs, e.u.s.aux);
		  freereg(fs, e.u.s.info);
		  e.u.s.info = luaK_codeABC(fs, OpCode.OP_GETTABLE, 0, e.u.s.info, e.u.s.aux);
		  e.k = expkind.VRELOCABLE;
		  break;
		}
		case expkind.VVARARG:
		case expkind.VCALL:
		{
		  luaK_setoneret(fs, e);
		  break;
		}
		default:
			break; // there is one value available (somewhere)
		break;
	  }
	}
	public static int luaK_exp2anyreg(FuncState fs, expdesc e)
	{
	  luaK_dischargevars(fs, e);
	  if (e.k == expkind.VNONRELOC)
	  {
		if (!((e).t != (e).f))
		{
			return e.u.s.info; // exp is already in a register
		}
		if (e.u.s.info >= fs.nactvar)
		{ // reg. is not a local?
		  exp2reg(fs, e, e.u.s.info); // put value on it
		  return e.u.s.info;
		}
	  }
	  luaK_exp2nextreg(fs, e); // default
	  return e.u.s.info;
	}
	public static void luaK_exp2nextreg(FuncState fs, expdesc e)
	{
	  luaK_dischargevars(fs, e);
	  freeexp(fs, e);
	  luaK_reserveregs(fs, 1);
	  exp2reg(fs, e, fs.freereg - 1);
	}
	public static void luaK_exp2val(FuncState fs, expdesc e)
	{
	  if (((e).t != (e).f))
	  {
		luaK_exp2anyreg(fs, e);
	  }
	  else
	  {
		luaK_dischargevars(fs, e);
	  }
	}
	public static int luaK_exp2RK(FuncState fs, expdesc e)
	{
	  luaK_exp2val(fs, e);
	  switch (e.k)
	  {
		case expkind.VKNUM:
		case expkind.VTRUE:
		case expkind.VFALSE:
		case expkind.VNIL:
		{
		  if (fs.nk <= ((1 << (DefineConstants.SIZE_B - 1)) - 1))
		  { // constant fit in RK operand?
			e.u.s.info = (e.k == expkind.VNIL) ? nilK(fs) : (e.k == expkind.VKNUM) ? luaK_numberK(fs, e.u.nval) : boolK(fs, (e.k == expkind.VTRUE));
			e.k = expkind.VK;
			return ((e.u.s.info) | (1 << (DefineConstants.SIZE_B - 1)));
		  }
		  else
		  {
			  break;
		  }
		}
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		case expkind.VK:
		{
		  if (e.u.s.info <= ((1 << (DefineConstants.SIZE_B - 1)) - 1)) // constant fit in argC?
		  {
			return ((e.u.s.info) | (1 << (DefineConstants.SIZE_B - 1)));
		  }
		  else
		  {
			  break;
		  }
		}
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		default:
			break;
	  }
	  /* not a constant in the right range: put it in a register */
	  return luaK_exp2anyreg(fs, e);
	}
	public static void luaK_self(FuncState fs, expdesc e, expdesc key)
	{
	  int func;
	  luaK_exp2anyreg(fs, e);
	  freeexp(fs, e);
	  func = fs.freereg;
	  luaK_reserveregs(fs, 2);
	  luaK_codeABC(fs, OpCode.OP_SELF, func, e.u.s.info, luaK_exp2RK(fs, key));
	  freeexp(fs, key);
	  e.u.s.info = func;
	  e.k = expkind.VNONRELOC;
	}
	public static void luaK_indexed(FuncState fs, expdesc t, expdesc k)
	{
	  t.u.s.aux = luaK_exp2RK(fs, k);
	  t.k = expkind.VINDEXED;
	}
	public static void luaK_goiftrue(FuncState fs, expdesc e)
	{
	  int pc; // pc of last jump
	  luaK_dischargevars(fs, e);
	  switch (e.k)
	  {
		case expkind.VK:
	case expkind.VKNUM:
	case expkind.VTRUE:
	{
		  pc = DefineConstants.NO_JUMP; // always true; do nothing
		  break;
	}
		case expkind.VFALSE:
		{
		  pc = luaK_jump(fs); // always jump
		  break;
		}
		case expkind.VJMP:
		{
		  invertjump(fs, e);
		  pc = e.u.s.info;
		  break;
		}
		default:
		{
		  pc = jumponcond(fs, e, 0);
		  break;
		}
	  }
	  luaK_concat(fs, ref e.f, pc); // insert last jump in `f' list
	  luaK_patchtohere(fs, e.t);
	  e.t = DefineConstants.NO_JUMP;
	}
	public static void luaK_storevar(FuncState fs, expdesc @var, expdesc ex)
	{
	  switch (@var.k)
	  {
		case expkind.VLOCAL:
		{
		  freeexp(fs, ex);
		  exp2reg(fs, ex, @var.u.s.info);
		  return;
		}
		case expkind.VUPVAL:
		{
		  int e = luaK_exp2anyreg(fs, ex);
		  luaK_codeABC(fs, OpCode.OP_SETUPVAL, e, @var.u.s.info, 0);
		  break;
		}
		case expkind.VGLOBAL:
		{
		  int e = luaK_exp2anyreg(fs, ex);
		  luaK_codeABx(fs, OpCode.OP_SETGLOBAL, e, @var.u.s.info);
		  break;
		}
		case expkind.VINDEXED:
		{
		  int e = luaK_exp2RK(fs, ex);
		  luaK_codeABC(fs, OpCode.OP_SETTABLE, @var.u.s.info, @var.u.s.aux, e);
		  break;
		}
		default:
		{
		  (c)(0)(0); // invalid var kind to store
		  break;
		}
	  }
	  freeexp(fs, ex);
	}
	public static void luaK_setreturns(FuncState fs, expdesc e, int nresults)
	{
	  if (e.k == expkind.VCALL)
	  { // expression is an open function call?
		((((fs).f.code[(e).u.s.info])) = (((((fs).f.code[(e).u.s.info])) & (~MASK1(DefineConstants.SIZE_C,((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)))) | ((((LUAI_UINT32)(nresults + 1)) << ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)))));
	  }
	  else if (e.k == expkind.VVARARG)
	  {
		((((fs).f.code[(e).u.s.info])) = (((((fs).f.code[(e).u.s.info])) & (~MASK1(DefineConstants.SIZE_B,(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)))) | ((((LUAI_UINT32)(nresults + 1)) << (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)))));
		((((fs).f.code[(e).u.s.info])) = (((((fs).f.code[(e).u.s.info])) & (~MASK1(DefineConstants.SIZE_A,(DefineConstants.POS_OP + DefineConstants.SIZE_OP)))) | ((((LUAI_UINT32)(fs.freereg)) << (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_A)) << (DefineConstants.POS_OP + DefineConstants.SIZE_OP)))));
		luaK_reserveregs(fs, 1);
	  }
	}
	public static void luaK_setoneret(FuncState fs, expdesc e)
	{
	  if (e.k == expkind.VCALL)
	  { // expression is an open function call?
		e.k = expkind.VNONRELOC;
		e.u.s.info = (((int)(((((fs).f.code[(e).u.s.info])) >> (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_A)) << 0))));
	  }
	  else if (e.k == expkind.VVARARG)
	  {
		((((fs).f.code[(e).u.s.info])) = (((((fs).f.code[(e).u.s.info])) & (~MASK1(DefineConstants.SIZE_B,(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)))) | ((((LUAI_UINT32)(2)) << (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)))));
		e.k = expkind.VRELOCABLE; // can relocate its simple result
	  }
	}
	public static int luaK_jump(FuncState fs)
	{
	  int jpc = fs.jpc; // save list of jumps to here
	  int j;
	  fs.jpc = DefineConstants.NO_JUMP;
	  j = luaK_codeABx(fs, OpCode.OP_JMP, 0, (DefineConstants.NO_JUMP) + MAXARG_sBx);
	  luaK_concat(fs, ref j, jpc); // keep them on hold
	  return j;
	}
	public static void luaK_ret(FuncState fs, int first, int nret)
	{
	  luaK_codeABC(fs, OpCode.OP_RETURN, first, nret + 1, 0);
	}
	public static void luaK_patchlist(FuncState fs, int list, int target)
	{
	  if (target == fs.pc)
	  {
		luaK_patchtohere(fs, list);
	  }
	  else
	  {
		(c)(0)(target < fs.pc);
		patchlistaux(fs, list, target, ((1 << DefineConstants.SIZE_A) - 1), target);
	  }
	}
	public static void luaK_patchtohere(FuncState fs, int list)
	{
	  luaK_getlabel(fs);
	  luaK_concat(fs, ref fs.jpc, list);
	}
	public static void luaK_concat(FuncState fs, ref int l1, int l2)
	{
	  if (l2 == DefineConstants.NO_JUMP)
	  {
		  return;
	  }
	  else if (l1 == DefineConstants.NO_JUMP)
	  {
		l1 = l2;
	  }
	  else
	  {
		int list = l1;
		int next;
		while ((next = getjump(fs, list)) != DefineConstants.NO_JUMP) // find last element
		{
		  list = next;
		}
		fixjump(fs, list, l2);
	  }
	}

/*
** returns current `pc' and marks it as a jump target (to avoid wrong
** optimizations with consecutive instructions not in the same basic block).
*/
	public static int luaK_getlabel(FuncState fs)
	{
	  fs.lasttarget = fs.pc;
	  return fs.pc;
	}
	public static void luaK_prefix(FuncState fs, UnOpr op, expdesc e)
	{
	  expdesc e2 = new expdesc();
	  e2.t = e2.0f = DefineConstants.NO_JUMP;
	  e2.k = expkind.VKNUM;
	  e2.u.nval = 0;
	  switch (op)
	  {
		case UnOpr.OPR_MINUS:
		{
		  if (isnumeral(e) == 0)
		  {
			luaK_exp2anyreg(fs, e); // cannot operate on non-numeric constants
		  }
		  codearith(fs, OpCode.OP_UNM, e, e2);
		  break;
		}
		case UnOpr.OPR_NOT:
			codenot(fs, e);
			break;
		case UnOpr.OPR_LEN:
		{
		  luaK_exp2anyreg(fs, e); // cannot operate on constants
		  codearith(fs, OpCode.OP_LEN, e, e2);
		  break;
		}
		default:
			(c)(0)(0);
		break;
	  }
	}
	public static void luaK_infix(FuncState fs, BinOpr op, expdesc v)
	{
	  switch (op)
	  {
		case BinOpr.OPR_AND:
		{
		  luaK_goiftrue(fs, v);
		  break;
		}
		case BinOpr.OPR_OR:
		{
		  luaK_goiffalse(fs, v);
		  break;
		}
		case BinOpr.OPR_CONCAT:
		{
		  luaK_exp2nextreg(fs, v); // operand must be on the `stack'
		  break;
		}
		case BinOpr.OPR_ADD:
	case BinOpr.OPR_SUB:
	case BinOpr.OPR_MUL:
	case BinOpr.OPR_DIV:
		case BinOpr.OPR_MOD:
	case BinOpr.OPR_POW:
	{
		  if (isnumeral(v) == 0)
		  {
			  luaK_exp2RK(fs, v);
		  }
		  break;
	}
		default:
		{
		  luaK_exp2RK(fs, v);
		  break;
		}
	  }
	}
	public static void luaK_posfix(FuncState fs, BinOpr op, expdesc e1, expdesc e2)
	{
	  switch (op)
	  {
		case BinOpr.OPR_AND:
		{
		  (c)(0)(e1.t == DefineConstants.NO_JUMP); // list must be closed
		  luaK_dischargevars(fs, e2);
		  luaK_concat(fs, ref e2.f, e1.f);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: *e1 = *e2;
		  e1.CopyFrom(e2);
		  break;
		}
		case BinOpr.OPR_OR:
		{
		  (c)(0)(e1.f == DefineConstants.NO_JUMP); // list must be closed
		  luaK_dischargevars(fs, e2);
		  luaK_concat(fs, ref e2.t, e1.t);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: *e1 = *e2;
		  e1.CopyFrom(e2);
		  break;
		}
		case BinOpr.OPR_CONCAT:
		{
		  luaK_exp2val(fs, e2);
		  if (e2.k == expkind.VRELOCABLE && (((OpCode)(((((fs).f.code[(e2).u.s.info])) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))) == OpCode.OP_CONCAT)
		  {
			(c)(0)(e1.u.s.info == (((int)(((((fs).f.code[(e2).u.s.info])) >> (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))) - 1);
			freeexp(fs, e1);
			((((fs).f.code[(e2).u.s.info])) = (((((fs).f.code[(e2).u.s.info])) & (~MASK1(DefineConstants.SIZE_B,(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)))) | ((((LUAI_UINT32)(e1.u.s.info)) << (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)))));
			e1.k = expkind.VRELOCABLE;
			e1.u.s.info = e2.u.s.info;
		  }
		  else
		  {
			luaK_exp2nextreg(fs, e2); // operand must be on the 'stack'
			codearith(fs, OpCode.OP_CONCAT, e1, e2);
		  }
		  break;
		}
		case BinOpr.OPR_ADD:
			codearith(fs, OpCode.OP_ADD, e1, e2);
			break;
		case BinOpr.OPR_SUB:
			codearith(fs, OpCode.OP_SUB, e1, e2);
			break;
		case BinOpr.OPR_MUL:
			codearith(fs, OpCode.OP_MUL, e1, e2);
			break;
		case BinOpr.OPR_DIV:
			codearith(fs, OpCode.OP_DIV, e1, e2);
			break;
		case BinOpr.OPR_MOD:
			codearith(fs, OpCode.OP_MOD, e1, e2);
			break;
		case BinOpr.OPR_POW:
			codearith(fs, OpCode.OP_POW, e1, e2);
			break;
		case BinOpr.OPR_EQ:
			codecomp(fs, OpCode.OP_EQ, 1, e1, e2);
			break;
		case BinOpr.OPR_NE:
			codecomp(fs, OpCode.OP_EQ, 0, e1, e2);
			break;
		case BinOpr.OPR_LT:
			codecomp(fs, OpCode.OP_LT, 1, e1, e2);
			break;
		case BinOpr.OPR_LE:
			codecomp(fs, OpCode.OP_LE, 1, e1, e2);
			break;
		case BinOpr.OPR_GT:
			codecomp(fs, OpCode.OP_LT, 0, e1, e2);
			break;
		case BinOpr.OPR_GE:
			codecomp(fs, OpCode.OP_LE, 0, e1, e2);
			break;
		default:
			(c)(0)(0);
		break;
	  }
	}
	public static void luaK_setlist(FuncState fs, int @base, int nelems, int tostore)
	{
	  int c = (nelems - 1) / DefineConstants.LFIELDS_PER_FLUSH + 1;
	  int b = (tostore == DefineConstants.LUA_MULTRET) ? 0 : tostore;
	  (c)(0)(tostore != 0);
	  if (c <= ((1 << DefineConstants.SIZE_C) - 1))
	  {
		luaK_codeABC(fs, OpCode.OP_SETLIST, @base, b, c);
	  }
	  else
	  {
		luaK_codeABC(fs, OpCode.OP_SETLIST, @base, b, 0);
		luaK_code(fs, ((LUAI_UINT32)(c)), fs.ls.lastline);
	  }
	  fs.freereg = @base + 1; // free registers with list values
	}



	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gfasttm(g,et,e) ((et) == NULL ? NULL : ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define fasttm(l,et,e) gfasttm(G(l), et, e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gt(L) (&L->l_gt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define registry(L) (&G(L)->l_registry)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BASIC_STACK_SIZE (2*LUA_MINSTACK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define curr_func(L) (clvalue(L->ci->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ci_func(ci) (clvalue((ci)->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define f_isLua(ci) (!ci_func(ci)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLua(ci) (ttisfunction((ci)->func) && f_isLua(ci))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define G(L) (L->l_G)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2ts(o) check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2ts(o) (&rawgco2ts(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2u(o) check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2u(o) (&rawgco2u(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2cl(o) check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2h(o) check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2p(o) check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2uv(o) check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ngcotouv(o) check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2th(o) check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define obj2gco(v) (cast(GCObject *, (v)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pcRel(pc, p) (cast(int, (pc) - (p)->code) - 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getline(f,pc) (((f)->lineinfo) ? (f)->lineinfo[pc] : 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resethookcount(L) (L->hookcount = L->basehookcount)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaD_checkstack(L,n) if ((char *)L->stack_last - (char *)L->top <= (n)*(int)sizeof(TValue)) luaD_growstack(L, n); else condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define incr_top(L) {luaD_checkstack(L,1); L->top++;}
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define savestack(L,p) ((char *)(p) - (char *)L->stack)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define restorestack(L,n) ((TValue *)((char *)L->stack + (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define saveci(L,p) ((char *)(p) - (char *)L->base_ci)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define restoreci(L,n) ((CallInfo *)((char *)L->base_ci + (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbits(x,m) ((x) &= cast(lu_byte, ~(m)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbits(x,m) ((x) |= (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbits(x,m) ((x) & (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bitmask(b) (1<<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bit2mask(b1,b2) (bitmask(b1) | bitmask(b2))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_setbit(x,b) setbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbit(x,b) resetbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbit(x,b) testbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define set2bits(x,b1,b2) setbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define reset2bits(x,b1,b2) resetbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define test2bits(x,b1,b2) testbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define WHITEBITS bit2mask(WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iswhite(x) test2bits((x)->gch.marked, WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isblack(x) testbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isgray(x) (!isblack(x) && !iswhite(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define otherwhite(g) (g->currentwhite ^ WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isdead(g,v) ((v)->gch.marked & otherwhite(g) & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define changewhite(x) ((x)->gch.marked ^= WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gray2black(x) l_setbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define valiswhite(x) (iscollectable(x) && iswhite(gcvalue(x)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_white(g) cast(lu_byte, (g)->currentwhite & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_checkGC(L) { condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1)); if (G(L)->totalbytes >= G(L)->GCthreshold) luaC_step(L); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),gcvalue(v)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barriert(L,t,v) { if (valiswhite(v) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarrier(L,p,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),obj2gco(o)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarriert(L,t,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gnode(t,i) (&(t)->node[i])
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gkey(n) (&(n)->i_key.nk)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gval(n) (&(n)->i_val)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gnext(n) ((n)->i_key.nk.next)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define key2tval(n) (&(n)->i_key.tvk)


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define hasjumps(e) ((e)->t != (e)->f)


	internal static int isnumeral(expdesc e)
	{
	  return (e.k == expkind.VKNUM && e.t == DefineConstants.NO_JUMP && e.f == DefineConstants.NO_JUMP);
	}


	internal static int condjump(FuncState fs, OpCode op, int A, int B, int C)
	{
	  luaK_codeABC(fs, op, A, B, C);
	  return luaK_jump(fs);
	}


	internal static void fixjump(FuncState fs, int pc, int dest)
	{
	  LUAI_UINT32 jmp = fs.f.code[pc];
	  int offset = dest - (pc + 1);
	  (c)(0)(dest != DefineConstants.NO_JUMP);
	  if (Math.Abs(offset) > MAXARG_sBx)
	  {
		luaX_syntaxerror(fs.ls, "control structure too long");
	  }
	  (jmp = ((jmp & (~MASK1((DefineConstants.SIZE_C + DefineConstants.SIZE_B),((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)))) | ((cast(LUAI_UINT32, ((uint)((offset) + MAXARG_sBx))) << ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << (DefineConstants.SIZE_C + DefineConstants.SIZE_B))) << ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)))));
	}


	internal static int getjump(FuncState fs, int pc)
	{
	  int offset = ((((int)(((fs.f.code[pc]) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << (DefineConstants.SIZE_C + DefineConstants.SIZE_B))) << 0)))) - MAXARG_sBx);
	  if (offset == DefineConstants.NO_JUMP) // point to itself represents end of list
	  {
		return DefineConstants.NO_JUMP; // end of list
	  }
	  else
	  {
		return (pc + 1) + offset; // turn offset into absolute position
	  }
	}


	internal static LUAI_UINT32 getjumpcontrol(FuncState fs, int pc)
	{
	  LUAI_UINT32 pi = fs.f.code[pc];
	  if (pc >= 1 && (luaP_opmodes[(((OpCode)(((*(pi - 1)) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0))))] & (1 << 7)))
	  {
		return pi - 1;
	  }
	  else
	  {
		return pi;
	  }
	}


	/*
	** check whether list has any jump that do not produce a value
	** (or produce an inverted value)
	*/
	internal static int need_value(FuncState fs, int list)
	{
	  for (; list != DefineConstants.NO_JUMP; list = getjump(fs, list))
	  {
		LUAI_UINT32 i = getjumpcontrol(fs, list);
		if ((((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))) != OpCode.OP_TESTSET)
		{
			return 1;
		}
	  }
	  return 0; // not found
	}


	internal static int patchtestreg(FuncState fs, int node, int reg)
	{
	  LUAI_UINT32 i = getjumpcontrol(fs, node);
	  if ((((OpCode)((i >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))) != OpCode.OP_TESTSET)
	  {
		return 0; // cannot patch other instructions
	  }
	  if (reg != ((1 << DefineConstants.SIZE_A) - 1) && reg != (((int)((i>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))))
	  {
		(i = ((i & (~MASK1(DefineConstants.SIZE_A,(DefineConstants.POS_OP + DefineConstants.SIZE_OP)))) | ((((LUAI_UINT32)(reg)) << (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_A)) << (DefineConstants.POS_OP + DefineConstants.SIZE_OP)))));
	  }
	  else // no register to put value or register already has the value
	  {
		i = ((((LUAI_UINT32)(OpCode.OP_TEST)) << DefineConstants.POS_OP) | (((LUAI_UINT32)((((int)((i>>(POS_C + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))))) << (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) | (((LUAI_UINT32)(0)) << (POS_C + DefineConstants.SIZE_C)) | (((LUAI_UINT32)((((int)((i>>(POS_A + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0)))))) << (POS_A + DefineConstants.SIZE_A)));
	  }

	  return 1;
	}


	internal static void removevalues(FuncState fs, int list)
	{
	  for (; list != DefineConstants.NO_JUMP; list = getjump(fs, list))
	  {
		  patchtestreg(fs, list, ((1 << DefineConstants.SIZE_A) - 1));
	  }
	}


	internal static void patchlistaux(FuncState fs, int list, int vtarget, int reg, int dtarget)
	{
	  while (list != DefineConstants.NO_JUMP)
	  {
		int next = getjump(fs, list);
		if (patchtestreg(fs, list, reg) != 0)
		{
		  fixjump(fs, list, vtarget);
		}
		else
		{
		  fixjump(fs, list, dtarget); // jump to default target
		}
		list = next;
	  }
	}


	internal static void dischargejpc(FuncState fs)
	{
	  patchlistaux(fs, fs.jpc, fs.pc, ((1 << DefineConstants.SIZE_A) - 1), fs.pc);
	  fs.jpc = DefineConstants.NO_JUMP;
	}


	internal static void freereg(FuncState fs, int reg)
	{
	  if (!((reg) & (1 << (DefineConstants.SIZE_B - 1))) && reg >= fs.nactvar)
	  {
		fs.freereg--;
		(c)(0)(reg == fs.freereg);
	  }
	}


	internal static void freeexp(FuncState fs, expdesc e)
	{
	  if (e.k == expkind.VNONRELOC)
	  {
		freereg(fs, e.u.s.info);
	  }
	}


	internal static int addk(FuncState fs, lua_TValue[] k, lua_TValue v)
	{
	  lua_State L = fs.L;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: lua_TValue *idx = luaH_set(L, fs->h, k);
	  lua_TValue idx = luaH_set(L, fs.h, new lua_TValue(k));
	  Proto f = fs.f;
	  int oldsize = f.sizek;
	  if ((((idx).tt) == DefineConstants.LUA_TNUMBER))
	  {
		(c)(0)(luaO_rawequalObj(fs.f.k[((int)((check_exp((((idx).tt) == DefineConstants.LUA_TNUMBER), (idx).value.n))))], v));
		return ((int)((check_exp((((idx).tt) == DefineConstants.LUA_TNUMBER), (idx).value.n))));
	  }
	  else
	  { // constant not found; create a new entry
	  {
			lua_TValue i_o = (idx);
			i_o.value.n = (((double)((fs.nk))));
			i_o.tt = DefineConstants.LUA_TNUMBER;
	};
		if ((fs.nk) + 1 > (f.sizek))
		{
			((f.k) = ((lua_TValue)(luaM_growaux_(L, f.k, ref (f.sizek), sizeof(lua_TValue), MAXARG_Bx, "constant table overflow"))));
		}
		while (oldsize < f.sizek)
		{
			((f.k[oldsize++]).tt = DefineConstants.LUA_TNIL);
		}
		{
			lua_TValue o2 = (v);
			lua_TValue o1 = (f.k[fs.nk]);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
			o1.value.CopyFrom(o2.value);
			o1.tt = o2.tt;
			(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	};
	{
			if (((((v).tt) >= DefineConstants.LUA_TSTRING) && (((check_exp((((v).tt) >= DefineConstants.LUA_TSTRING), (v).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))) && ((((((union GCObject)((f))))).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))))
			{
				luaC_barrierf(L, (((union GCObject)((f)))), check_exp((((v).tt) >= DefineConstants.LUA_TSTRING), (v).value.gc));
			}
	};
		return fs.nk++;
	  }
	}


	internal static int boolK(FuncState fs, int b)
	{
	  lua_TValue o = new lua_TValue();
	  {
		  lua_TValue i_o = (o);
		  i_o.value.b = (b);
		  i_o.tt = DefineConstants.LUA_TBOOLEAN;
	  };
	  return addk(fs, o, o);
	}


	internal static int nilK(FuncState fs)
	{
	  lua_TValue k = new lua_TValue();
	  lua_TValue v = new lua_TValue();
	  ((v).tt = DefineConstants.LUA_TNIL);
	  /* cannot use nil as key; instead use table itself to represent nil */
	  {
		  lua_TValue i_o = (k);
		  i_o.value.gc = ((union GCObject)((fs.h)));
		  i_o.tt = DefineConstants.LUA_TTABLE;
		  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((fs.L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  return addk(fs, k, v);
	}


	internal static int code_label(FuncState fs, int A, int b, int jump)
	{
	  luaK_getlabel(fs); // those instructions may be jump targets
	  return luaK_codeABC(fs, OpCode.OP_LOADBOOL, A, b, jump);
	}


	internal static void discharge2reg(FuncState fs, expdesc e, int reg)
	{
	  luaK_dischargevars(fs, e);
	  switch (e.k)
	  {
		case expkind.VNIL:
		{
		  luaK_nil(fs, reg, 1);
		  break;
		}
		case expkind.VFALSE:
	case expkind.VTRUE:
	{
		  luaK_codeABC(fs, OpCode.OP_LOADBOOL, reg, e.k == expkind.VTRUE, 0);
		  break;
	}
		case expkind.VK:
		{
		  luaK_codeABx(fs, OpCode.OP_LOADK, reg, e.u.s.info);
		  break;
		}
		case expkind.VKNUM:
		{
		  luaK_codeABx(fs, OpCode.OP_LOADK, reg, luaK_numberK(fs, e.u.nval));
		  break;
		}
		case expkind.VRELOCABLE:
		{
		  LUAI_UINT32 pc = ((fs).f.code[(e).u.s.info]);
		  (pc = ((pc & (~MASK1(DefineConstants.SIZE_A,(DefineConstants.POS_OP + DefineConstants.SIZE_OP)))) | ((((LUAI_UINT32)(reg)) << (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_A)) << (DefineConstants.POS_OP + DefineConstants.SIZE_OP)))));
		  break;
		}
		case expkind.VNONRELOC:
		{
		  if (reg != e.u.s.info)
		  {
			luaK_codeABC(fs, OpCode.OP_MOVE, reg, e.u.s.info, 0);
		  }
		  break;
		}
		default:
		{
		  (c)(0)(e.k == expkind.VVOID || e.k == expkind.VJMP);
		  return; // nothing to do...
		}
	  }
	  e.u.s.info = reg;
	  e.k = expkind.VNONRELOC;
	}


	internal static void discharge2anyreg(FuncState fs, expdesc e)
	{
	  if (e.k != expkind.VNONRELOC)
	  {
		luaK_reserveregs(fs, 1);
		discharge2reg(fs, e, fs.freereg - 1);
	  }
	}


	internal static void exp2reg(FuncState fs, expdesc e, int reg)
	{
	  discharge2reg(fs, e, reg);
	  if (e.k == expkind.VJMP)
	  {
		luaK_concat(fs, ref e.t, e.u.s.info); // put this jump in `t' list
	  }
	  if (((e).t != (e).f))
	  {
		int final; // position after whole expression
		int p_f = DefineConstants.NO_JUMP; // position of an eventual LOAD false
		int p_t = DefineConstants.NO_JUMP; // position of an eventual LOAD true
		if (need_value(fs, e.t) != 0 || need_value(fs, e.f) != 0)
		{
		  int fj = (e.k == expkind.VJMP) ? DefineConstants.NO_JUMP : luaK_jump(fs);
		  p_f = code_label(fs, reg, 0, 1);
		  p_t = code_label(fs, reg, 1, 0);
		  luaK_patchtohere(fs, fj);
		}
		final = luaK_getlabel(fs);
		patchlistaux(fs, e.f, final, reg, p_f);
		patchlistaux(fs, e.t, final, reg, p_t);
	  }
	  e.f = e.t = DefineConstants.NO_JUMP;
	  e.u.s.info = reg;
	  e.k = expkind.VNONRELOC;
	}


	internal static void invertjump(FuncState fs, expdesc e)
	{
	  LUAI_UINT32 pc = getjumpcontrol(fs, e.u.s.info);
	  (c)(0)((luaP_opmodes[(((OpCode)((pc >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0))))] & (1 << 7)) && (((OpCode)((pc>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))) != OpCode.OP_TESTSET && (((OpCode)((pc>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))) != OpCode.OP_TEST);
	  (pc = ((pc & (~MASK1(DefineConstants.SIZE_A,(DefineConstants.POS_OP + DefineConstants.SIZE_OP)))) | ((((LUAI_UINT32)(!((((int)((pc >> (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_A)) << 0))))))) << (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_A)) << (DefineConstants.POS_OP + DefineConstants.SIZE_OP)))));
	}


	internal static int jumponcond(FuncState fs, expdesc e, int cond)
	{
	  if (e.k == expkind.VRELOCABLE)
	  {
		LUAI_UINT32 ie = ((fs).f.code[(e).u.s.info]);
		if ((((OpCode)(((ie) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))) == OpCode.OP_NOT)
		{
		  fs.pc--; // remove previous OP_NOT
		  return condjump(fs, OpCode.OP_TEST, (((int)(((ie) >> (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))), 0, cond == 0);
		}
		/* else go through */
	  }
	  discharge2anyreg(fs, e);
	  freeexp(fs, e);
	  return condjump(fs, OpCode.OP_TESTSET, ((1 << DefineConstants.SIZE_A) - 1), e.u.s.info, cond);
	}


	internal static void luaK_goiffalse(FuncState fs, expdesc e)
	{
	  int pc; // pc of last jump
	  luaK_dischargevars(fs, e);
	  switch (e.k)
	  {
		case expkind.VNIL:
	case expkind.VFALSE:
	{
		  pc = DefineConstants.NO_JUMP; // always false; do nothing
		  break;
	}
		case expkind.VTRUE:
		{
		  pc = luaK_jump(fs); // always jump
		  break;
		}
		case expkind.VJMP:
		{
		  pc = e.u.s.info;
		  break;
		}
		default:
		{
		  pc = jumponcond(fs, e, 1);
		  break;
		}
	  }
	  luaK_concat(fs, ref e.t, pc); // insert last jump in `t' list
	  luaK_patchtohere(fs, e.f);
	  e.f = DefineConstants.NO_JUMP;
	}


	internal static void codenot(FuncState fs, expdesc e)
	{
	  luaK_dischargevars(fs, e);
	  switch (e.k)
	  {
		case expkind.VNIL:
	case expkind.VFALSE:
	{
		  e.k = expkind.VTRUE;
		  break;
	}
		case expkind.VK:
	case expkind.VKNUM:
	case expkind.VTRUE:
	{
		  e.k = expkind.VFALSE;
		  break;
	}
		case expkind.VJMP:
		{
		  invertjump(fs, e);
		  break;
		}
		case expkind.VRELOCABLE:
		case expkind.VNONRELOC:
		{
		  discharge2anyreg(fs, e);
		  freeexp(fs, e);
		  e.u.s.info = luaK_codeABC(fs, OpCode.OP_NOT, 0, e.u.s.info, 0);
		  e.k = expkind.VRELOCABLE;
		  break;
		}
		default:
		{
		  (c)(0)(0); // cannot happen
		  break;
		}
	  }
	  /* interchange true and false lists */
	  {
		  int temp = e.f;
		  e.f = e.t;
		  e.t = temp;
  }
	  removevalues(fs, e.f);
	  removevalues(fs, e.t);
	}


	internal static int constfolding(OpCode op, expdesc e1, expdesc e2)
	{
	  double v1;
	  double v2;
	  double r;
	  if (isnumeral(e1) == 0 || isnumeral(e2) == 0)
	  {
		  return 0;
	  }
	  v1 = e1.u.nval;
	  v2 = e2.u.nval;
	  switch (op)
	  {
		case OpCode.OP_ADD:
			r = ((v1) + (v2));
			break;
		case OpCode.OP_SUB:
			r = ((v1) - (v2));
			break;
		case OpCode.OP_MUL:
			r = ((v1) * (v2));
			break;
		case OpCode.OP_DIV:
		  if (v2 == 0)
		  {
			  return 0; // do not attempt to divide by 0
		  }
		  r = ((v1) / (v2));
		  break;
		case OpCode.OP_MOD:
		  if (v2 == 0)
		  {
			  return 0; // do not attempt to divide by 0
		  }
		  r = ((v1) - Math.Floor((v1) / (v2)) * (v2));
		  break;
		case OpCode.OP_POW:
			r = (Math.Pow(v1,v2));
			break;
		case OpCode.OP_UNM:
			r = (-(v1));
			break;
		case OpCode.OP_LEN:
			return 0; // no constant folding for 'len'
		default:
			(c)(0)(0);
			r = 0;
			break;
	  }
	  if ((!(((r)) == ((r)))))
	  {
		  return 0; // do not attempt to produce NaN
	  }
	  e1.u.nval = r;
	  return 1;
	}


	internal static void codearith(FuncState fs, OpCode op, expdesc e1, expdesc e2)
	{
	  if (constfolding(op, e1, e2) != 0)
	  {
		return;
	  }
	  else
	  {
		int o2 = (op != OpCode.OP_UNM && op != OpCode.OP_LEN) ? luaK_exp2RK(fs, e2) : 0;
		int o1 = luaK_exp2RK(fs, e1);
		if (o1 > o2)
		{
		  freeexp(fs, e1);
		  freeexp(fs, e2);
		}
		else
		{
		  freeexp(fs, e2);
		  freeexp(fs, e1);
		}
		e1.u.s.info = luaK_codeABC(fs, op, 0, o1, o2);
		e1.k = expkind.VRELOCABLE;
	  }
	}


	internal static void codecomp(FuncState fs, OpCode op, int cond, expdesc e1, expdesc e2)
	{
	  int o1 = luaK_exp2RK(fs, e1);
	  int o2 = luaK_exp2RK(fs, e2);
	  freeexp(fs, e2);
	  freeexp(fs, e1);
	  if (cond == 0 && op != OpCode.OP_EQ)
	  {
		int temp; // exchange args to replace by `<' or `<='
		temp = o1;
		o1 = o2;
		o2 = temp; // o1 <==> o2
		cond = 1;
	  }
	  e1.u.s.info = condjump(fs, op, cond, o1, o2);
	  e1.k = expkind.VJMP;
	}


	internal static int luaK_code(FuncState fs, LUAI_UINT32 i, int line)
	{
	  Proto f = fs.f;
	  dischargejpc(fs); // `pc' will change
	  /* put new instruction in code array */
	  if ((fs.pc) + 1 > (f.sizecode))
	  {
		  ((f.code) = ((LUAI_UINT32)(luaM_growaux_(fs.L, f.code, ref (f.sizecode), sizeof(LUAI_UINT32), (INT_MAX - 2), "code size overflow"))));
	  }
	  f.code[fs.pc] = i;
	  /* save corresponding line information */
	  if ((fs.pc) + 1 > (f.sizelineinfo))
	  {
		  ((f.lineinfo) = ((int)(luaM_growaux_(fs.L, f.lineinfo, ref (f.sizelineinfo), sizeof(int), (INT_MAX - 2), "code size overflow"))));
	  }
	  f.lineinfo[fs.pc] = line;
	  return fs.pc++;
	}


	/*
	** $Id: ldblib.c,v 1.104.1.3 2008/01/21 13:11:21 roberto Exp $
	** Interface from Lua to its debug API
	** See Copyright Notice in lua.h
	*/




	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_OPENLIB
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getn(L,i) ((int)lua_objlen(L, i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_setn(L,i,j) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaI_openlib luaL_openlib
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_ERRFILE (LUA_ERRERR+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_argcheck(L, cond,numarg,extramsg) ((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkstring(L,n) (luaL_checklstring(L, (n), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optstring(L,n,d) (luaL_optlstring(L, (n), (d), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkint(L,n) ((int)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optint(L,n,d) ((int)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checklong(L,n) ((long)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optlong(L,n,d) ((long)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_typename(L,i) lua_typename(L, lua_type(L,(i)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dofile(L, fn) (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dostring(L, s) (luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getmetatable(L,n) (lua_getfield(L, LUA_REGISTRYINDEX, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_opt(L,f,n,d) (lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addchar(B,c) ((void)((B)->p < ((B)->buffer+LUAL_BUFFERSIZE) || luaL_prepbuffer(B)), (*(B)->p++ = (char)(c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_putchar(B,c) luaL_addchar(B,c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addsize(B,n) ((B)->p += (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_ref(L,lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : (lua_pushstring(L, "unlocked references are obsolete"), lua_error(L), 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unref(L,ref) luaL_unref(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getref(L,ref) lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_reg luaL_Reg
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(x) ((void)0)



	internal static int db_getregistry(lua_State L)
	{
	  lua_pushvalue(L, DefineConstants.LUA_REGISTRYINDEX);
	  return 1;
	}


	internal static int db_getmetatable(lua_State L)
	{
	  luaL_checkany(L, 1);
	  if (!lua_getmetatable(L, 1))
	  {
		lua_pushnil(L); // no metatable
	  }
	  return 1;
	}


	internal static int db_setmetatable(lua_State L)
	{
	  int t = lua_type(L, 2);
	  (((t == DefineConstants.LUA_TNIL || t == DefineConstants.LUA_TTABLE) || luaL_argerror(L, (2), ("nil or table expected"))));
	  lua_settop(L, 2);
	  lua_pushboolean(L, lua_setmetatable(L, 1));
	  return 1;
	}


	internal static int db_getfenv(lua_State L)
	{
	  lua_getfenv(L, 1);
	  return 1;
	}


	internal static int db_setfenv(lua_State L)
	{
	  luaL_checktype(L, 2, DefineConstants.LUA_TTABLE);
	  lua_settop(L, 2);
	  if (lua_setfenv(L, 1) == 0)
	  {
		luaL_error(L, "'" "setfenv" "'" + " cannot change environment of given object");
	  }
	  return 1;
	}


	internal static void settabss(lua_State L, string i, string v)
	{
	  lua_pushstring(L, v);
	  lua_setfield(L, -2, i);
	}


	internal static void settabsi(lua_State L, string i, int v)
	{
	  lua_pushinteger(L, v);
	  lua_setfield(L, -2, i);
	}


	internal static lua_State getthread(lua_State L, ref int arg)
	{
	  if ((lua_type(L, (1)) == DefineConstants.LUA_TTHREAD))
	  {
		arg = 1;
		return lua_tothread(L, 1);
	  }
	  else
	  {
		arg = null;
		return L;
	  }
	}


	internal static void treatstackoption(lua_State L, lua_State L1, string fname)
	{
	  if (L == L1)
	  {
		lua_pushvalue(L, -2);
		lua_remove(L, -3);
	  }
	  else
	  {
		lua_xmove(L1, L, 1);
	  }
	  lua_setfield(L, -2, fname);
	}


	internal static int db_getinfo(lua_State L)
	{
	  lua_Debug ar = new lua_Debug();
	  int arg;
	  lua_State L1 = getthread(L, ref arg);
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *options = (luaL_optlstring(L, (arg+2), ("flnSu"), null));
	  sbyte options = (luaL_optlstring(L, (arg + 2), ("flnSu"), null));
	  if (lua_isnumber(L, arg + 1))
	  {
		if (lua_getstack(L1, (int)lua_tointeger(L, arg + 1), ar) == 0)
		{
		  lua_pushnil(L); // level out of range
		  return 1;
		}
	  }
	  else if ((lua_type(L, (arg + 1)) == DefineConstants.LUA_TFUNCTION))
	  {
		lua_pushfstring(L, ">%s", options);
		options = lua_tolstring(L, (-1), null);
		lua_pushvalue(L, arg + 1);
		lua_xmove(L, L1, 1);
	  }
	  else
	  {
		return luaL_argerror(L, arg + 1, "function or level expected");
	  }
	  if (lua_getinfo(L1, options, ar) == 0)
	  {
		return luaL_argerror(L, arg + 2, "invalid option");
	  }
	  lua_createtable(L, 0, 2);
	  if (StringFunctions.StrChr(options, 'S'))
	  {
		settabss(L, "source", ar.source);
		settabss(L, "short_src", ar.short_src);
		settabsi(L, "linedefined", ar.linedefined);
		settabsi(L, "lastlinedefined", ar.lastlinedefined);
		settabss(L, "what", ar.what);
	  }
	  if (StringFunctions.StrChr(options, 'l'))
	  {
		settabsi(L, "currentline", ar.currentline);
	  }
	  if (StringFunctions.StrChr(options, 'u'))
	  {
		settabsi(L, "nups", ar.nups);
	  }
	  if (StringFunctions.StrChr(options, 'n'))
	  {
		settabss(L, "name", ar.name);
		settabss(L, "namewhat", ar.namewhat);
	  }
	  if (StringFunctions.StrChr(options, 'L'))
	  {
		treatstackoption(L, L1, "activelines");
	  }
	  if (StringFunctions.StrChr(options, 'f'))
	  {
		treatstackoption(L, L1, "func");
	  }
	  return 1; // return table
	}


	internal static int db_getlocal(lua_State L)
	{
	  int arg;
	  lua_State L1 = getthread(L, ref arg);
	  lua_Debug ar = new lua_Debug();
	  string name;
	  if (lua_getstack(L1, ((int)luaL_checkinteger(L, (arg + 1))), ar) == 0) // out of range?
	  {
		return luaL_argerror(L, arg + 1, "level out of range");
	  }
	  name = lua_getlocal(L1, ar, ((int)luaL_checkinteger(L, (arg + 2))));
	  if (name != 0)
	  {
		lua_xmove(L1, L, 1);
		lua_pushstring(L, name);
		lua_pushvalue(L, -2);
		return 2;
	  }
	  else
	  {
		lua_pushnil(L);
		return 1;
	  }
	}


	internal static int db_setlocal(lua_State L)
	{
	  int arg;
	  lua_State L1 = getthread(L, ref arg);
	  lua_Debug ar = new lua_Debug();
	  if (lua_getstack(L1, ((int)luaL_checkinteger(L, (arg + 1))), ar) == 0) // out of range?
	  {
		return luaL_argerror(L, arg + 1, "level out of range");
	  }
	  luaL_checkany(L, arg + 3);
	  lua_settop(L, arg + 3);
	  lua_xmove(L, L1, 1);
	  lua_pushstring(L, lua_setlocal(L1, ar, ((int)luaL_checkinteger(L, (arg + 2)))));
	  return 1;
	}


	internal static int auxupvalue(lua_State L, int get)
	{
	  string name;
	  int n = ((int)luaL_checkinteger(L, (2)));
	  luaL_checktype(L, 1, DefineConstants.LUA_TFUNCTION);
	  if (lua_iscfunction(L, 1))
	  {
		  return 0; // cannot touch C upvalues from Lua
	  }
	  name = get != 0 ? lua_getupvalue(L, 1, n) : lua_setupvalue(L, 1, n);
	  if (name == null)
	  {
		  return 0;
	  }
	  lua_pushstring(L, name);
	  lua_insert(L, -(get + 1));
	  return get + 1;
	}


	internal static int db_getupvalue(lua_State L)
	{
	  return auxupvalue(L, 1);
	}


	internal static int db_setupvalue(lua_State L)
	{
	  luaL_checkany(L, 3);
	  return auxupvalue(L, 0);
	}



	internal const sbyte KEY_HOOK = (sbyte)'h';


	internal static void hookf(lua_State L, lua_Debug ar)
	{
	  string[] hooknames = {"call", "return", "line", "count", "tail return"};
	  lua_pushlightuserdata(L, (object)KEY_HOOK);
	  lua_rawget(L, DefineConstants.LUA_REGISTRYINDEX);
	  lua_pushlightuserdata(L, L);
	  lua_rawget(L, -2);
	  if ((lua_type(L, (-1)) == DefineConstants.LUA_TFUNCTION))
	  {
		lua_pushstring(L, hooknames[(int)ar.event]);
		if (ar.currentline >= 0)
		{
		  lua_pushinteger(L, ar.currentline);
		}
		else
		{
			lua_pushnil(L);
		}
		(x)(0)(lua_getinfo(L, "lS", ar));
		lua_call(L, 2, 0);
	  }
	}


	internal static int makemask(string smask, int count)
	{
	  int mask = 0;
	  if (StringFunctions.StrChr(smask, 'c'))
	  {
		  mask |= (1 << DefineConstants.LUA_HOOKCALL);
	  }
	  if (StringFunctions.StrChr(smask, 'r'))
	  {
		  mask |= (1 << DefineConstants.LUA_HOOKRET);
	  }
	  if (StringFunctions.StrChr(smask, 'l'))
	  {
		  mask |= (1 << DefineConstants.LUA_HOOKLINE);
	  }
	  if (count > 0)
	  {
		  mask |= (1 << DefineConstants.LUA_HOOKCOUNT);
	  }
	  return mask;
	}


	internal static string unmakemask(int mask, ref string smask)
	{
	  int i = 0;
	  if ((mask & (1 << DefineConstants.LUA_HOOKCALL)) != 0)
	  {
		  smask[i++] = 'c';
	  }
	  if ((mask & (1 << DefineConstants.LUA_HOOKRET)) != 0)
	  {
		  smask[i++] = 'r';
	  }
	  if ((mask & (1 << DefineConstants.LUA_HOOKLINE)) != 0)
	  {
		  smask[i++] = 'l';
	  }
	  smask[i] = '\0';
	  return smask;
	}


	internal static void gethooktable(lua_State L)
	{
	  lua_pushlightuserdata(L, (object)KEY_HOOK);
	  lua_rawget(L, DefineConstants.LUA_REGISTRYINDEX);
	  if (!(lua_type(L, (-1)) == DefineConstants.LUA_TTABLE))
	  {
		lua_settop(L, -(1) - 1);
		lua_createtable(L, 0, 1);
		lua_pushlightuserdata(L, (object)KEY_HOOK);
		lua_pushvalue(L, -2);
		lua_rawset(L, DefineConstants.LUA_REGISTRYINDEX);
	  }
	}


	internal static int db_sethook(lua_State L)
	{
	  int arg;
	  int mask;
	  int count;
	  lua_Hook func;
	  lua_State L1 = getthread(L, ref arg);
	  if ((lua_type(L, (arg + 1)) <= 0))
	  {
		lua_settop(L, arg + 1);
		func = null;
		mask = 0;
		count = 0; // turn off hooks
	  }
	  else
	  {
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *smask = (luaL_checklstring(L, (arg+2), null));
		sbyte smask = (luaL_checklstring(L, (arg + 2), null));
		luaL_checktype(L, arg + 1, DefineConstants.LUA_TFUNCTION);
		count = ((int)luaL_optinteger(L, (arg + 3), (0)));
		func = hookf;
		mask = makemask(smask, count);
	  }
	  gethooktable(L);
	  lua_pushlightuserdata(L, L1);
	  lua_pushvalue(L, arg + 1);
	  lua_rawset(L, -3); // set new hook
	  lua_settop(L, -(1) - 1); // remove hook table
	  lua_sethook(L1, func, mask, count); // set hooks
	  return 0;
	}


	internal static int db_gethook(lua_State L)
	{
	  int arg;
	  lua_State L1 = getthread(L, ref arg);
	  string buff = new string(new char[5]);
	  int mask = lua_gethookmask(L1);
	  lua_Hook hook = lua_gethook(L1);
	  if (hook != null && hook != hookf) // external hook?
	  {
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "external hook", (sizeof("external hook")/sizeof(sbyte))-1);
		lua_pushlstring(L, "" "external hook", (("external hook").Length) - 1);
	  }
	  else
	  {
		gethooktable(L);
		lua_pushlightuserdata(L, L1);
		lua_rawget(L, -2); // get hook
		lua_remove(L, -2); // remove hook table
	  }
	  lua_pushstring(L, unmakemask(mask, ref buff));
	  lua_pushinteger(L, lua_gethookcount(L1));
	  return 3;
	}


	internal static int db_debug(lua_State L)
	{
	  for (;;)
	  {
		string buffer = new string(new char[250]);
		fputs("lua_debug> ", stderr);
		if (fgets(buffer, sizeof(sbyte), stdin) == 0 || string.Compare(buffer, "cont\n") == 0)
		{
		  return 0;
		}
		if (luaL_loadbuffer(L, buffer, buffer.Length, "=(debug command)") || lua_pcall(L, 0, 0, 0))
		{
		  fputs(lua_tolstring(L, (-1), null), stderr);
		  fputs("\n", stderr);
		}
		lua_settop(L, 0); // remove eventual returns
	  }
	}



	internal static int db_errorfb(lua_State L)
	{
	  int level;
	  int firstpart = 1; // still before eventual `...'
	  int arg;
	  lua_State L1 = getthread(L, ref arg);
	  lua_Debug ar = new lua_Debug();
	  if (lua_isnumber(L, arg + 2))
	  {
		level = (int)lua_tointeger(L, arg + 2);
		lua_settop(L, -(1) - 1);
	  }
	  else
	  {
		level = (L == L1) ? 1 : 0; // level 0 may be this own function
	  }
	  if (lua_gettop(L) == arg)
	  {
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "", (sizeof("")/sizeof(sbyte))-1);
		lua_pushlstring(L, "" "", (("").Length) - 1);
	  }
	  else if (!lua_isstring(L, arg + 1))
	  {
		  return 1; // message is not a string
	  }
	  else
	  {
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "\n", (sizeof("\n")/sizeof(sbyte))-1);
		  lua_pushlstring(L, "" "\n", (("\n").Length) - 1);
	  }
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "stack traceback:", (sizeof("stack traceback:")/sizeof(sbyte))-1);
	  lua_pushlstring(L, "" "stack traceback:", (("stack traceback:").Length) - 1);
	  while (lua_getstack(L1, level++, ar) != 0)
	  {
		if (level > DefineConstants.LEVELS1 && firstpart != 0)
		{
		  /* no more than `LEVELS2' more levels? */
		  if (lua_getstack(L1, level + DefineConstants.LEVELS2, ar) == 0)
		  {
			level--; // keep going
		  }
		  else
		  {
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "\n\t...", (sizeof("\n\t...")/sizeof(sbyte))-1);
			lua_pushlstring(L, "" "\n\t...", (("\n\t...").Length) - 1); // too many levels
			while (lua_getstack(L1, level + DefineConstants.LEVELS2, ar) != 0) // find last levels
			{
			  level++;
			}
		  }
		  firstpart = 0;
		  continue;
		}
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "\n\t", (sizeof("\n\t")/sizeof(sbyte))-1);
		lua_pushlstring(L, "" "\n\t", (("\n\t").Length) - 1);
		lua_getinfo(L1, "Snl", ar);
		lua_pushfstring(L, "%s:", ar.short_src);
		if (ar.currentline > 0)
		{
		  lua_pushfstring(L, "%d:", ar.currentline);
		}
		if (ar.namewhat != (sbyte)'\0') // is there a name?
		{
			lua_pushfstring(L, " in function " "'" "%s" "'", ar.name);
		}
		else
		{
		  if (ar.what == (sbyte)'m') // main?
		  {
			lua_pushfstring(L, " in main chunk");
		  }
		  else if (ar.what == (sbyte)'C' || ar.what == (sbyte)'t')
		  {
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" " ?", (sizeof(" ?")/sizeof(sbyte))-1);
			lua_pushlstring(L, "" " ?", ((" ?").Length) - 1); // C function or tail call
		  }
		  else
		  {
			lua_pushfstring(L, " in function <%s:%d>", ar.short_src, ar.linedefined);
		  }
		}
		lua_concat(L, lua_gettop(L) - arg);
	  }
	  lua_concat(L, lua_gettop(L) - arg);
	  return 1;
	}


	internal luaL_Reg[] dblib =
	{
		new luaL_Reg("debug", db_debug),
		new luaL_Reg("getfenv", db_getfenv),
		new luaL_Reg("gethook", db_gethook),
		new luaL_Reg("getinfo", db_getinfo),
		new luaL_Reg("getlocal", db_getlocal),
		new luaL_Reg("getregistry", db_getregistry),
		new luaL_Reg("getmetatable", db_getmetatable),
		new luaL_Reg("getupvalue", db_getupvalue),
		new luaL_Reg("setfenv", db_setfenv),
		new luaL_Reg("sethook", db_sethook),
		new luaL_Reg("setlocal", db_setlocal),
		new luaL_Reg("setmetatable", db_setmetatable),
		new luaL_Reg("setupvalue", db_setupvalue),
		new luaL_Reg("traceback", db_errorfb),
		new luaL_Reg(null, null)
	};


	public static int luaopen_debug(lua_State L)
	{
	  luaL_register(L, DefineConstants.LUA_DBLIBNAME, dblib);
	  return 1;
	}


	/*
	** $Id: ldebug.c,v 2.29.1.6 2008/05/08 16:56:26 roberto Exp $
	** Debug Interface
	** See Copyright Notice in lua.h
	*/





	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_OPENLIB
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_SIZET ((size_t)(~(size_t)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_LUMEM ((lu_mem)(~(lu_mem)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_INT (INT_MAX-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IntPoint(p) ((unsigned int)(lu_mem)(p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (lua_assert(c), (e))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check(l,e) lua_assert(e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(c) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check luai_apicheck
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define UNUSED(x) ((void)(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast(t, exp) ((t)(exp))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_byte(i) cast(lu_byte, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_num(i) cast(lua_Number, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_int(i) cast(int, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_lock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unlock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_threadyield(L) {lua_unlock(L); lua_lock(L);}
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) x
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LAST_TAG LUA_TTHREAD
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NUM_TAGS (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TPROTO (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TUPVAL (LAST_TAG+2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TDEADKEY (LAST_TAG+3)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define CommonHeader GCObject *next; lu_byte tt; lu_byte marked
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define TValuefields Value value; int tt
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnil(o) (ttype(o) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnumber(o) (ttype(o) == LUA_TNUMBER)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisstring(o) (ttype(o) == LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttistable(o) (ttype(o) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisfunction(o) (ttype(o) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisboolean(o) (ttype(o) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisuserdata(o) (ttype(o) == LUA_TUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisthread(o) (ttype(o) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttislightuserdata(o) (ttype(o) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttype(o) ((o)->tt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gcvalue(o) check_exp(iscollectable(o), (o)->value.gc)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pvalue(o) check_exp(ttislightuserdata(o), (o)->value.p)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define nvalue(o) check_exp(ttisnumber(o), (o)->value.n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawtsvalue(o) check_exp(ttisstring(o), &(o)->value.gc->ts)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define tsvalue(o) (&rawtsvalue(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawuvalue(o) check_exp(ttisuserdata(o), &(o)->value.gc->u)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define uvalue(o) (&rawuvalue(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define clvalue(o) check_exp(ttisfunction(o), &(o)->value.gc->cl)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define hvalue(o) check_exp(ttistable(o), &(o)->value.gc->h)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bvalue(o) check_exp(ttisboolean(o), (o)->value.b)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define thvalue(o) check_exp(ttisthread(o), &(o)->value.gc->th)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_isfalse(o) (ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkconsistency(obj) lua_assert(!iscollectable(obj) || (ttype(obj) == (obj)->value.gc->gch.tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkliveness(g,obj) lua_assert(!iscollectable(obj) || ((ttype(obj) == (obj)->value.gc->gch.tt) && !isdead(g, (obj)->value.gc)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnilvalue(obj) ((obj)->tt=LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnvalue(obj,x) { TValue *i_o=(obj); i_o->value.n=(x); i_o->tt=LUA_TNUMBER; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setpvalue(obj,x) { TValue *i_o=(obj); i_o->value.p=(x); i_o->tt=LUA_TLIGHTUSERDATA; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbvalue(obj,x) { TValue *i_o=(obj); i_o->value.b=(x); i_o->tt=LUA_TBOOLEAN; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TSTRING; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setuvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TUSERDATA; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setthvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTHREAD; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setclvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TFUNCTION; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTABLE; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TPROTO; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj(L,obj1,obj2) { const TValue *o2=(obj2); TValue *o1=(obj1); o1->value = o2->value; o1->tt=o2->tt; checkliveness(G(L),o1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjs2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2s setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue2s sethvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue2s setptvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjt2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2n setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2n setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setttype(obj, tt) (ttype(obj) = (tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscollectable(o) (ttype(o) >= LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getstr(ts) cast(const char *, (ts) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define svalue(o) getstr(rawtsvalue(o))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ClosureHeader CommonHeader; lu_byte isC; lu_byte nupvalues; GCObject *gclist; struct Table *env
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscfunction(o) (ttype(o) == LUA_TFUNCTION && clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLfunction(o) (ttype(o) == LUA_TFUNCTION && !clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lmod(s,size) (check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define twoto(x) (1<<(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizenode(t) (twoto((t)->lsizenode))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaO_nilobject (&luaO_nilobject_)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ceillog2(x) (luaO_log2((x)-1) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocv(L,b,on,n,e) ((cast(size_t, (n)+1) <= MAX_SIZET/(e)) ? luaM_realloc_(L, (b), (on)*(e), (n)*(e)) : luaM_toobig(L))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freemem(L, b, s) luaM_realloc_(L, (b), (s), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_free(L, b) luaM_realloc_(L, (b), sizeof(*(b)), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freearray(L, b, n, t) luaM_reallocv(L, (b), n, 0, sizeof(t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_malloc(L,t) luaM_realloc_(L, NULL, 0, (t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_new(L,t) cast(t *, luaM_malloc(L, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_newvector(L,n,t) cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_growvector(L,v,nelems,size,t,limit,e) if ((nelems)+1 > (size)) ((v)=cast(t *, luaM_growaux_(L,v,&(size),sizeof(t),limit,e)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocvector(L, v,oldn,n,t) ((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define char2int(c) cast(int, cast(unsigned char, (c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define zgetc(z) (((z)->n--)>0 ? char2int(*(z)->p++) : luaZ_fill(z))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_buffer(buff) ((buff)->buffer)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_sizebuffer(buff) ((buff)->buffsize)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_bufflen(buff) ((buff)->n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resetbuffer(buff) ((buff)->n = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resizebuffer(L, buff, size) (luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), (buff)->buffsize = size)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_freebuffer(L, buff) luaZ_resizebuffer(L, buff, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define TOKEN_LEN (sizeof("function")/sizeof(char))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NUM_RESERVED (cast(int, TK_WHILE-FIRST_RESERVED+1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SIZE_Bx (SIZE_C + SIZE_B)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define POS_A (POS_OP + SIZE_OP)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define POS_C (POS_A + SIZE_A)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define POS_B (POS_C + SIZE_C)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define POS_Bx POS_C
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_Bx ((1<<SIZE_Bx)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_sBx (MAXARG_Bx>>1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_Bx MAX_INT
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_sBx MAX_INT
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_A ((1<<SIZE_A)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_B ((1<<SIZE_B)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_C ((1<<SIZE_C)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MASK1(n,p) ((~((~(Instruction)0)<<n))<<p)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MASK0(n,p) (~MASK1(n,p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GET_OPCODE(i) (cast(OpCode, ((i)>>POS_OP) & MASK1(SIZE_OP,0)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SET_OPCODE(i,o) ((i) = (((i)&MASK0(SIZE_OP,POS_OP)) | ((cast(Instruction, o)<<POS_OP)&MASK1(SIZE_OP,POS_OP))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GETARG_A(i) (cast(int, ((i)>>POS_A) & MASK1(SIZE_A,0)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SETARG_A(i,u) ((i) = (((i)&MASK0(SIZE_A,POS_A)) | ((cast(Instruction, u)<<POS_A)&MASK1(SIZE_A,POS_A))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GETARG_B(i) (cast(int, ((i)>>POS_B) & MASK1(SIZE_B,0)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SETARG_B(i,b) ((i) = (((i)&MASK0(SIZE_B,POS_B)) | ((cast(Instruction, b)<<POS_B)&MASK1(SIZE_B,POS_B))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GETARG_C(i) (cast(int, ((i)>>POS_C) & MASK1(SIZE_C,0)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SETARG_C(i,b) ((i) = (((i)&MASK0(SIZE_C,POS_C)) | ((cast(Instruction, b)<<POS_C)&MASK1(SIZE_C,POS_C))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GETARG_Bx(i) (cast(int, ((i)>>POS_Bx) & MASK1(SIZE_Bx,0)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SETARG_Bx(i,b) ((i) = (((i)&MASK0(SIZE_Bx,POS_Bx)) | ((cast(Instruction, b)<<POS_Bx)&MASK1(SIZE_Bx,POS_Bx))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GETARG_sBx(i) (GETARG_Bx(i)-MAXARG_sBx)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SETARG_sBx(i,b) SETARG_Bx((i),cast(unsigned int, (b)+MAXARG_sBx))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define CREATE_ABC(o,a,b,c) ((cast(Instruction, o)<<POS_OP) | (cast(Instruction, a)<<POS_A) | (cast(Instruction, b)<<POS_B) | (cast(Instruction, c)<<POS_C))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define CREATE_ABx(o,a,bc) ((cast(Instruction, o)<<POS_OP) | (cast(Instruction, a)<<POS_A) | (cast(Instruction, bc)<<POS_Bx))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BITRK (1 << (SIZE_B - 1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ISK(x) ((x) & BITRK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define INDEXK(r) ((int)(r) & ~BITRK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXINDEXRK (BITRK - 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define RKASK(x) ((x) | BITRK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NO_REG MAXARG_A
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NUM_OPCODES (cast(int, OP_VARARG) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getOpMode(m) (cast(enum OpMode, luaP_opmodes[m] & 3))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getBMode(m) (cast(enum OpArgMask, (luaP_opmodes[m] >> 4) & 3))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getCMode(m) (cast(enum OpArgMask, (luaP_opmodes[m] >> 2) & 3))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testAMode(m) (luaP_opmodes[m] & (1 << 6))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testTMode(m) (luaP_opmodes[m] & (1 << 7))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getcode(fs,e) ((fs)->f->code[(e)->u.s.info])
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaK_codeAsBx(fs,o,A,sBx) luaK_codeABx(fs,o,A,(sBx)+MAXARG_sBx)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaK_setmultret(fs,e) luaK_setreturns(fs, e, LUA_MULTRET)
	/*
	** $Id: ldebug.h,v 2.3.1.1 2007/12/27 13:02:25 roberto Exp $
	** Auxiliary functions from Debug Interface module
	** See Copyright Notice in lua.h
	*/



	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gfasttm(g,et,e) ((et) == NULL ? NULL : ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define fasttm(l,et,e) gfasttm(G(l), et, e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gt(L) (&L->l_gt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define registry(L) (&G(L)->l_registry)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BASIC_STACK_SIZE (2*LUA_MINSTACK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define curr_func(L) (clvalue(L->ci->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ci_func(ci) (clvalue((ci)->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define f_isLua(ci) (!ci_func(ci)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLua(ci) (ttisfunction((ci)->func) && f_isLua(ci))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define G(L) (L->l_G)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2ts(o) check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2ts(o) (&rawgco2ts(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2u(o) check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2u(o) (&rawgco2u(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2cl(o) check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2h(o) check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2p(o) check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2uv(o) check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ngcotouv(o) check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2th(o) check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define obj2gco(v) (cast(GCObject *, (v)))


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pcRel(pc, p) (cast(int, (pc) - (p)->code) - 1)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getline(f,pc) (((f)->lineinfo) ? (f)->lineinfo[pc] : 0)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resethookcount(L) (L->hookcount = L->basehookcount)


	public static void luaG_typeerror(lua_State L, lua_TValue o, string op)
	{
	  string name = null;
	  string t = luaT_typenames[((o).tt)];
	  string kind = (isinstack(L.ci, o)) != 0 ? getobjname(L, L.ci, ((int)((o - L.@base))), name) : null;
	  if (kind != 0)
	  {
		luaG_runerror(L, "attempt to %s %s " "'" "%s" "'" " (a %s value)", op, kind, name, t);
	  }
	  else
	  {
		luaG_runerror(L, "attempt to %s a %s value", op, t);
	  }
	}
	public static void luaG_concaterror(lua_State L, lua_TValue p1, lua_TValue p2)
	{
	  if ((((p1).tt) == DefineConstants.LUA_TSTRING) || (((p1).tt) == DefineConstants.LUA_TNUMBER))
	  {
		  p1 = p2;
	  }
	  (c)(0)(!(((p1).tt) == DefineConstants.LUA_TSTRING) && !(((p1).tt) == DefineConstants.LUA_TNUMBER));
	  luaG_typeerror(L, p1, "concatenate");
	}
	public static void luaG_aritherror(lua_State L, lua_TValue p1, lua_TValue p2)
	{
	  lua_TValue temp = new lua_TValue();
	  if (luaV_tonumber(p1, temp) == null)
	  {
		p2 = p1; // first operand is wrong
	  }
	  luaG_typeerror(L, p2, "perform arithmetic on");
	}
	public static int luaG_ordererror(lua_State L, lua_TValue p1, lua_TValue p2)
	{
	  string t1 = luaT_typenames[((p1).tt)];
	  string t2 = luaT_typenames[((p2).tt)];
	  if (t1[2] == t2[2])
	  {
		luaG_runerror(L, "attempt to compare two %s values", t1);
	  }
	  else
	  {
		luaG_runerror(L, "attempt to compare %s with %s", t1, t2);
	  }
	  return 0;
	}
	public static void luaG_runerror(lua_State L, string fmt, params object[] LegacyParamArray)
	{
	//  va_list argp;
  int ParamCount = -1;
	//  va_start(argp, fmt);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: addinfo(L, luaO_pushvfstring(L, fmt, argp));
	  addinfo(L, luaO_pushvfstring(L, fmt, new va_list(argp)));
	//  va_end(argp);
	  luaG_errormsg(L);
	}
	public static void luaG_errormsg(lua_State L)
	{
	  if (L.errfunc != 0)
	  { // is there an error handling function?
		lua_TValue errfunc = ((lua_TValue)((string)L.stack + (L.errfunc)));
		if (!(((errfunc).tt) == DefineConstants.LUA_TFUNCTION))
		{
			luaD_throw(L, DefineConstants.LUA_ERRERR);
		}
		{
			lua_TValue o2 = (L.top - 1);
			lua_TValue o1 = (L.top);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
			o1.value.CopyFrom(o2.value);
			o1.tt = o2.tt;
			(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	}; // move argument
	{
			lua_TValue o2 = (errfunc);
			lua_TValue o1 = (L.top - 1);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
			o1.value.CopyFrom(o2.value);
			o1.tt = o2.tt;
			(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	}; // push function
	{
			if ((string)L.stack_last - (string)L.top <= (1) * (int)sizeof(lua_TValue) != null)
			{
				luaD_growstack(L, 1);
			}
			else
			{
				(x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
			}
			;
			L.top++;
	};
		luaD_call(L, L.top - 2, 1); // call it
	  }
	  luaD_throw(L, DefineConstants.LUA_ERRRUN);
	}

/* }====================================================== */


	public static int luaG_checkcode(Proto pt)
	{
	  return (symbexec(pt, pt.sizecode, ((1 << DefineConstants.SIZE_A) - 1)) != 0);
	}
	public static int luaG_checkopenop(LUAI_UINT32 i)
	{
	  switch ((((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))))
	  {
		case OpCode.OP_CALL:
		case OpCode.OP_TAILCALL:
		case OpCode.OP_RETURN:
		case OpCode.OP_SETLIST:
		{
		  if (!((((int)(((i) >> (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))) == 0))
		  {
			  return 0;
		  }
		  return 1;
		}
		default:
			return 0; // invalid instruction after an open call
	  }
	}


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaD_checkstack(L,n) if ((char *)L->stack_last - (char *)L->top <= (n)*(int)sizeof(TValue)) luaD_growstack(L, n); else condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define incr_top(L) {luaD_checkstack(L,1); L->top++;}
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define savestack(L,p) ((char *)(p) - (char *)L->stack)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define restorestack(L,n) ((TValue *)((char *)L->stack + (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define saveci(L,p) ((char *)(p) - (char *)L->base_ci)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define restoreci(L,n) ((CallInfo *)((char *)L->base_ci + (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeCclosure(n) (cast(int, sizeof(CClosure)) + cast(int, sizeof(TValue)*((n)-1)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeLclosure(n) (cast(int, sizeof(LClosure)) + cast(int, sizeof(TValue *)*((n)-1)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbits(x,m) ((x) &= cast(lu_byte, ~(m)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbits(x,m) ((x) |= (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbits(x,m) ((x) & (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bitmask(b) (1<<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bit2mask(b1,b2) (bitmask(b1) | bitmask(b2))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_setbit(x,b) setbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbit(x,b) resetbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbit(x,b) testbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define set2bits(x,b1,b2) setbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define reset2bits(x,b1,b2) resetbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define test2bits(x,b1,b2) testbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define WHITEBITS bit2mask(WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iswhite(x) test2bits((x)->gch.marked, WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isblack(x) testbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isgray(x) (!isblack(x) && !iswhite(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define otherwhite(g) (g->currentwhite ^ WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isdead(g,v) ((v)->gch.marked & otherwhite(g) & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define changewhite(x) ((x)->gch.marked ^= WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gray2black(x) l_setbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define valiswhite(x) (iscollectable(x) && iswhite(gcvalue(x)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_white(g) cast(lu_byte, (g)->currentwhite & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_checkGC(L) { condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1)); if (G(L)->totalbytes >= G(L)->GCthreshold) luaC_step(L); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),gcvalue(v)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barriert(L,t,v) { if (valiswhite(v) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarrier(L,p,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),obj2gco(o)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarriert(L,t,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizestring(s) (sizeof(union TString)+((s)->len+1)*sizeof(char))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeudata(u) (sizeof(union Udata)+(u)->len)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_new(L, s) (luaS_newlstr(L, s, strlen(s)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_newliteral(L, s) (luaS_newlstr(L, "" s, (sizeof(s)/sizeof(char))-1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_fix(s) l_setbit((s)->tsv.marked, FIXEDBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gnode(t,i) (&(t)->node[i])
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gkey(n) (&(n)->i_key.nk)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gval(n) (&(n)->i_val)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gnext(n) ((n)->i_key.nk.next)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define key2tval(n) (&(n)->i_key.tvk)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define tostring(L,o) ((ttype(o) == LUA_TSTRING) || (luaV_tostring(L, o)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define tonumber(o,n) (ttype(o) == LUA_TNUMBER || (((o) = luaV_tonumber(o,n)) != NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define equalobj(L,o1,o2) (ttype(o1) == ttype(o2) && luaV_equalval(L, o1, o2))



//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'ci', so pointers on this parameter are left unchanged:
	internal static string getfuncname(lua_State L, CallInfo * ci, string[] name)
	{
	  LUAI_UINT32 i = new LUAI_UINT32();
	  if (((((((ci).func).tt) == DefineConstants.LUA_TFUNCTION) && (!(check_exp(ttisfunction((ci).func), ((ci).func).value.gc.cl)).c.isC)) && ci.tailcalls > 0) || !(((((ci - 1).func).tt) == DefineConstants.LUA_TFUNCTION) && (!(check_exp(ttisfunction((ci - 1).func), ((ci - 1).func).value.gc.cl)).c.isC)))
	  {
		return null; // calling function is not Lua (or is unknown)
	  }
	  ci--; // calling function
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: i = (check_exp(((((ci)->func)->tt) == DefineConstants.LUA_TFUNCTION), &((ci)->func)->value.gc->cl))->l.p->code[currentpc(L, ci)];
	  i = (check_exp(((((ci).func).tt) == DefineConstants.LUA_TFUNCTION), ((ci).func).value.gc.cl)).l.p.code[currentpc(L, new CallInfo(ci))];
	  if ((((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))) == OpCode.OP_CALL || (((OpCode)(((i)>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))) == OpCode.OP_TAILCALL || (((OpCode)(((i)>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))) == OpCode.OP_TFORLOOP)
	  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: return getobjname(L, ci, (((int)(((i)>>(DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_A))<<0)))), name);
		return getobjname(L, new CallInfo(ci), (((int)(((i) >> (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_A)) << 0)))), name);
	  }
	  else
	  {
		return null; // no useful name can be found
	  }
	}


	internal static int currentpc(lua_State L, CallInfo ci)
	{
	  if (!(((((ci).func).tt) == DefineConstants.LUA_TFUNCTION) && (!(check_exp(ttisfunction((ci).func), ((ci).func).value.gc.cl)).c.isC)))
	  {
		  return -1; // function is not a Lua function?
	  }
	  if (ci == L.ci)
	  {
		ci.savedpc = L.savedpc;
	  }
	  return (((int)((ci.savedpc) - ((check_exp(((((ci).func).tt) == DefineConstants.LUA_TFUNCTION), ((ci).func).value.gc.cl)).l.p).code)) - 1);
	}


	internal static int currentline(lua_State L, CallInfo ci)
	{
	  int pc = currentpc(L, ci);
	  if (pc < 0)
	  {
		return -1; // only active lua functions have current-line information
	  }
	  else
	  {
		return ((((check_exp(((((ci).func).tt) == DefineConstants.LUA_TFUNCTION), ((ci).func).value.gc.cl)).l.p).lineinfo) ? ((check_exp(((((ci).func).tt) == DefineConstants.LUA_TFUNCTION), ((ci).func).value.gc.cl)).l.p).lineinfo[pc] : 0);
	  }
	}


	/*
	** this function can be called asynchronous (e.g. during a signal)
	*/
	public static int lua_sethook(lua_State L, lua_Hook func, int mask, int count)
	{
	  if (func == null || mask == 0)
	  { // turn off hooks?
		mask = 0;
		func = null;
	  }
	  L.hook = func;
	  L.basehookcount = count;
	  (L.hookcount = L.basehookcount);
	  L.hookmask = ((byte)((mask)));
	  return 1;
	}


	public static lua_Hook lua_gethook(lua_State L)
	{
	  return L.hook;
	}


	public static int lua_gethookmask(lua_State L)
	{
	  return L.hookmask;
	}


	public static int lua_gethookcount(lua_State L)
	{
	  return L.basehookcount;
	}


	public static int lua_getstack(lua_State L, int level, lua_Debug ar)
	{
	  int status;
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  CallInfo * ci = new CallInfo();
	  (L)(0)(L);
	  for (ci = L.ci; level > 0 && ci > L.base_ci; ci--)
	  {
		level--;
		if ((!(check_exp(((((ci).func).tt) == DefineConstants.LUA_TFUNCTION), ((ci).func).value.gc.cl)).c.isC)) // Lua function?
		{
		  level -= ci.tailcalls; // skip lost tail calls
		}
	  }
	  if (level == 0 && ci > L.base_ci)
	  { // level found?
		status = 1;
		ar.i_ci = ((int)((ci - L.base_ci)));
	  }
	  else if (level < 0)
	  { // level is of a lost tail call?
		status = 1;
		ar.i_ci = 0;
	  }
	  else
	  {
		  status = 0; // no such level
	  }
	  (L)(0)(L);
	  return status;
	}


	internal static Proto getluaproto(CallInfo ci)
	{
	  return ((((((ci).func).tt) == DefineConstants.LUA_TFUNCTION) && (!ci_func(ci).c.isC)) ? (check_exp(ttisfunction((ci).func), ((ci).func).value.gc.cl)).l.p : null);
	}


	internal static string findlocal(lua_State L, CallInfo ci, int n)
	{
	  string name;
	  Proto fp = getluaproto(ci);
	  if (fp != null && (name = luaF_getlocalname(fp, n, currentpc(L, ci))) != null)
	  {
		return name; // is a local variable in a Lua function
	  }
	  else
	  {
		lua_TValue limit = (ci == L.ci) ? L.top : (ci + 1).func;
		if (limit - ci.@base >= n != 0 && n > 0) // is 'n' inside 'ci' stack?
		{
		  return "(*temporary)";
		}
		else
		{
		  return null;
		}
	  }
	}


	public static string lua_getlocal(lua_State L, lua_Debug ar, int n)
	{
	  CallInfo ci = L.base_ci + ar.i_ci;
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *name = findlocal(L, ci, n);
	  sbyte name = findlocal(L, ci, n);
	  (L)(0)(L);
	  if (name != 0)
	  {
		  luaA_pushobject(L, ci.@base + (n - 1));
	  }
	  (L)(0)(L);
	  return name;
	}


	public static string lua_setlocal(lua_State L, lua_Debug ar, int n)
	{
	  CallInfo ci = L.base_ci + ar.i_ci;
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *name = findlocal(L, ci, n);
	  sbyte name = findlocal(L, ci, n);
	  (L)(0)(L);
	  if (name != 0)
	  {
			  lua_TValue o2 = (L.top - 1);
			  lua_TValue o1 = (ci.@base + (n - 1));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
			  o1.value.CopyFrom(o2.value);
			  o1.tt = o2.tt;
			  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  L.top--; // pop value
	  (L)(0)(L);
	  return name;
	}


	internal static void funcinfo(lua_Debug ar, Closure cl)
	{
	  if (cl.c.isC != 0)
	  {
		ar.source = "=[C]";
		ar.linedefined = -1;
		ar.lastlinedefined = -1;
		ar.what = "C";
	  }
	  else
	  {
		ar.source = ((string)((cl.l.p.source) + 1));
		ar.linedefined = cl.l.p.linedefined;
		ar.lastlinedefined = cl.l.p.lastlinedefined;
		ar.what = (ar.linedefined == 0) ? "main" : "Lua";
	  }
	  luaO_chunkid(ref ar.short_src, ar.source, DefineConstants.LUA_IDSIZE);
	}


	internal static void info_tailcall(lua_Debug ar)
	{
	  ar.name = ar.namewhat = "";
	  ar.what = "tail";
	  ar.lastlinedefined = ar.linedefined = ar.currentline = -1;
	  ar.source = "=(tail call)";
	  luaO_chunkid(ref ar.short_src, ar.source, DefineConstants.LUA_IDSIZE);
	  ar.nups = 0;
	}


	internal static void collectvalidlines(lua_State L, Closure f)
	{
	  if (f == null || f.c.isC != 0)
	  {
		((L.top).tt = DefineConstants.LUA_TNIL);
	  }
	  else
	  {
		Table t = luaH_new(L, 0, 0);
		int[] lineinfo = f.l.p.lineinfo;
		int i;
		for (i = 0; i < f.l.p.sizelineinfo; i++)
		{
			  lua_TValue i_o = (luaH_setnum(L, t, lineinfo[i]));
			  i_o.value.b = (1);
			  i_o.tt = DefineConstants.LUA_TBOOLEAN;
		};
		{
			lua_TValue i_o = (L.top);
			i_o.value.gc = ((union GCObject)((t)));
			i_o.tt = DefineConstants.LUA_TTABLE;
			(c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	};
	  }
	  {
		  if ((string)L.stack_last - (string)L.top <= (1) * (int)sizeof(lua_TValue) != null)
		  {
			  luaD_growstack(L, 1);
		  }
		  else
		  {
			  (x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
		  }
		  ;
		  L.top++;
  };
	}


//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'what', so pointers on this parameter are left unchanged:
	internal static int auxgetinfo(lua_State L, sbyte * what, lua_Debug ar, Closure f, CallInfo ci)
	{
	  int status = 1;
	  if (f == null)
	  {
		info_tailcall(ar);
		return status;
	  }
	  for (; * what; what++)
	  {
		switch (*what)
		{
		  case 'S':
		  {
			funcinfo(ar, f);
			break;
		  }
		  case 'l':
		  {
			ar.currentline = (ci) != null ? currentline(L, ci) : -1;
			break;
		  }
		  case 'u':
		  {
			ar.nups = f.c.nupvalues;
			break;
		  }
		  case 'n':
		  {
			ar.namewhat = (ci) != null ? getfuncname(L, ci, ar.name) : null;
			if (ar.namewhat == null)
			{
			  ar.namewhat = ""; // not found
			  ar.name = null;
			}
			break;
		  }
		  case 'L':
		  case 'f': // handled by lua_getinfo
			break;
		  default:
			  status = 0; // invalid option
		  break;
		}
	  }
	  return status;
	}


//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'what', so pointers on this parameter are left unchanged:
	public static int lua_getinfo(lua_State L, sbyte * what, lua_Debug ar)
	{
	  int status;
	  Closure f = null;
	  CallInfo ci = null;
	  (L)(0)(L);
	  if (*what == (sbyte)'>')
	  {
		lua_TValue func = L.top - 1;
		luai_apicheck(L, (((func).tt) == DefineConstants.LUA_TFUNCTION));
		what = what.Substring(1); // skip the '>'
		f = check_exp((((func).tt) == DefineConstants.LUA_TFUNCTION), (func).value.gc.cl);
		L.top--; // pop function
	  }
	  else if (ar.i_ci != 0)
	  { // no tail call?
		ci = L.base_ci + ar.i_ci;
		(c)(0)((((ci.func).tt) == DefineConstants.LUA_TFUNCTION));
		f = check_exp((((ci.func).tt) == DefineConstants.LUA_TFUNCTION), (ci.func).value.gc.cl);
	  }
	  status = auxgetinfo(L, what, ar, f, ci);
	  if (StringFunctions.StrChr(what, 'f'))
	  {
		if (f == null)
		{
			((L.top).tt = DefineConstants.LUA_TNIL);
		}
		else
		{
			lua_TValue i_o = (L.top);
			i_o.value.gc = ((union GCObject)((f)));
			i_o.tt = DefineConstants.LUA_TFUNCTION;
			(c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		};
		{
			if ((string)L.stack_last - (string)L.top <= (1) * (int)sizeof(lua_TValue) != null)
			{
				luaD_growstack(L, 1);
			}
			else
			{
				(x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
			}
			;
			L.top++;
	};
	  }
	  if (StringFunctions.StrChr(what, 'L'))
	  {
		collectvalidlines(L, f);
	  }
	  (L)(0)(L);
	  return status;
	}


	/*
	** {======================================================
	** Symbolic Execution and code checker
	** =======================================================
	*/

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check(x) if (!(x)) return 0;

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkjump(pt,pc) check(0 <= pc && pc < pt->sizecode)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkreg(pt,reg) check((reg) < (pt)->maxstacksize)



	internal static int precheck(Proto pt)
	{
	  if (!(pt.maxstacksize <= DefineConstants.MAXSTACK))
	  {
		  return 0;
	  }
	  if (!(pt.numparams + (pt.is_vararg & DefineConstants.VARARG_HASARG) <= pt.maxstacksize))
	  {
		  return 0;
	  }
	  if (!(!(pt.is_vararg & DefineConstants.VARARG_NEEDSARG) || (pt.is_vararg & DefineConstants.VARARG_HASARG)))
	  {
		  return 0;
	  }
	  if (!(pt.sizeupvalues <= pt.nups))
	  {
		  return 0;
	  }
	  if (!(pt.sizelineinfo == pt.sizecode || pt.sizelineinfo == 0))
	  {
		  return 0;
	  }
	  if (!(pt.sizecode > 0 && (((OpCode)(((pt.code[pt.sizecode-1]) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))) == OpCode.OP_RETURN))
	  {
		  return 0;
	  }
	  return 1;
	}


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkopenop(pt,pc) luaG_checkopenop((pt)->code[(pc)+1])


	internal static int checkArgMode(Proto pt, int r, OpArgMask mode)
	{
	  switch (mode)
	  {
		case OpArgMask.OpArgN:
			if (!(r == 0))
			{
				return 0;
			}
			;
			break;
		case OpArgMask.OpArgU:
			break;
		case OpArgMask.OpArgR:
			if (!((r) < (pt).maxstacksize))
			{
				return 0;
			}
			;
			break;
		case OpArgMask.OpArgK:
		  if (!((((r) & (1 << (DefineConstants.SIZE_B - 1))) != 0) ? ((int)(r) & ~(1 << (DefineConstants.SIZE_B - 1))) < pt.sizek : r < pt.maxstacksize))
		  {
			  return 0;
		  }
		  break;
	  }
	  return 1;
	}


	internal static LUAI_UINT32 symbexec(Proto pt, int lastpc, int reg)
	{
	  int pc;
	  int last; // stores position of last instruction that changed `reg'
	  last = pt.sizecode-1; // points to final return (a `neutral' instruction)
	  if ((precheck(pt)) == 0)
	  {
		  return 0;
	  }
	  for (pc = 0; pc < lastpc; pc++)
	  {
		LUAI_UINT32 i = pt.code[pc];
		OpCode op = (((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0))));
		int a = (((int)(((i) >> (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_A)) << 0))));
		int b = 0;
		int c = 0;
		if (!(op < (((int)(OpCode.OP_VARARG)) + 1)))
		{
			return 0;
		}
		if (!((a) < (pt).maxstacksize))
		{
			return 0;
		}
		switch ((((OpMode)(luaP_opmodes[(int)op] & 3))))
		{
		  case OpMode.iABC:
		  {
			b = (((int)(((i) >> (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))));
			c = (((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))));
			if ((checkArgMode(pt, b, (((OpArgMask)((luaP_opmodes[(int)op] >> 4) & 3))))) == 0)
			{
				return 0;
			}
			if ((checkArgMode(pt, c, (((OpArgMask)((luaP_opmodes[(int)op] >> 2) & 3))))) == 0)
			{
				return 0;
			}
			break;
		  }
		  case OpMode.iABx:
		  {
			b = (((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << (DefineConstants.SIZE_C + DefineConstants.SIZE_B))) << 0))));
			if ((((OpArgMask)((luaP_opmodes[(int)op] >> 4) & 3))) == OpArgMask.OpArgK)
			{
				if (!(b < pt.sizek))
				{
					return 0;
				}
			}
			break;
		  }
		  case OpMode.iAsBx:
		  {
			b = ((((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << (DefineConstants.SIZE_C + DefineConstants.SIZE_B))) << 0)))) - MAXARG_sBx);
			if ((((OpArgMask)((luaP_opmodes[(int)op] >> 4) & 3))) == OpArgMask.OpArgR)
			{
			  int dest = pc + 1 + b;
			  if (!(0 <= dest != 0 && dest < pt.sizecode))
			  {
				  return 0;
			  }
			  if (dest > 0)
			  {
				int j;
				/* check that it does not jump to a setlist count; this
				   is tricky, because the count from a previous setlist may
				   have the same value of an invalid setlist; so, we must
				   go all the way back to the first of them (if any) */
				for (j = 0; j < dest; j++)
				{
				  LUAI_UINT32 d = pt.code[dest - 1 - j];
				  if (!((((OpCode)(((d) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))) == OpCode.OP_SETLIST && (((int)(((d)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0)))) == 0))
				  {
					  break;
				  }
				}
				/* if 'j' is even, previous value is not a setlist (even if
				   it looks like one) */
				if (!((j & 1) == 0))
				{
					return 0;
				}
			  }
			}
			break;
		  }
		}
		if (((luaP_opmodes[(int)op] & (1 << 6))) != 0)
		{
		  if (a == reg)
		  {
			  last = pc; // change register `a'
		  }
		}
		if (((luaP_opmodes[(int)op] & (1 << 7))) != 0)
		{
		  if (!(pc + 2 < pt.sizecode))
		  {
			  return 0;
		  }
		  ; // check skip
		  if (!((((OpCode)(((pt.code[pc + 1]) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))) == OpCode.OP_JMP))
		  {
			  return 0;
		  }
		}
		switch (op)
		{
		  case OpCode.OP_LOADBOOL:
		  {
			if (c == 1)
			{ // does it jump?
			  if (!(pc + 2 < pt.sizecode))
			  {
				  return 0;
			  }
			  ; // check its jump
			  if (!((((OpCode)(((pt.code[pc + 1]) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))) != OpCode.OP_SETLIST || (((int)(((pt.code[pc + 1])>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0)))) != 0))
			  {
				  return 0;
			  }
			}
			break;
		  }
		  case OpCode.OP_LOADNIL:
		  {
			if (a <= reg != 0 && reg <= b)
			{
			  last = pc; // set registers from `a' to `b'
			}
			break;
		  }
		  case OpCode.OP_GETUPVAL:
		  case OpCode.OP_SETUPVAL:
		  {
			if (!(b < pt.nups))
			{
				return 0;
			}
			break;
		  }
		  case OpCode.OP_GETGLOBAL:
		  case OpCode.OP_SETGLOBAL:
		  {
			if (!((((pt.k[b]).tt) == DefineConstants.LUA_TSTRING)))
			{
				return 0;
			}
			break;
		  }
		  case OpCode.OP_SELF:
		  {
			if (!((a + 1) < (pt).maxstacksize))
			{
				return 0;
			}
			if (reg == a + 1)
			{
				last = pc;
			}
			break;
		  }
		  case OpCode.OP_CONCAT:
		  {
			if (!(b < c))
			{
				return 0;
			}
			; // at least two operands
			break;
		  }
		  case OpCode.OP_TFORLOOP:
		  {
			if (!(c >= 1))
			{
				return 0;
			}
			; // at least one result (control variable)
			if (!((a + 2 + c) < (pt).maxstacksize))
			{
				return 0;
			}
			; // space for results
			if (reg >= a + 2)
			{
				last = pc; // affect all regs above its base
			}
			break;
		  }
		  case OpCode.OP_FORLOOP:
		  case OpCode.OP_FORPREP:
			if (!((a + 3) < (pt).maxstacksize))
			{
				return 0;
			}
			/* go through */
		  case OpCode.OP_JMP:
		  {
			int dest = pc + 1 + b;
			/* not full check and jump is forward and do not skip `lastpc'? */
			if (reg != ((1 << DefineConstants.SIZE_A) - 1) && pc < dest && dest <= lastpc)
			{
			  pc += b; // do the jump
			}
			break;
		  }
		  case OpCode.OP_CALL:
		  case OpCode.OP_TAILCALL:
		  {
			if (b != 0)
			{
			  if (!((a + b - 1) < (pt).maxstacksize))
			  {
				  return 0;
			  }
			}
			c--; // c = num. returns
			if (c == DefineConstants.LUA_MULTRET)
			{
			  if ((luaG_checkopenop((pt).code[(pc) + 1])) == 0)
			  {
				  return 0;
			  }
			}
			else if (c != 0)
			{
			  if (!((a + c - 1) < (pt).maxstacksize))
			  {
				  return 0;
			  }
			}
			if (reg >= a)
			{
				last = pc; // affect all registers above base
			}
			break;
		  }
		  case OpCode.OP_RETURN:
		  {
			b--; // b = num. returns
			if (b > 0)
			{
				if (!((a + b - 1) < (pt).maxstacksize))
				{
					return 0;
				}
			}
			break;
		  }
		  case OpCode.OP_SETLIST:
		  {
			if (b > 0)
			{
				if (!((a + b) < (pt).maxstacksize))
				{
					return 0;
				}
			}
			if (c == 0)
			{
			  pc++;
			  if (!(pc < pt.sizecode - 1))
			  {
				  return 0;
			  }
			}
			break;
		  }
		  case OpCode.OP_CLOSURE:
		  {
			int nup;
			int j;
			if (!(b < pt.sizep))
			{
				return 0;
			}
			nup = pt.p[b].nups;
			if (!(pc + nup < pt.sizecode))
			{
				return 0;
			}
			for (j = 1; j <= nup; j++)
			{
			  OpCode op1 = (((OpCode)(((pt.code[pc + j]) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0))));
			  if (!(op1 == OpCode.OP_GETUPVAL || op1 == OpCode.OP_MOVE))
			  {
				  return 0;
			  }
			}
			if (reg != ((1 << DefineConstants.SIZE_A) - 1)) // tracing?
			{
			  pc += nup; // do not 'execute' these pseudo-instructions
			}
			break;
		  }
		  case OpCode.OP_VARARG:
		  {
			if (!((pt.is_vararg & DefineConstants.VARARG_ISVARARG) && !(pt.is_vararg & DefineConstants.VARARG_NEEDSARG)))
			{
				return 0;
			}
			b--;
			if (b == DefineConstants.LUA_MULTRET)
			{
				if ((luaG_checkopenop((pt).code[(pc) + 1])) == 0)
				{
					return 0;
				}
			}
			if (!((a + b - 1) < (pt).maxstacksize))
			{
				return 0;
			}
			break;
		  }
		  default:
			  break;
		}
	  }
	  return pt.code[last];
	}



	internal static string kname(Proto p, int c)
	{
	  if (((c) & (1 << (DefineConstants.SIZE_B - 1))) && (((p.k[((int)(c) & ~(1 << (DefineConstants.SIZE_B - 1)))]).tt) == DefineConstants.LUA_TSTRING))
	  {
		return ((string)((check_exp((((p.k[((int)(c) & ~(1 << (DefineConstants.SIZE_B - 1)))]).tt) == DefineConstants.LUA_TSTRING), (p.k[((int)(c) & ~(1 << (DefineConstants.SIZE_B - 1)))]).value.gc.ts)) + 1));
	  }
	  else
	  {
		return "?";
	  }
	}


	internal static string getobjname(lua_State L, CallInfo ci, int stackpos, string[] name)
	{
	  if ((((((ci).func).tt) == DefineConstants.LUA_TFUNCTION) && (!(check_exp(ttisfunction((ci).func), ((ci).func).value.gc.cl)).c.isC)))
	  { // a Lua function?
		Proto p = (check_exp(((((ci).func).tt) == DefineConstants.LUA_TFUNCTION), ((ci).func).value.gc.cl)).l.p;
		int pc = currentpc(L, ci);
		LUAI_UINT32 i = new LUAI_UINT32();
		name[0] = ((char)luaF_getlocalname(p, stackpos + 1, pc)).ToString();
		if name // is a local?
		{
		  return "local";
		}
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: i = symbexec(p, pc, stackpos);
		i.CopyFrom(symbexec(p, pc, stackpos)); // try symbolic execution
		(c)(0)(pc != -1);
		switch ((((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))))
		{
		  case OpCode.OP_GETGLOBAL:
		  {
			int g = (((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << (DefineConstants.SIZE_C + DefineConstants.SIZE_B))) << 0)))); // global index
			(c)(0)((((p.k[g]).tt) == DefineConstants.LUA_TSTRING));
			name[0] = ((string)((check_exp((((p.k[g]).tt) == DefineConstants.LUA_TSTRING), (p.k[g]).value.gc.ts)) + 1));
			return "global";
		  }
		  case OpCode.OP_MOVE:
		  {
			int a = (((int)(((i) >> (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_A)) << 0))));
			int b = (((int)(((i) >> (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))); // move from `b' to `a'
			if (b < a)
			{
			  return getobjname(L, ci, b, name); // get name for `b'
			}
			break;
		  }
		  case OpCode.OP_GETTABLE:
		  {
			int k = (((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0)))); // key index
			name[0] = ((char)kname(p, k)).ToString();
			return "field";
		  }
		  case OpCode.OP_GETUPVAL:
		  {
			int u = (((int)(((i) >> (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))); // upvalue index
			name[0] = p.upvalues ? ((string)((p.upvalues[u]) + 1)) : "?";
			return "upvalue";
		  }
		  case OpCode.OP_SELF:
		  {
			int k = (((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0)))); // key index
			name[0] = ((char)kname(p, k)).ToString();
			return "method";
		  }
		  default:
			  break;
		}
	  }
	  return null; // no useful name found
	}


	/* only ANSI way to check whether a pointer points to an array */
	internal static int isinstack(CallInfo ci, lua_TValue o)
	{
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  lua_TValue * p = new lua_TValue();
	  for (p = ci.@base; p < ci.top; p++)
	  {
		if (o == p)
		{
			return 1;
		}
	  }
	  return 0;
	}


	internal static void addinfo(lua_State L, string msg)
	{
	  CallInfo ci = L.ci;
	  if ((((((ci).func).tt) == DefineConstants.LUA_TFUNCTION) && (!(check_exp(ttisfunction((ci).func), ((ci).func).value.gc.cl)).c.isC)))
	  { // is Lua code?
		string buff = new string(new char[DefineConstants.LUA_IDSIZE]); // add file:line information
		int line = currentline(L, ci);
		luaO_chunkid(ref buff, ((string)((getluaproto(ci).source) + 1)), DefineConstants.LUA_IDSIZE);
		luaO_pushfstring(L, "%s:%d: %s", buff, line, msg);
	  }
	}



	public static int luaD_protectedparser(lua_State L, Zio z, string name)
	{
	  SParser p = new SParser();
	  int status;
	  p.z = z;
	  p.name = name;
	  ((p.buff).buffer = null, (p.buff).buffsize = 0);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: status = luaD_pcall(L, f_parser, &p, ((sbyte *)(L->top) - (sbyte *)L->stack), L->errfunc);
	  status = luaD_pcall(L, f_parser, p, ((string)(L.top) - (string)L.stack), new ptrdiff_t(L.errfunc));
	  ((((p.buff).buffer) = ((string)(((cast(size_t, (0) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(sbyte))) ? luaM_realloc_(L, ((p.buff).buffer), ((p.buff).buffsize) * (sizeof(sbyte)), (0) * (sizeof(sbyte))) : luaM_toobig(L))))), (p.buff).buffsize = 0);
	  return status;
	}
	private extern void luaD_callhook(struct lua_State * L, int event, int line);
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'L', so pointers on this parameter are left unchanged:
	public static int luaD_precall(lua_State * L, lua_TValue func, int nresults)
	{
	  LClosure cl;
	  ptrdiff_t funcr = new ptrdiff_t();
	  if (!(((func).tt) == DefineConstants.LUA_TFUNCTION)) // `func' is not a function?
	  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: func = tryfuncTM(L, func);
		func = tryfuncTM(new lua_State(L), func); // check the `function' tag method
	  }
	  funcr = ((string)(func) - (string)L.stack);
	  cl = check_exp((((func).tt) == DefineConstants.LUA_TFUNCTION), (func).value.gc.cl).l;
	  L.ci.savedpc = L.savedpc;
	  if (cl.isC == 0)
	  { // Lua function? prepare its call
		CallInfo ci;
		lua_TValue st;
		lua_TValue @base;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: Proto *p = cl->p;
		Proto[] p = new Proto(cl.p);
		if ((string)L.stack_last - (string)L.top <= (p.maxstacksize) * (int)sizeof(lua_TValue) != null)
		{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaD_growstack(L, p->maxstacksize);
			luaD_growstack(new lua_State(L), p.maxstacksize);
		}
		else
		{
			(x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
		}
		func = ((lua_TValue)((string)L.stack + (funcr)));
		if (p.is_vararg == 0)
		{ // no varargs?
		  @base = func + 1;
		  if (L.top > @base + p.numparams)
		  {
			L.top = @base + p.numparams;
		  }
		}
		else
		{ // vararg function
		  int nargs = ((int)((L.top - func))) - 1;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: base = adjust_varargs(L, p, nargs);
		  @base = adjust_varargs(new lua_State(L), p, nargs);
		  func = ((lua_TValue)((string)L.stack + (funcr))); // previous call may change the stack
		}
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: ci = ((L->ci == L->end_ci) ? growCI(L) : ((x)(0)(luaD_reallocCI(L, L->size_ci)), ++L->ci));
		ci = ((L.ci == L.end_ci) ? growCI(new lua_State(L)) : ((x)(0)(luaD_reallocCI(L, L.size_ci)), ++L.ci)); // now `enter' new function
		ci.func = func;
		L.@base = ci.@base = @base;
		ci.top = L.@base + p.maxstacksize;
		(c)(0)(ci.top <= L.stack_last);
		L.savedpc = p.code; // starting point
		ci.tailcalls = 0;
		ci.nresults = nresults;
		for (st = L.top; st < ci.top; st++)
		{
		  ((st).tt = DefineConstants.LUA_TNIL);
		}
		L.top = ci.top;
		if ((L.hookmask & (1 << DefineConstants.LUA_HOOKCALL)) != 0)
		{
		  L.savedpc++; // hooks assume 'pc' is already incremented
		  luaD_callhook(L, DefineConstants.LUA_HOOKCALL, -1);
		  L.savedpc--; // correct 'pc'
		}
		return DefineConstants.PCRLUA;
	  }
	  else
	  { // if is a C function, call it
		CallInfo ci;
		int n;
		if ((string)L.stack_last - (string)L.top <= (DefineConstants.LUA_MINSTACK) * (int)sizeof(lua_TValue) != null)
		{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaD_growstack(L, DefineConstants.LUA_MINSTACK);
			luaD_growstack(new lua_State(L), DefineConstants.LUA_MINSTACK);
		}
		else
		{
			(x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
		}
		; // ensure minimum stack size
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: ci = ((L->ci == L->end_ci) ? growCI(L) : ((x)(0)(luaD_reallocCI(L, L->size_ci)), ++L->ci));
		ci = ((L.ci == L.end_ci) ? growCI(new lua_State(L)) : ((x)(0)(luaD_reallocCI(L, L.size_ci)), ++L.ci)); // now `enter' new function
		ci.func = ((lua_TValue)((string)L.stack + (funcr)));
		L.@base = ci.@base = ci.func + 1;
		ci.top = L.top + DefineConstants.LUA_MINSTACK;
		(c)(0)(ci.top <= L.stack_last);
		ci.nresults = nresults;
		if ((L.hookmask & (1 << DefineConstants.LUA_HOOKCALL)) != 0)
		{
		  luaD_callhook(L, DefineConstants.LUA_HOOKCALL, -1);
		}
		(L)(0)(L);
		n = (check_exp((((L.ci.func).tt) == DefineConstants.LUA_TFUNCTION), (L.ci.func).value.gc.cl)).c.f(L); // do the actual call
		(L)(0)(L);
		if (n < 0) // yielding?
		{
		  return DefineConstants.PCRYIELD;
		}
		else
		{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaD_poscall(L, L->top - n);
		  luaD_poscall(new lua_State(L), L.top - n);
		  return DefineConstants.PCRC;
		}
	  }
	}

/*
** Call a function (C or Lua). The function to be called is at *func.
** The arguments are on the stack, right after the function.
** When returns, all the results are on the stack, starting at the original
** function position.
*/ 
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'L', so pointers on this parameter are left unchanged:
	public static void luaD_call(lua_State * L, lua_TValue func, int nResults)
	{
	  if (++L.nCcalls >= DefineConstants.LUAI_MAXCCALLS)
	  {
		if (L.nCcalls == DefineConstants.LUAI_MAXCCALLS)
		{
		  luaG_runerror(L, "C stack overflow");
		}
		else if (L.nCcalls >= (DefineConstants.LUAI_MAXCCALLS + (DefineConstants.LUAI_MAXCCALLS >> 3)))
		{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaD_throw(L, DefineConstants.LUA_ERRERR);
		  luaD_throw(new lua_State(L), DefineConstants.LUA_ERRERR); // error while handing stack error
		}
	  }
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: if (luaD_precall(L, func, nResults) == DefineConstants.PCRLUA)
	  if (luaD_precall(new lua_State(L), func, nResults) == DefineConstants.PCRLUA) // is a Lua function?
	  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaV_execute(L, 1);
		luaV_execute(new lua_State(L), 1); // call it
	  }
	  L.nCcalls--;
	  {
		  (x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
		  if ((L.l_G).totalbytes >= (L.l_G).GCthreshold)
		  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaC_step(L);
			  luaC_step(new lua_State(L));
		  }
	  };
	}
	public static int luaD_pcall(lua_State L, Pfunc func, object u, ptrdiff_t old_top, ptrdiff_t ef)
	{
	  int status;
	  ushort oldnCcalls = L.nCcalls;
	  ptrdiff_t old_ci = ((string)(L.ci) - (string)L.base_ci);
	  byte old_allowhooks = L.allowhook;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: ptrdiff_t old_errfunc = L->errfunc;
	  ptrdiff_t old_errfunc = new ptrdiff_t(L.errfunc);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: L->errfunc = ef;
	  L.errfunc.CopyFrom(ef);
	  status = luaD_rawrunprotected(L, func, u);
	  if (status != 0)
	  { // an error occurred?
		lua_TValue oldtop = ((lua_TValue)((string)L.stack + (old_top)));
		luaF_close(L, oldtop); // close eventual pending closures
		luaD_seterrorobj(L, status, oldtop);
		L.nCcalls = oldnCcalls;
		L.ci = ((CallInfo)((string)L.base_ci + (old_ci)));
		L.@base = L.ci.@base;
		L.savedpc = L.ci.savedpc;
		L.allowhook = old_allowhooks;
		restore_stack_limit(L);
	  }
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: L->errfunc = old_errfunc;
	  L.errfunc.CopyFrom(old_errfunc);
	  return status;
	}
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'firstResult', so pointers on this parameter are left unchanged:
	public static int luaD_poscall(lua_State L, lua_TValue * firstResult)
	{
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  lua_TValue * res = new lua_TValue();
	  int wanted;
	  int i;
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  CallInfo * ci = new CallInfo();
	  if ((L.hookmask & (1 << DefineConstants.LUA_HOOKRET)) != 0)
	  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: firstResult = callrethooks(L, firstResult);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
		firstResult.CopyFrom(callrethooks(L, new lua_TValue(firstResult)));
	  }
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: ci = L->ci--;
	  ci.CopyFrom(L.ci--);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: res = ci->func;
	  res.CopyFrom(ci.func); // res == final position of 1st result
	  wanted = ci.nresults;
	  L.@base = (ci - 1).@base; // restore base
	  L.savedpc = (ci - 1).savedpc; // restore savedpc
	  /* move results to correct place */
	  for (i = wanted; i != 0 && firstResult < L.top; i--)
	  {
			lua_TValue o2 = (firstResult++);
			lua_TValue o1 = (res++);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
			o1.value.CopyFrom(o2.value);
			o1.tt = o2.tt;
			(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  while (i-- > 0)
	  {
		((res++).tt = DefineConstants.LUA_TNIL);
	  }
	  L.top = res;
	  return (wanted - DefineConstants.LUA_MULTRET); // 0 iff wanted == LUA_MULTRET
	}
	public static void luaD_reallocCI(lua_State L, int newsize)
	{
	  CallInfo oldci = L.base_ci;
	  ((L.base_ci) = ((CallInfo)(((cast(size_t, (newsize) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(CallInfo))) ? luaM_realloc_(L, (L.base_ci), (L.size_ci) * (sizeof(CallInfo)), (newsize) * (sizeof(CallInfo))) : luaM_toobig(L)))));
	  L.size_ci = newsize;
	  L.ci = (L.ci - oldci) + L.base_ci;
	  L.end_ci = L.base_ci + L.size_ci - 1;
	}
	public static void luaD_reallocstack(lua_State L, int newsize)
	{
	  lua_TValue oldstack = L.stack;
	  int realsize = newsize + 1 + DefineConstants.EXTRA_STACK;
	  (c)(0)(L.stack_last - L.stack == L.stacksize - DefineConstants.EXTRA_STACK - 1);
	  ((L.stack) = ((lua_TValue)(((cast(size_t, (realsize) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(lua_TValue))) ? luaM_realloc_(L, (L.stack), (L.stacksize) * (sizeof(lua_TValue)), (realsize) * (sizeof(lua_TValue))) : luaM_toobig(L)))));
	  L.stacksize = realsize;
	  L.stack_last = L.stack + newsize;
	  correctstack(L, oldstack);
	}
	public static void luaD_growstack(lua_State L, int n)
	{
	  if (n <= L.stacksize) // double size is enough?
	  {
		luaD_reallocstack(L, 2 * L.stacksize);
	  }
	  else
	  {
		luaD_reallocstack(L, L.stacksize + n);
	  }
	}

	public static void luaD_throw(lua_State L, int errcode)
	{
	  if (L.errorJmp != null)
	  {
		L.errorJmp.status = errcode;
		longjmp((L.errorJmp).b, 1);
	  }
	  else
	  {
		L.status = ((byte)((errcode)));
		if ((L.l_G).panic != null)
		{
		  resetstack(L, errcode);
		  (L)(0)(L);
		  (L.l_G).panic(L);
		}
		Environment.Exit(1);
	  }
	}
	public static int luaD_rawrunprotected(lua_State L, Pfunc f, object ud)
	{
	  lua_longjmp lj = new lua_longjmp();
	  lj.status = 0;
	  lj.previous = L.errorJmp; // chain new error handler
	  L.errorJmp = lj;
	  if (setjmp((lj).b) == 0)
	  {
		  f(L, ud);
	  };
	  L.errorJmp = lj.previous; // restore old error handler
	  return lj.status;
	}

	public static void luaD_seterrorobj(lua_State L, int errcode, lua_TValue oldtop)
	{
	  switch (errcode)
	  {
		case DefineConstants.LUA_ERRMEM:
		{
		  {
			  lua_TValue i_o = (oldtop);
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: i_o->value.gc=((union GCObject *)(((luaS_newlstr(L, "" DefineConstants.MEMERRMSG, (sizeof(DefineConstants.MEMERRMSG)/sizeof(sbyte))-1)))));
			  i_o.value.gc = ((union GCObject)((luaS_newlstr(L, "" DefineConstants.MEMERRMSG, (DefineConstants.MEMERRMSG.Length) - 1))));
			  i_o.tt = DefineConstants.LUA_TSTRING;
			  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
		  break;
		}
		case DefineConstants.LUA_ERRERR:
		{
		  {
			  lua_TValue i_o = (oldtop);
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: i_o->value.gc=((union GCObject *)(((luaS_newlstr(L, "" "error in error handling", (sizeof("error in error handling")/sizeof(sbyte))-1)))));
			  i_o.value.gc = ((union GCObject)((luaS_newlstr(L, "" "error in error handling", (("error in error handling").Length) - 1))));
			  i_o.tt = DefineConstants.LUA_TSTRING;
			  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
		  break;
		}
		case DefineConstants.LUA_ERRSYNTAX:
		case DefineConstants.LUA_ERRRUN:
		{
		  {
			  lua_TValue o2 = (L.top - 1);
			  lua_TValue o1 = (oldtop);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
			  o1.value.CopyFrom(o2.value);
			  o1.tt = o2.tt;
			  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  }; // error message on current top
		  break;
		}
	  }
	  L.top = oldtop + 1;
	}


	internal static void restore_stack_limit(lua_State L)
	{
	  (c)(0)(L.stack_last - L.stack == L.stacksize - DefineConstants.EXTRA_STACK - 1);
	  if (L.size_ci > DefineConstants.LUAI_MAXCALLS)
	  { // there was an overflow?
		int inuse = ((int)((L.ci - L.base_ci)));
		if (inuse + 1 < DefineConstants.LUAI_MAXCALLS) // can `undo' overflow?
		{
		  luaD_reallocCI(L, DefineConstants.LUAI_MAXCALLS);
		}
	  }
	}


	internal static void resetstack(lua_State L, int status)
	{
	  L.ci = L.base_ci;
	  L.@base = L.ci.@base;
	  luaF_close(L, L.@base); // close eventual pending closures
	  luaD_seterrorobj(L, status, L.@base);
	  L.nCcalls = L.baseCcalls;
	  L.allowhook = 1;
	  restore_stack_limit(L);
	  L.errfunc = 0;
	  L.errorJmp = null;
	}

	/* }====================================================== */


	internal static void correctstack(lua_State L, lua_TValue oldstack)
	{
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  CallInfo * ci = new CallInfo();
	  GCObject up;
	  L.top = (L.top - oldstack) + L.stack;
	  for (up = L.openupval; up != null; up = up.gch.next)
	  {
		check_exp((up).gch.tt == (DefineConstants.LUA_TTHREAD + 2), ((up).uv)).v = (check_exp((up).gch.tt == (DefineConstants.LUA_TTHREAD + 2), ((up).uv)).v - oldstack) + L.stack;
	  }
	  for (ci = L.base_ci; ci <= L.ci; ci++)
	  {
		ci.top = (ci.top - oldstack) + L.stack;
		ci.@base = (ci.@base - oldstack) + L.stack;
		ci.func = (ci.func - oldstack) + L.stack;
	  }
	  L.@base = (L.@base - oldstack) + L.stack;
	}


//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'L', so pointers on this parameter are left unchanged:
	internal static CallInfo growCI(lua_State * L)
	{
	  if (L.size_ci > DefineConstants.LUAI_MAXCALLS) // overflow while handling overflow?
	  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaD_throw(L, DefineConstants.LUA_ERRERR);
		luaD_throw(new lua_State(L), DefineConstants.LUA_ERRERR);
	  }
	  else
	  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaD_reallocCI(L, 2 *L->size_ci);
		luaD_reallocCI(new lua_State(L), 2 * L.size_ci);
		if (L.size_ci > DefineConstants.LUAI_MAXCALLS)
		{
		  luaG_runerror(L, "stack overflow");
		}
	  }
	  return ++L.ci;
	}


	private void luaD_callhook(struct lua_State * L, int event, int line)
	{
	  lua_Hook hook = L.hook;
	  if (hook != null && L.allowhook)
	  {
		ptrdiff_t top = ((string)(L.top) - (string)L.stack);
		ptrdiff_t ci_top = ((string)(L.ci.top) - (string)L.stack);
		lua_Debug ar = new lua_Debug();
		ar.event = event;
		ar.currentline = line;
		if (event == DefineConstants.LUA_HOOKTAILRET)
		{
		  ar.i_ci = 0; // tail call; no debug information about it
		}
		else
		{
		  ar.i_ci = ((int)((L.ci - L.base_ci)));
		}
		if ((string)L.stack_last - (string)L.top <= (DefineConstants.LUA_MINSTACK) * (int)sizeof(lua_TValue) != null)
		{
			luaD_growstack(L, DefineConstants.LUA_MINSTACK);
		}
		else
		{
			(x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
		}
		; // ensure minimum stack size
		L.ci.top = L.top + DefineConstants.LUA_MINSTACK;
		(c)(0)(L.ci.top <= L.stack_last);
		L.allowhook = 0; // cannot call hooks inside a hook
		(L)(0)(L);
		hook(L, ar);
		(L)(0)(L);
		(c)(0)(!L.allowhook);
		L.allowhook = 1;
		L.ci.top = ((lua_TValue)((string)L.stack + (ci_top)));
		L.top = ((lua_TValue)((string)L.stack + (top)));
	  }
	}


//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'p', so pointers on this parameter are left unchanged:
	internal static lua_TValue adjust_varargs(lua_State L, Proto * p, int actual)
	{
	  int i;
	  int nfixargs = p.numparams;
	  Table htab = null;
	  lua_TValue @base;
	  lua_TValue @fixed;
	  for (; actual < nfixargs; ++actual)
	  {
		((L.top++).tt = DefineConstants.LUA_TNIL);
	  }
	#if LUA_COMPAT_VARARG
	  if ((p.is_vararg & DefineConstants.VARARG_NEEDSARG) != 0)
	  { // compat. with old-style vararg?
		int nvar = actual - nfixargs; // number of extra arguments
		(c)(0)(p.is_vararg & DefineConstants.VARARG_HASARG);
		{
			(x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
			if ((L.l_G).totalbytes >= (L.l_G).GCthreshold)
			{
				luaC_step(L);
			}
		};
		htab = luaH_new(L, nvar, 1); // create `arg' table
		for (i = 0; i < nvar; i++) // put extra arguments into `arg' table
		{
			  lua_TValue o2 = (L.top - nvar + i);
			  lua_TValue o1 = (luaH_setnum(L, htab, i + 1));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
			  o1.value.CopyFrom(o2.value);
			  o1.tt = o2.tt;
			  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		};
		/* store counter in field `n' */
		{
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_TValue *i_o=(luaH_setstr(L, htab, (luaS_newlstr(L, "" "n", (sizeof("n")/sizeof(sbyte))-1))));
			lua_TValue i_o = (luaH_setstr(L, htab, (luaS_newlstr(L, "" "n", (("n").Length) - 1))));
			i_o.value.n = (((double)((nvar))));
			i_o.tt = DefineConstants.LUA_TNUMBER;
	};
	  }
	#endif
	  /* move fixed parameters to final position */
	  @fixed = L.top - actual; // first fixed argument
	  @base = L.top; // final position of first argument
	  for (i = 0; i < nfixargs; i++)
	  {
		{
			lua_TValue o2 = (@fixed + i);
			lua_TValue o1 = (L.top++);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
			o1.value.CopyFrom(o2.value);
			o1.tt = o2.tt;
			(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	};
		((@fixed + i).tt = DefineConstants.LUA_TNIL);
	  }
	  /* add `arg' parameter */
	  if (htab != null)
	  {
		{
			lua_TValue i_o = (L.top++);
			i_o.value.gc = ((union GCObject)((htab)));
			i_o.tt = DefineConstants.LUA_TTABLE;
			(c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	};
		(c)(0)(((((((union GCObject)((htab))))).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))));
	  }
	  return @base;
	}


	internal static lua_TValue tryfuncTM(lua_State L, lua_TValue func)
	{
	  lua_TValue tm = luaT_gettmbyobj(L, func, TMS.TM_CALL);
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  lua_TValue * p = new lua_TValue();
	  ptrdiff_t funcr = ((string)(func) - (string)L.stack);
	  if (!(((tm).tt) == DefineConstants.LUA_TFUNCTION))
	  {
		luaG_typeerror(L, func, "call");
	  }
	  /* Open a hole inside the stack at `func' */
	  for (p = L.top; p > func; p--)
	  {
		  lua_TValue o2 = (p - 1);
		  lua_TValue o1 = (p);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
		  o1.value.CopyFrom(o2.value);
		  o1.tt = o2.tt;
		  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  {
		  if ((string)L.stack_last - (string)L.top <= (1) * (int)sizeof(lua_TValue) != null)
		  {
			  luaD_growstack(L, 1);
		  }
		  else
		  {
			  (x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
		  }
		  ;
		  L.top++;
  };
	  func = ((lua_TValue)((string)L.stack + (funcr))); // previous call may change stack
	  {
		  lua_TValue o2 = (tm);
		  lua_TValue o1 = (func);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
		  o1.value.CopyFrom(o2.value);
		  o1.tt = o2.tt;
		  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  }; // tag method is the new function to be called
	  return func;
	}



	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define inc_ci(L) ((L->ci == L->end_ci) ? growCI(L) : (condhardstacktests(luaD_reallocCI(L, L->size_ci)), ++L->ci))


	internal static lua_TValue callrethooks(lua_State L, lua_TValue firstResult)
	{
	  ptrdiff_t fr = ((string)(firstResult) - (string)L.stack); // next call may change stack
	  luaD_callhook(L, DefineConstants.LUA_HOOKRET, -1);
	  if ((!(check_exp(((((L.ci).func).tt) == DefineConstants.LUA_TFUNCTION), ((L.ci).func).value.gc.cl)).c.isC))
	  { // Lua function?
		while ((L.hookmask & (1 << DefineConstants.LUA_HOOKRET)) && L.ci.tailcalls--) // tail calls
		{
		  luaD_callhook(L, DefineConstants.LUA_HOOKTAILRET, -1);
		}
	  }
	  return ((lua_TValue)((string)L.stack + (fr)));
	}


	internal static void resume(lua_State L, object ud)
	{
	  lua_TValue firstArg = ((lua_TValue)(ud));
	  CallInfo ci = L.ci;
	  if (L.status == 0)
	  { // start coroutine?
		(c)(0)(ci == L.base_ci && firstArg > L.@base);
		if (luaD_precall(L, firstArg - 1, DefineConstants.LUA_MULTRET) != DefineConstants.PCRLUA)
		{
		  return;
		}
	  }
	  else
	  { // resuming from previous yield
		(c)(0)(L.status == DefineConstants.LUA_YIELD);
		L.status = 0;
		if (!(!(check_exp(((((ci).func).tt) == DefineConstants.LUA_TFUNCTION), ((ci).func).value.gc.cl)).c.isC))
		{ // `common' yield?
		  /* finish interrupted execution of `OP_CALL' */
		  (c)(0)((((OpCode)(((*((ci - 1).savedpc - 1)) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))) == OpCode.OP_CALL || (((OpCode)(((*((ci - 1).savedpc - 1))>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))) == OpCode.OP_TAILCALL);
		  if (luaD_poscall(L, firstArg) != 0) // complete it...
		  {
			L.top = L.ci.top; // and correct top if not multiple results
		  }
		}
		else // yielded inside a hook: just continue its execution
		{
		  L.@base = L.ci.@base;
		}
	  }
	  luaV_execute(L, ((int)((L.ci - L.base_ci))));
	}


	internal static int resume_error(lua_State L, string msg)
	{
	  L.top = L.ci.@base;
	  {
		  lua_TValue i_o = (L.top);
		  i_o.value.gc = ((union GCObject)((luaS_newlstr(L, msg, msg.Length))));
		  i_o.tt = DefineConstants.LUA_TSTRING;
		  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  {
		  if ((string)L.stack_last - (string)L.top <= (1) * (int)sizeof(lua_TValue) != null)
		  {
			  luaD_growstack(L, 1);
		  }
		  else
		  {
			  (x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
		  }
		  ;
		  L.top++;
  };
	  (L)(0)(L);
	  return DefineConstants.LUA_ERRRUN;
	}


//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'L', so pointers on this parameter are left unchanged:
	public static int lua_resume(lua_State * L, int nargs)
	{
	  int status;
	  (L)(0)(L);
	  if (L.status != DefineConstants.LUA_YIELD && (L.status != 0 || L.ci != L.base_ci))
	  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: return resume_error(L, "cannot resume non-suspended coroutine");
		  return resume_error(new lua_State(L), "cannot resume non-suspended coroutine");
	  }
	  if (L.nCcalls >= DefineConstants.LUAI_MAXCCALLS)
	  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: return resume_error(L, "C stack overflow");
		return resume_error(new lua_State(L), "C stack overflow");
	  }
	  (L);
	  (c)(0)(L.errfunc == 0);
	  L.baseCcalls = ++L.nCcalls;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: status = luaD_rawrunprotected(L, resume, L->top - nargs);
	  status = luaD_rawrunprotected(new lua_State(L), resume, L.top - nargs);
	  if (status != 0)
	  { // error?
		L.status = ((byte)((status))); // mark thread as `dead'
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaD_seterrorobj(L, status, L->top);
		luaD_seterrorobj(new lua_State(L), status, L.top);
		L.ci.top = L.top;
	  }
	  else
	  {
		(c)(0)(L.nCcalls == L.baseCcalls);
		status = L.status;
	  }
	  --L.nCcalls;
	  (L)(0)(L);
	  return status;
	}


	public static int lua_yield(lua_State L, int nresults)
	{
	  (L);
	  (L)(0)(L);
	  if (L.nCcalls > L.baseCcalls)
	  {
		luaG_runerror(L, "attempt to yield across metamethod/C-call boundary");
	  }
	  L.@base = L.top - nresults; // protect stack slots below
	  L.status = DefineConstants.LUA_YIELD;
	  (L)(0)(L);
	  return -1;
	}

	internal static void f_parser(lua_State L, object ud)
	{
	  int i;
	  Proto tf;
	  Closure cl;
	  SParser p = ((SParser)(ud));
	  int c = luaZ_lookahead(p.z);
	  {
		  (x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
		  if ((L.l_G).totalbytes >= (L.l_G).GCthreshold)
		  {
			  luaC_step(L);
		  }
	  };
	  tf = ((c == DefineConstants.LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p.z, p.buff, p.name);
	  cl = luaF_newLclosure(L, tf.nups, check_exp(((((L.l_gt)).tt) == DefineConstants.LUA_TTABLE), ((L.l_gt)).value.gc.h));
	  cl.l.p = tf;
	  for (i = 0; i < tf.nups; i++) // initialize eventual upvalues
	  {
		cl.l.upvals[i] = luaF_newupval(L);
	  }
	  {
		  lua_TValue i_o = (L.top);
		  i_o.value.gc = ((union GCObject)((cl)));
		  i_o.tt = DefineConstants.LUA_TFUNCTION;
		  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
  };
  {
		  if ((string)L.stack_last - (string)L.top <= (1) * (int)sizeof(lua_TValue) != null)
		  {
			  luaD_growstack(L, 1);
		  }
		  else
		  {
			  (x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
		  }
		  ;
		  L.top++;
  };
	}




	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define DumpMem(b,n,size,D) DumpBlock(b,(n)*(size),D)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define DumpVar(x,D) DumpMem(&x,1,sizeof(x),D)

	internal static void DumpBlock(object b, size_t size, DumpState D)
	{
	 if (D.status == 0)
	 {
	  (L)(0)(D.L);
	  D.status = D.writer(D.L,b,size,D.data);
	  (L)(0)(D.L);
	 }
	}

	internal static void DumpChar(int y, DumpState D)
	{
	 sbyte x = (sbyte)y;
	 DumpBlock(x, (1) * (sizeof(sbyte)), D);
	}

	internal static void DumpInt(int x, DumpState D)
	{
	 DumpBlock(x, (1) * (sizeof(int)), D);
	}

	internal static void DumpNumber(double x, DumpState D)
	{
	 DumpBlock(x, (1) * (sizeof(double)), D);
	}

	internal static void DumpVector(object b, int n, size_t size, DumpState D)
	{
	 DumpInt(n, D);
	 DumpBlock(b, (n) * (size), D);
	}

	internal static void DumpString(TString s, DumpState D)
	{
	 if (s == null || ((string)((s) + 1)) == null)
	 {
	  size_t size = 0;
	  DumpBlock(sizeof(size_t), (1) * (sizeof(size_t)), D);
	 }
	 else
	 {
	  size_t size = s.tsv.len + 1; // include trailing '\0'
	  DumpBlock(sizeof(size_t), (1) * (sizeof(size_t)), D);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: DumpBlock(((const sbyte *)((s) + 1)),size,D);
	  DumpBlock(((string)((s) + 1)), new size_t(size), D);
	 }
	}

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define DumpCode(f,D) DumpVector(f->code,f->sizecode,sizeof(Instruction),D)

	internal static void DumpFunction(Proto f, TString p, DumpState D)
	{
	 DumpString((f.source == p || D.strip != 0) ? null : f.source, D);
	 DumpInt(f.linedefined, D);
	 DumpInt(f.lastlinedefined, D);
	 DumpChar(f.nups, D);
	 DumpChar(f.numparams, D);
	 DumpChar(f.is_vararg, D);
	 DumpChar(f.maxstacksize, D);
	 DumpVector(f.code, f.sizecode, sizeof(LUAI_UINT32), D);
	 DumpConstants(f, D);
	 DumpDebug(f, D);
	}

	internal static void DumpConstants(Proto f, DumpState D)
	{
	 int i;
	 int n = f.sizek;
	 DumpInt(n, D);
	 for (i = 0; i < n; i++)
	 {
	  lua_TValue o = f.k[i];
	  DumpChar(((o).tt), D);
	  switch (((o).tt))
	  {
	   case DefineConstants.LUA_TNIL:
		break;
	   case DefineConstants.LUA_TBOOLEAN:
		DumpChar(check_exp((((o).tt) == DefineConstants.LUA_TBOOLEAN), (o).value.b), D);
		break;
	   case DefineConstants.LUA_TNUMBER:
		DumpNumber(check_exp((((o).tt) == DefineConstants.LUA_TNUMBER), (o).value.n), D);
		break;
	   case DefineConstants.LUA_TSTRING:
		DumpString(check_exp((((o).tt) == DefineConstants.LUA_TSTRING), (o).value.gc.ts), D);
		break;
	   default:
		(c)(0)(0); // cannot happen
		break;
	  }
	 }
	 n = f.sizep;
	 DumpInt(n, D);
	 for (i = 0; i < n; i++)
	 {
		 DumpFunction(f.p[i], f.source, D);
	 }
	}

	internal static void DumpDebug(Proto f, DumpState D)
	{
	 int i;
	 int n;
	 n = (D.strip) != 0 ? 0 : f.sizelineinfo;
	 DumpVector(f.lineinfo, n, sizeof(int), D);
	 n = (D.strip) != 0 ? 0 : f.sizelocvars;
	 DumpInt(n, D);
	 for (i = 0; i < n; i++)
	 {
	  DumpString(f.locvars[i].varname, D);
	  DumpInt(f.locvars[i].startpc, D);
	  DumpInt(f.locvars[i].endpc, D);
	 }
	 n = (D.strip) != 0 ? 0 : f.sizeupvalues;
	 DumpInt(n, D);
	 for (i = 0; i < n; i++)
	 {
		 DumpString(f.upvalues[i], D);
	 }
	}

	internal static void DumpHeader(DumpState D)
	{
	 string h = new string(new char[DefineConstants.LUAC_HEADERSIZE]);
	 luaU_header(ref h);
	 DumpBlock(h, DefineConstants.LUAC_HEADERSIZE, D);
	}

	/*
	** dump Lua function as precompiled chunk
	*/
	public static int luaU_dump(lua_State L, Proto f, lua_Writer w, object data, int strip)
	{
	 DumpState D = new DumpState();
	 D.L = L;
	 D.writer = w;
	 D.data = data;
	 D.strip = strip;
	 D.status = 0;
	 DumpHeader(D);
	 DumpFunction(f, null, D);
	 return D.status;
	}

	/*
	** $Id: lfunc.c,v 2.12.1.2 2007/12/28 14:58:43 roberto Exp $
	** Auxiliary functions to manipulate prototypes and closures
	** See Copyright Notice in lua.h
	*/




	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_VARARG
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_OPENLIB
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)

	/*
	** $Id: lfunc.h,v 2.4.1.1 2007/12/27 13:02:25 roberto Exp $
	** Auxiliary functions to manipulate prototypes and closures
	** See Copyright Notice in lua.h
	*/



	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_SIZET ((size_t)(~(size_t)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_LUMEM ((lu_mem)(~(lu_mem)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_INT (INT_MAX-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IntPoint(p) ((unsigned int)(lu_mem)(p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (lua_assert(c), (e))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check(l,e) lua_assert(e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(c) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check luai_apicheck
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define UNUSED(x) ((void)(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast(t, exp) ((t)(exp))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_byte(i) cast(lu_byte, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_num(i) cast(lua_Number, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_int(i) cast(int, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_lock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unlock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_threadyield(L) {lua_unlock(L); lua_lock(L);}
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) x
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LAST_TAG LUA_TTHREAD
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NUM_TAGS (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TPROTO (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TUPVAL (LAST_TAG+2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TDEADKEY (LAST_TAG+3)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define CommonHeader GCObject *next; lu_byte tt; lu_byte marked
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define TValuefields Value value; int tt
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnil(o) (ttype(o) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnumber(o) (ttype(o) == LUA_TNUMBER)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisstring(o) (ttype(o) == LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttistable(o) (ttype(o) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisfunction(o) (ttype(o) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisboolean(o) (ttype(o) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisuserdata(o) (ttype(o) == LUA_TUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisthread(o) (ttype(o) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttislightuserdata(o) (ttype(o) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttype(o) ((o)->tt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gcvalue(o) check_exp(iscollectable(o), (o)->value.gc)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pvalue(o) check_exp(ttislightuserdata(o), (o)->value.p)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define nvalue(o) check_exp(ttisnumber(o), (o)->value.n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawtsvalue(o) check_exp(ttisstring(o), &(o)->value.gc->ts)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define tsvalue(o) (&rawtsvalue(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawuvalue(o) check_exp(ttisuserdata(o), &(o)->value.gc->u)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define uvalue(o) (&rawuvalue(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define clvalue(o) check_exp(ttisfunction(o), &(o)->value.gc->cl)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define hvalue(o) check_exp(ttistable(o), &(o)->value.gc->h)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bvalue(o) check_exp(ttisboolean(o), (o)->value.b)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define thvalue(o) check_exp(ttisthread(o), &(o)->value.gc->th)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_isfalse(o) (ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkconsistency(obj) lua_assert(!iscollectable(obj) || (ttype(obj) == (obj)->value.gc->gch.tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkliveness(g,obj) lua_assert(!iscollectable(obj) || ((ttype(obj) == (obj)->value.gc->gch.tt) && !isdead(g, (obj)->value.gc)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnilvalue(obj) ((obj)->tt=LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnvalue(obj,x) { TValue *i_o=(obj); i_o->value.n=(x); i_o->tt=LUA_TNUMBER; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setpvalue(obj,x) { TValue *i_o=(obj); i_o->value.p=(x); i_o->tt=LUA_TLIGHTUSERDATA; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbvalue(obj,x) { TValue *i_o=(obj); i_o->value.b=(x); i_o->tt=LUA_TBOOLEAN; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TSTRING; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setuvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TUSERDATA; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setthvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTHREAD; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setclvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TFUNCTION; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTABLE; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TPROTO; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj(L,obj1,obj2) { const TValue *o2=(obj2); TValue *o1=(obj1); o1->value = o2->value; o1->tt=o2->tt; checkliveness(G(L),o1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjs2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2s setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue2s sethvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue2s setptvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjt2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2n setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2n setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setttype(obj, tt) (ttype(obj) = (tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscollectable(o) (ttype(o) >= LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getstr(ts) cast(const char *, (ts) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define svalue(o) getstr(rawtsvalue(o))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ClosureHeader CommonHeader; lu_byte isC; lu_byte nupvalues; GCObject *gclist; struct Table *env
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscfunction(o) (ttype(o) == LUA_TFUNCTION && clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLfunction(o) (ttype(o) == LUA_TFUNCTION && !clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lmod(s,size) (check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define twoto(x) (1<<(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizenode(t) (twoto((t)->lsizenode))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaO_nilobject (&luaO_nilobject_)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ceillog2(x) (luaO_log2((x)-1) + 1)


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeCclosure(n) (cast(int, sizeof(CClosure)) + cast(int, sizeof(TValue)*((n)-1)))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeLclosure(n) (cast(int, sizeof(LClosure)) + cast(int, sizeof(TValue *)*((n)-1)))


	public static Proto luaF_newproto(lua_State L)
	{
	  Proto f = ((Proto)(luaM_realloc_(L, null, 0, (sizeof(Proto)))));
	  luaC_link(L, (((union GCObject)((f)))), (DefineConstants.LUA_TTHREAD + 1));
	  f.k = null;
	  f.sizek = 0;
	  f.p = null;
	  f.sizep = 0;
	  f.code = null;
	  f.sizecode = 0;
	  f.sizelineinfo = 0;
	  f.sizeupvalues = 0;
	  f.nups = 0;
	  f.upvalues = null;
	  f.numparams = 0;
	  f.is_vararg = 0;
	  f.maxstacksize = 0;
	  f.lineinfo = null;
	  f.sizelocvars = 0;
	  f.locvars = null;
	  f.linedefined = 0;
	  f.lastlinedefined = 0;
	  f.source = null;
	  return f;
	}
	public static Closure luaF_newCclosure(lua_State L, int nelems, Table e)
	{
	  Closure c = ((Closure)(luaM_realloc_(L, null, 0, ((cast(int, sizeof(CClosure)) + cast(int, sizeof(lua_TValue) * ((nelems) - 1)))))));
	  luaC_link(L, (((union GCObject)((c)))), DefineConstants.LUA_TFUNCTION);
	  c.c.isC = 1;
	  c.c.env = e;
	  c.c.nupvalues = ((byte)((nelems)));
	  return c;
	}
	public static Closure luaF_newLclosure(lua_State L, int nelems, Table e)
	{
	  Closure c = ((Closure)(luaM_realloc_(L, null, 0, ((cast(int, sizeof(LClosure)) + cast(int, sizeof(lua_TValue) * ((nelems) - 1)))))));
	  luaC_link(L, (((union GCObject)((c)))), DefineConstants.LUA_TFUNCTION);
	  c.l.isC = 0;
	  c.l.env = e;
	  c.l.nupvalues = ((byte)((nelems)));
	  while (nelems-- != 0)
	  {
		  c.l.upvals[nelems] = null;
	  }
	  return c;
	}
	public static UpVal luaF_newupval(lua_State L)
	{
	  UpVal uv = ((UpVal)(luaM_realloc_(L, null, 0, (sizeof(UpVal)))));
	  luaC_link(L, (((union GCObject)((uv)))), (DefineConstants.LUA_TTHREAD + 2));
	  uv.v = uv.u.value;
	  ((uv.v).tt = DefineConstants.LUA_TNIL);
	  return uv;
	}
	public static UpVal luaF_findupval(lua_State L, lua_TValue level)
	{
	  global_State g = (L.l_G);
	  GCObject[] pp = L.openupval;
	  UpVal p;
	  UpVal uv;
	  while (pp[0] != null && (p = check_exp(pp == null || pp.gch.tt == (DefineConstants.LUA_TTHREAD + 2), (pp.uv))).v >= level)
	  {
		(c)(0)(p.v != p.u.value);
		if (p.v == level)
		{ // found a corresponding upvalue?
		  if (((((((union GCObject)((p))))).gch.marked & (g.currentwhite ^ WHITEBITS) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))) != 0) // is it dead?
		  {
			(((((union GCObject)((p))))).gch.marked ^= ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))); // ressurect it
		  }
		  return p;
		}
		pp = p.next;
	  }
	  uv = ((UpVal)(luaM_realloc_(L, null, 0, (sizeof(UpVal))))); // not found: create a new one
	  uv.tt = (DefineConstants.LUA_TTHREAD + 2);
	  uv.marked = ((byte)((g).currentwhite & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))));
	  uv.v = level; // current value lives in the stack
	  uv.next = pp[0]; // chain it in the proper position
	  pp[0] = (((union GCObject)((uv))));
	  uv.u.l.prev = g.uvhead; // double link it in `uvhead' list
	  uv.u.l.next = g.uvhead.u.l.next;
	  uv.u.l.next.u.l.prev = uv;
	  g.uvhead.u.l.next = uv;
	  (c)(0)(uv.u.l.next.u.l.prev == uv && uv.u.l.prev.u.l.next == uv);
	  return uv;
	}
	public static void luaF_close(lua_State L, lua_TValue level)
	{
	  UpVal uv;
	  global_State g = (L.l_G);
	  while (L.openupval != null && (uv = check_exp((L.openupval) == null || (L.openupval).gch.tt == (DefineConstants.LUA_TTHREAD + 2), ((L.openupval).uv))).v >= level)
	  {
		GCObject o = (((union GCObject)((uv))));
		(c)(0)(!(((o).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))) && uv.v != uv.u.value);
		L.openupval = uv.next; // remove from `open' list
		if ((((o).gch.marked & (g.currentwhite ^ WHITEBITS) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))) != 0)
		{
		  luaF_freeupval(L, uv); // free upvalue
		}
		else
		{
		  unlinkupval(uv);
		  {
			  lua_TValue o2 = (uv.v);
			  lua_TValue o1 = (uv.u.value);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
			  o1.value.CopyFrom(o2.value);
			  o1.tt = o2.tt;
			  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		  };
		  uv.v = uv.u.value; // now current value lives here
		  luaC_linkupval(L, uv); // link upvalue into `gcroot' list
		}
	  }
	}
	public static void luaF_freeproto(lua_State L, Proto f)
	{
	  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(LUAI_UINT32))) ? luaM_realloc_(L, ((f.code)), (f.sizecode) * (sizeof(LUAI_UINT32)), (0) * (sizeof(LUAI_UINT32))) : luaM_toobig(L));
	  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(Proto))) ? luaM_realloc_(L, ((f.p)), (f.sizep) * (sizeof(Proto)), (0) * (sizeof(Proto))) : luaM_toobig(L));
	  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(lua_TValue))) ? luaM_realloc_(L, ((f.k)), (f.sizek) * (sizeof(lua_TValue)), (0) * (sizeof(lua_TValue))) : luaM_toobig(L));
	  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(int))) ? luaM_realloc_(L, ((f.lineinfo)), (f.sizelineinfo) * (sizeof(int)), (0) * (sizeof(int))) : luaM_toobig(L));
	  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(LocVar))) ? luaM_realloc_(L, ((f.locvars)), (f.sizelocvars) * (sizeof(LocVar)), (0) * (sizeof(LocVar))) : luaM_toobig(L));
	  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(TString))) ? luaM_realloc_(L, ((f.upvalues)), (f.sizeupvalues) * (sizeof(TString)), (0) * (sizeof(TString))) : luaM_toobig(L));
	  luaM_realloc_(L, (f), sizeof(Proto), 0);
	}
	public static void luaF_freeclosure(lua_State L, Closure c)
	{
	  int size = (c.c.isC) != 0 ? (((int)(sizeof(CClosure))) + ((int)(sizeof(lua_TValue) * ((c.c.nupvalues) - 1)))) : (((int)(sizeof(LClosure))) + ((int)(sizeof(lua_TValue) * ((c.l.nupvalues) - 1))));
	  luaM_realloc_(L, (c), (size), 0);
	}
	public static void luaF_freeupval(lua_State L, UpVal uv)
	{
	  if (uv.v != uv.u.value) // is it open?
	  {
		unlinkupval(uv); // remove from open list
	  }
	  luaM_realloc_(L, (uv), sizeof(UpVal), 0); // free upvalue
	}

/*
** Look for n-th local variable at line `line' in function `func'.
** Returns NULL if not found.
*/
	public static string luaF_getlocalname(Proto f, int local_number, int pc)
	{
	  int i;
	  for (i = 0; i < f.sizelocvars && f.locvars[i].startpc <= pc; i++)
	  {
		if (pc < f.locvars[i].endpc)
		{ // is variable active?
		  local_number--;
		  if (local_number == 0)
		  {
			return ((string)((f.locvars[i].varname) + 1));
		  }
		}
	  }
	  return null; // not found
	}



	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbits(x,m) ((x) &= cast(lu_byte, ~(m)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbits(x,m) ((x) |= (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbits(x,m) ((x) & (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bitmask(b) (1<<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bit2mask(b1,b2) (bitmask(b1) | bitmask(b2))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_setbit(x,b) setbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbit(x,b) resetbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbit(x,b) testbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define set2bits(x,b1,b2) setbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define reset2bits(x,b1,b2) resetbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define test2bits(x,b1,b2) testbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define WHITEBITS bit2mask(WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iswhite(x) test2bits((x)->gch.marked, WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isblack(x) testbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isgray(x) (!isblack(x) && !iswhite(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define otherwhite(g) (g->currentwhite ^ WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isdead(g,v) ((v)->gch.marked & otherwhite(g) & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define changewhite(x) ((x)->gch.marked ^= WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gray2black(x) l_setbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define valiswhite(x) (iscollectable(x) && iswhite(gcvalue(x)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_white(g) cast(lu_byte, (g)->currentwhite & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_checkGC(L) { condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1)); if (G(L)->totalbytes >= G(L)->GCthreshold) luaC_step(L); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),gcvalue(v)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barriert(L,t,v) { if (valiswhite(v) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarrier(L,p,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),obj2gco(o)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarriert(L,t,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocv(L,b,on,n,e) ((cast(size_t, (n)+1) <= MAX_SIZET/(e)) ? luaM_realloc_(L, (b), (on)*(e), (n)*(e)) : luaM_toobig(L))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freemem(L, b, s) luaM_realloc_(L, (b), (s), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_free(L, b) luaM_realloc_(L, (b), sizeof(*(b)), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freearray(L, b, n, t) luaM_reallocv(L, (b), n, 0, sizeof(t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_malloc(L,t) luaM_realloc_(L, NULL, 0, (t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_new(L,t) cast(t *, luaM_malloc(L, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_newvector(L,n,t) cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_growvector(L,v,nelems,size,t,limit,e) if ((nelems)+1 > (size)) ((v)=cast(t *, luaM_growaux_(L,v,&(size),sizeof(t),limit,e)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocvector(L, v,oldn,n,t) ((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gfasttm(g,et,e) ((et) == NULL ? NULL : ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define fasttm(l,et,e) gfasttm(G(l), et, e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define char2int(c) cast(int, cast(unsigned char, (c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define zgetc(z) (((z)->n--)>0 ? char2int(*(z)->p++) : luaZ_fill(z))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_buffer(buff) ((buff)->buffer)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_sizebuffer(buff) ((buff)->buffsize)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_bufflen(buff) ((buff)->n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resetbuffer(buff) ((buff)->n = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resizebuffer(L, buff, size) (luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), (buff)->buffsize = size)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_freebuffer(L, buff) luaZ_resizebuffer(L, buff, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gt(L) (&L->l_gt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define registry(L) (&G(L)->l_registry)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BASIC_STACK_SIZE (2*LUA_MINSTACK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define curr_func(L) (clvalue(L->ci->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ci_func(ci) (clvalue((ci)->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define f_isLua(ci) (!ci_func(ci)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLua(ci) (ttisfunction((ci)->func) && f_isLua(ci))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define G(L) (L->l_G)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2ts(o) check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2ts(o) (&rawgco2ts(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2u(o) check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2u(o) (&rawgco2u(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2cl(o) check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2h(o) check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2p(o) check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2uv(o) check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ngcotouv(o) check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2th(o) check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define obj2gco(v) (cast(GCObject *, (v)))


	internal static void unlinkupval(UpVal uv)
	{
	  (c)(0)(uv.u.l.next.u.l.prev == uv && uv.u.l.prev.u.l.next == uv);
	  uv.u.l.next.u.l.prev = uv.u.l.prev; // remove from `uvhead' list
	  uv.u.l.prev.u.l.next = uv.u.l.next;
	}



/* move `dead' udata that need finalization to list `tmudata' */
	/*
	** $Id: lgc.c,v 2.38.1.1 2007/12/27 13:02:25 roberto Exp $
	** Garbage Collector
	** See Copyright Notice in lua.h
	*/



	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_VARARG
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_OPENLIB
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_SIZET ((size_t)(~(size_t)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_LUMEM ((lu_mem)(~(lu_mem)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_INT (INT_MAX-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IntPoint(p) ((unsigned int)(lu_mem)(p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (lua_assert(c), (e))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check(l,e) lua_assert(e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(c) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check luai_apicheck
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define UNUSED(x) ((void)(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast(t, exp) ((t)(exp))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_byte(i) cast(lu_byte, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_num(i) cast(lua_Number, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_int(i) cast(int, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_lock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unlock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_threadyield(L) {lua_unlock(L); lua_lock(L);}
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) x
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LAST_TAG LUA_TTHREAD
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NUM_TAGS (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TPROTO (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TUPVAL (LAST_TAG+2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TDEADKEY (LAST_TAG+3)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define CommonHeader GCObject *next; lu_byte tt; lu_byte marked
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define TValuefields Value value; int tt
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnil(o) (ttype(o) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnumber(o) (ttype(o) == LUA_TNUMBER)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisstring(o) (ttype(o) == LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttistable(o) (ttype(o) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisfunction(o) (ttype(o) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisboolean(o) (ttype(o) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisuserdata(o) (ttype(o) == LUA_TUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisthread(o) (ttype(o) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttislightuserdata(o) (ttype(o) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttype(o) ((o)->tt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gcvalue(o) check_exp(iscollectable(o), (o)->value.gc)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pvalue(o) check_exp(ttislightuserdata(o), (o)->value.p)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define nvalue(o) check_exp(ttisnumber(o), (o)->value.n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawtsvalue(o) check_exp(ttisstring(o), &(o)->value.gc->ts)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define tsvalue(o) (&rawtsvalue(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawuvalue(o) check_exp(ttisuserdata(o), &(o)->value.gc->u)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define uvalue(o) (&rawuvalue(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define clvalue(o) check_exp(ttisfunction(o), &(o)->value.gc->cl)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define hvalue(o) check_exp(ttistable(o), &(o)->value.gc->h)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bvalue(o) check_exp(ttisboolean(o), (o)->value.b)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define thvalue(o) check_exp(ttisthread(o), &(o)->value.gc->th)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_isfalse(o) (ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkconsistency(obj) lua_assert(!iscollectable(obj) || (ttype(obj) == (obj)->value.gc->gch.tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkliveness(g,obj) lua_assert(!iscollectable(obj) || ((ttype(obj) == (obj)->value.gc->gch.tt) && !isdead(g, (obj)->value.gc)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnilvalue(obj) ((obj)->tt=LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnvalue(obj,x) { TValue *i_o=(obj); i_o->value.n=(x); i_o->tt=LUA_TNUMBER; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setpvalue(obj,x) { TValue *i_o=(obj); i_o->value.p=(x); i_o->tt=LUA_TLIGHTUSERDATA; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbvalue(obj,x) { TValue *i_o=(obj); i_o->value.b=(x); i_o->tt=LUA_TBOOLEAN; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TSTRING; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setuvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TUSERDATA; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setthvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTHREAD; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setclvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TFUNCTION; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTABLE; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TPROTO; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj(L,obj1,obj2) { const TValue *o2=(obj2); TValue *o1=(obj1); o1->value = o2->value; o1->tt=o2->tt; checkliveness(G(L),o1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjs2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2s setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue2s sethvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue2s setptvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjt2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2n setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2n setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setttype(obj, tt) (ttype(obj) = (tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscollectable(o) (ttype(o) >= LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getstr(ts) cast(const char *, (ts) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define svalue(o) getstr(rawtsvalue(o))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ClosureHeader CommonHeader; lu_byte isC; lu_byte nupvalues; GCObject *gclist; struct Table *env
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscfunction(o) (ttype(o) == LUA_TFUNCTION && clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLfunction(o) (ttype(o) == LUA_TFUNCTION && !clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lmod(s,size) (check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define twoto(x) (1<<(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizenode(t) (twoto((t)->lsizenode))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaO_nilobject (&luaO_nilobject_)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ceillog2(x) (luaO_log2((x)-1) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gfasttm(g,et,e) ((et) == NULL ? NULL : ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define fasttm(l,et,e) gfasttm(G(l), et, e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocv(L,b,on,n,e) ((cast(size_t, (n)+1) <= MAX_SIZET/(e)) ? luaM_realloc_(L, (b), (on)*(e), (n)*(e)) : luaM_toobig(L))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freemem(L, b, s) luaM_realloc_(L, (b), (s), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_free(L, b) luaM_realloc_(L, (b), sizeof(*(b)), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freearray(L, b, n, t) luaM_reallocv(L, (b), n, 0, sizeof(t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_malloc(L,t) luaM_realloc_(L, NULL, 0, (t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_new(L,t) cast(t *, luaM_malloc(L, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_newvector(L,n,t) cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_growvector(L,v,nelems,size,t,limit,e) if ((nelems)+1 > (size)) ((v)=cast(t *, luaM_growaux_(L,v,&(size),sizeof(t),limit,e)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocvector(L, v,oldn,n,t) ((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define char2int(c) cast(int, cast(unsigned char, (c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define zgetc(z) (((z)->n--)>0 ? char2int(*(z)->p++) : luaZ_fill(z))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_buffer(buff) ((buff)->buffer)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_sizebuffer(buff) ((buff)->buffsize)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_bufflen(buff) ((buff)->n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resetbuffer(buff) ((buff)->n = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resizebuffer(L, buff, size) (luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), (buff)->buffsize = size)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_freebuffer(L, buff) luaZ_resizebuffer(L, buff, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gt(L) (&L->l_gt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define registry(L) (&G(L)->l_registry)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BASIC_STACK_SIZE (2*LUA_MINSTACK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define curr_func(L) (clvalue(L->ci->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ci_func(ci) (clvalue((ci)->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define f_isLua(ci) (!ci_func(ci)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLua(ci) (ttisfunction((ci)->func) && f_isLua(ci))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define G(L) (L->l_G)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2ts(o) check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2ts(o) (&rawgco2ts(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2u(o) check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2u(o) (&rawgco2u(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2cl(o) check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2h(o) check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2p(o) check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2uv(o) check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ngcotouv(o) check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2th(o) check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define obj2gco(v) (cast(GCObject *, (v)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pcRel(pc, p) (cast(int, (pc) - (p)->code) - 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getline(f,pc) (((f)->lineinfo) ? (f)->lineinfo[pc] : 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resethookcount(L) (L->hookcount = L->basehookcount)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaD_checkstack(L,n) if ((char *)L->stack_last - (char *)L->top <= (n)*(int)sizeof(TValue)) luaD_growstack(L, n); else condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define incr_top(L) {luaD_checkstack(L,1); L->top++;}
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define savestack(L,p) ((char *)(p) - (char *)L->stack)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define restorestack(L,n) ((TValue *)((char *)L->stack + (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define saveci(L,p) ((char *)(p) - (char *)L->base_ci)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define restoreci(L,n) ((CallInfo *)((char *)L->base_ci + (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeCclosure(n) (cast(int, sizeof(CClosure)) + cast(int, sizeof(TValue)*((n)-1)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeLclosure(n) (cast(int, sizeof(LClosure)) + cast(int, sizeof(TValue *)*((n)-1)))
	/*
	** $Id: lgc.h,v 2.15.1.1 2007/12/27 13:02:25 roberto Exp $
	** Garbage Collector
	** See Copyright Notice in lua.h
	*/





	/*
	** Possible states of the Garbage Collector
	*/


	/*
	** some userful bit tricks
	*/
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbits(x,m) ((x) &= cast(lu_byte, ~(m)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbits(x,m) ((x) |= (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbits(x,m) ((x) & (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bitmask(b) (1<<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bit2mask(b1,b2) (bitmask(b1) | bitmask(b2))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_setbit(x,b) setbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbit(x,b) resetbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbit(x,b) testbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define set2bits(x,b1,b2) setbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define reset2bits(x,b1,b2) resetbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define test2bits(x,b1,b2) testbits(x, (bit2mask(b1, b2)))



	/*
	** Layout for bit use in `marked' field:
	** bit 0 - object is white (type 0)
	** bit 1 - object is white (type 1)
	** bit 2 - object is black
	** bit 3 - for userdata: has been finalized
	** bit 3 - for tables: has weak keys
	** bit 4 - for tables: has weak values
	** bit 5 - object is fixed (should not be collected)
	** bit 6 - object is "super" fixed (only the main thread)
	*/


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define WHITEBITS bit2mask(WHITE0BIT, WHITE1BIT)


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iswhite(x) test2bits((x)->gch.marked, WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isblack(x) testbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isgray(x) (!isblack(x) && !iswhite(x))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define otherwhite(g) (g->currentwhite ^ WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isdead(g,v) ((v)->gch.marked & otherwhite(g) & WHITEBITS)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define changewhite(x) ((x)->gch.marked ^= WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gray2black(x) l_setbit((x)->gch.marked, BLACKBIT)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define valiswhite(x) (iscollectable(x) && iswhite(gcvalue(x)))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_white(g) cast(lu_byte, (g)->currentwhite & WHITEBITS)


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_checkGC(L) { condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1)); if (G(L)->totalbytes >= G(L)->GCthreshold) luaC_step(L); }


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),gcvalue(v)); }

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barriert(L,t,v) { if (valiswhite(v) && isblack(obj2gco(t))) luaC_barrierback(L,t); }

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarrier(L,p,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),obj2gco(o)); }

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarriert(L,t,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(t))) luaC_barrierback(L,t); }

	public static size_t luaC_separateudata(lua_State L, int all)
	{
	  global_State g = (L.l_G);
	  size_t deadmem = 0;
	  GCObject[] p = g.mainthread.next;
	  GCObject curr;
	  while ((curr = p[0]) != null)
	  {
		if (!((((curr).gch.marked) & (((bitmask(DefineConstants.WHITE0BIT) | bitmask(DefineConstants.WHITE1BIT))))) || all != 0) || ((((check_exp((curr).gch.tt == DefineConstants.LUA_TUSERDATA, ((curr).u)).uv)).marked) & ((1 << (DefineConstants.FINALIZEDBIT)))))
		{
		  p = curr.gch.next; // don't bother with them
		}
		else if ((((check_exp((curr).gch.tt == DefineConstants.LUA_TUSERDATA, ((curr).u)).uv).metatable) == null ? null : (((check_exp((curr).gch.tt == DefineConstants.LUA_TUSERDATA, ((curr).u)).uv).metatable).flags & (1u << (TMS.TM_GC))) ? null : luaT_gettm((check_exp((curr).gch.tt == DefineConstants.LUA_TUSERDATA, ((curr).u)).uv).metatable, TMS.TM_GC, ((L.l_G)).tmname[(int)TMS.TM_GC])) == null)
		{
		  ((((check_exp((curr).gch.tt == DefineConstants.LUA_TUSERDATA, ((curr).u)).uv)).marked) |= ((1 << (DefineConstants.FINALIZEDBIT)))); // don't need finalization
		  p = curr.gch.next;
		}
		else
		{ // must call its gc method
		  deadmem += (sizeof(Udata) + ((check_exp((curr).gch.tt == DefineConstants.LUA_TUSERDATA, ((curr).u)).uv)).len);
		  ((((check_exp((curr).gch.tt == DefineConstants.LUA_TUSERDATA, ((curr).u)).uv)).marked) |= ((1 << (DefineConstants.FINALIZEDBIT))));
		  p[0] = curr.gch.next;
		  /* link `curr' at the end of `tmudata' list */
		  if (g.tmudata == null) // list is empty?
		  {
			g.tmudata = curr.gch.next = curr; // creates a circular list
		  }
		  else
		  {
			curr.gch.next = g.tmudata.gch.next;
			g.tmudata.gch.next = curr;
			g.tmudata = curr;
		  }
		}
	  }
	  return deadmem;
	}

/*
** Call all GC tag methods
*/
	public static void luaC_callGCTM(lua_State L)
	{
	  while ((L.l_G).tmudata != null)
	  {
		GCTM(L);
	  }
	}
	public static void luaC_freeall(lua_State L)
	{
	  global_State g = (L.l_G);
	  int i;
	  g.currentwhite = (bitmask(DefineConstants.WHITE0BIT) | bitmask(DefineConstants.WHITE1BIT)) | (1 << (DefineConstants.SFIXEDBIT)); // mask to collect all elements
	  sweeplist(L, g.rootgc, ((LUAI_UMEM)(~(LUAI_UMEM)0) - 2));
	  for (i = 0; i < g.strt.size; i++) // free all string lists
	  {
		sweeplist(L, g.strt.hash[i], ((LUAI_UMEM)(~(LUAI_UMEM)0) - 2));
	  }
	}
	public static void luaC_step(lua_State L)
	{
	  global_State g = (L.l_G);
	  LUAI_MEM lim = (DefineConstants.GCSTEPSIZE / 100) * g.gcstepmul;
	  if (lim == 0)
	  {
		lim = (((LUAI_UMEM)(~(LUAI_UMEM)0) - 2) - 1) / 2; // no limit
	  }
	  g.gcdept += g.totalbytes - g.GCthreshold;
	  do
	  {
		lim -= singlestep(L);
		if (g.gcstate == DefineConstants.GCSpause)
		{
		  break;
		}
	  } while (lim > 0);
	  if (g.gcstate != DefineConstants.GCSpause)
	  {
		if (g.gcdept < DefineConstants.GCSTEPSIZE)
		{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: g->GCthreshold = g->totalbytes + DefineConstants.GCSTEPSIZE;
		  g.GCthreshold.CopyFrom(g.totalbytes + DefineConstants.GCSTEPSIZE); // - lim/g->gcstepmul;
		}
		else
		{
		  g.gcdept -= DefineConstants.GCSTEPSIZE;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: g->GCthreshold = g->totalbytes;
		  g.GCthreshold.CopyFrom(g.totalbytes);
		}
	  }
	  else
	  {
		(c)(0)(g.totalbytes >= g.estimate);
		(g.GCthreshold = (g.estimate / 100) * g.gcpause);
	  }
	}
	public static void luaC_fullgc(lua_State L)
	{
	  global_State g = (L.l_G);
	  if (g.gcstate <= DefineConstants.GCSpropagate)
	  {
		/* reset sweep marks to sweep all elements (returning them to white) */
		g.sweepstrgc = 0;
		g.sweepgc = g.rootgc;
		/* reset other collector lists */
		g.gray = null;
		g.grayagain = null;
		g.weak = null;
		g.gcstate = DefineConstants.GCSsweepstring;
	  }
	  (c)(0)(g.gcstate != DefineConstants.GCSpause && g.gcstate != DefineConstants.GCSpropagate);
	  /* finish any pending sweep phase */
	  while (g.gcstate != DefineConstants.GCSfinalize)
	  {
		(c)(0)(g.gcstate == DefineConstants.GCSsweepstring || g.gcstate == DefineConstants.GCSsweep);
		singlestep(L);
	  }
	  markroot(L);
	  while (g.gcstate != DefineConstants.GCSpause)
	  {
		singlestep(L);
	  }
	  (g.GCthreshold = (g.estimate / 100) * g.gcpause);
	}
	public static void luaC_link(lua_State L, GCObject o, byte tt)
	{
	  global_State g = (L.l_G);
	  o.gch.next = g.rootgc;
	  g.rootgc = o;
	  o.gch.marked = ((byte)((g).currentwhite & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))));
	  o.gch.tt = tt;
	}
	public static void luaC_linkupval(lua_State L, UpVal uv)
	{
	  global_State g = (L.l_G);
	  GCObject o = (((union GCObject)((uv))));
	  o.gch.next = g.rootgc; // link upvalue into `rootgc' list
	  g.rootgc = o;
	  if ((!(((o).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))) && !(((o).gch.marked) & (((bitmask(DefineConstants.WHITE0BIT) | bitmask(DefineConstants.WHITE1BIT)))))))
	  {
		if (g.gcstate == DefineConstants.GCSpropagate)
		{
		  (((o).gch.marked) |= ((1 << (DefineConstants.BLACKBIT)))); // closed upvalues need barrier
		  {
			  if (((((uv.v).tt) >= DefineConstants.LUA_TSTRING) && (((check_exp((((uv.v).tt) >= DefineConstants.LUA_TSTRING), (uv.v).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))) && ((((((union GCObject)((uv))))).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))))
			  {
				  luaC_barrierf(L, (((union GCObject)((uv)))), check_exp((((uv.v).tt) >= DefineConstants.LUA_TSTRING), (uv.v).value.gc));
			  }
		  };
		}
		else
		{ // sweep phase: sweep it (turning it into white)
		  ((o).gch.marked = ((byte)((((o).gch.marked & ((byte)((~((1 << (DefineConstants.BLACKBIT)) | (bitmask(DefineConstants.WHITE0BIT) | bitmask(DefineConstants.WHITE1BIT))))))) | ((byte)((g).currentwhite & (bitmask(DefineConstants.WHITE0BIT) | bitmask(DefineConstants.WHITE1BIT))))))));
		  (c)(0)(g.gcstate != DefineConstants.GCSfinalize && g.gcstate != DefineConstants.GCSpause);
		}
	  }
	}
	public static void luaC_barrierf(lua_State L, GCObject o, GCObject v)
	{
	  global_State g = (L.l_G);
	  (c)(0)((((o).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))) && (((v).gch.marked) & ((bit2mask(DefineConstants.WHITE0BIT, DefineConstants.WHITE1BIT)))) && !((v).gch.marked & (g.currentwhite ^ WHITEBITS) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) && !((o).gch.marked & (g.currentwhite ^ WHITEBITS) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))));
	  (c)(0)(g.gcstate != DefineConstants.GCSfinalize && g.gcstate != DefineConstants.GCSpause);
	  (c)(0)(((o.gch).tt) != DefineConstants.LUA_TTABLE);
	  /* must keep invariant? */
	  if (g.gcstate == DefineConstants.GCSpropagate)
	  {
		reallymarkobject(g, v); // restore invariant
	  }
	  else // don't mind
	  {
		((o).gch.marked = ((byte)((((o).gch.marked & ((byte)((~((1 << (DefineConstants.BLACKBIT)) | (bitmask(DefineConstants.WHITE0BIT) | bitmask(DefineConstants.WHITE1BIT))))))) | ((byte)((g).currentwhite & (bitmask(DefineConstants.WHITE0BIT) | bitmask(DefineConstants.WHITE1BIT)))))))); // mark as white just to avoid other barriers
	  }
	}
	public static void luaC_barrierback(lua_State L, Table t)
	{
	  global_State g = (L.l_G);
	  GCObject o = (((union GCObject)((t))));
	  (c)(0)((((o).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))) && !((o).gch.marked & (g.currentwhite ^ WHITEBITS) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))));
	  (c)(0)(g.gcstate != DefineConstants.GCSfinalize && g.gcstate != DefineConstants.GCSpause);
	  (((o).gch.marked) &= ((byte)(~((1 << (DefineConstants.BLACKBIT)))))); // make table gray (again)
	  t.gclist = g.grayagain;
	  g.grayagain = o;
	}



	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizestring(s) (sizeof(union TString)+((s)->len+1)*sizeof(char))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeudata(u) (sizeof(union Udata)+(u)->len)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_new(L, s) (luaS_newlstr(L, s, strlen(s)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_newliteral(L, s) (luaS_newlstr(L, "" s, (sizeof(s)/sizeof(char))-1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_fix(s) l_setbit((s)->tsv.marked, FIXEDBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gnode(t,i) (&(t)->node[i])
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gkey(n) (&(n)->i_key.nk)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gval(n) (&(n)->i_val)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gnext(n) ((n)->i_key.nk.next)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define key2tval(n) (&(n)->i_key.tvk)




	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define maskmarks cast_byte(~(bitmask(BLACKBIT)|WHITEBITS))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define makewhite(g,x) ((x)->gch.marked = cast_byte(((x)->gch.marked & maskmarks) | luaC_white(g)))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define white2gray(x) reset2bits((x)->gch.marked, WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define black2gray(x) resetbit((x)->gch.marked, BLACKBIT)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define stringmark(s) reset2bits((s)->tsv.marked, WHITE0BIT, WHITE1BIT)


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isfinalized(u) testbit((u)->marked, FINALIZEDBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define markfinalized(u) l_setbit((u)->marked, FINALIZEDBIT)


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define KEYWEAK bitmask(KEYWEAKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VALUEWEAK bitmask(VALUEWEAKBIT)



	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define markvalue(g,o) { checkconsistency(o); if (iscollectable(o) && iswhite(gcvalue(o))) reallymarkobject(g,gcvalue(o)); }

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define markobject(g,t) { if (iswhite(obj2gco(t))) reallymarkobject(g, obj2gco(t)); }


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setthreshold(g) (g->GCthreshold = (g->estimate/100) * g->gcpause)


	internal static void removeentry(Node n)
	{
	  (c)(0)((((((n).i_val)).tt) == DefineConstants.LUA_TNIL));
	  if ((((((n).i_key.nk)).tt) >= DefineConstants.LUA_TSTRING))
	  {
		(((((n).i_key.nk)).tt) = ((DefineConstants.LUA_TTHREAD + 3))); // dead key; remove it
	  }
	}


	internal static void reallymarkobject(global_State g, GCObject o)
	{
	  (c)(0)((((o).gch.marked) & ((bit2mask(DefineConstants.WHITE0BIT, DefineConstants.WHITE1BIT)))) && !((o).gch.marked & (g.currentwhite ^ WHITEBITS) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))));
	  (((o).gch.marked) &= ((byte)(~((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))));
	  switch (o.gch.tt)
	  {
		case DefineConstants.LUA_TSTRING:
		{
		  return;
		}
		case DefineConstants.LUA_TUSERDATA:
		{
		  Table mt = (check_exp((o).gch.tt == DefineConstants.LUA_TUSERDATA, ((o).u)).uv).metatable;
		  (((o).gch.marked) |= ((1 << (DefineConstants.BLACKBIT)))); // udata are never gray
		  if (mt != null)
		  {
			  if ((((((((union GCObject)((mt))))).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))) != 0)
			  {
				  reallymarkobject(g, (((union GCObject)((mt)))));
			  }
		  };
		  {
			  if ((((((((union GCObject)(((check_exp((o).gch.tt == DefineConstants.LUA_TUSERDATA, ((o).u)).uv).env))))).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))) != 0)
			  {
				  reallymarkobject(g, (((union GCObject)(((check_exp((o).gch.tt == DefineConstants.LUA_TUSERDATA, ((o).u)).uv).env)))));
			  }
	  };
		  return;
		}
		case (DefineConstants.LUA_TTHREAD + 2):
		{
		  UpVal uv = check_exp((o).gch.tt == (DefineConstants.LUA_TTHREAD + 2), ((o).uv));
		  {
			  (c)(0)(!(((uv.v).tt) >= DefineConstants.LUA_TSTRING) || (((uv.v).tt) == (uv.v).value.gc.gch.tt));
			  if ((((uv.v).tt) >= DefineConstants.LUA_TSTRING) && (((check_exp((((uv.v).tt) >= DefineConstants.LUA_TSTRING), (uv.v).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))))
			  {
				  reallymarkobject(g, check_exp((((uv.v).tt) >= DefineConstants.LUA_TSTRING), (uv.v).value.gc));
			  }
		  };
		  if (uv.v == uv.u.value) // closed?
		  {
			(((o).gch.marked) |= ((1 << (DefineConstants.BLACKBIT)))); // open upvalues are never black
		  }
		  return;
		}
		case DefineConstants.LUA_TFUNCTION:
		{
		  check_exp((o).gch.tt == DefineConstants.LUA_TFUNCTION, ((o).cl)).c.gclist = g.gray;
		  g.gray = o;
		  break;
		}
		case DefineConstants.LUA_TTABLE:
		{
		  check_exp((o).gch.tt == DefineConstants.LUA_TTABLE, ((o).h)).gclist = g.gray;
		  g.gray = o;
		  break;
		}
		case DefineConstants.LUA_TTHREAD:
		{
		  check_exp((o).gch.tt == DefineConstants.LUA_TTHREAD, ((o).th)).gclist = g.gray;
		  g.gray = o;
		  break;
		}
		case (DefineConstants.LUA_TTHREAD + 1):
		{
		  check_exp((o).gch.tt == (DefineConstants.LUA_TTHREAD + 1), ((o).p)).gclist = g.gray;
		  g.gray = o;
		  break;
		}
		default:
			(c)(0)(0);
		break;
	  }
	}


	internal static void marktmu(global_State g)
	{
	  GCObject u = g.tmudata;
	  if (u != null)
	  {
		do
		{
		  u = u.gch.next;
		  ((u).gch.marked = ((byte)((((u).gch.marked & ((byte)((~((1 << (DefineConstants.BLACKBIT)) | (bitmask(DefineConstants.WHITE0BIT) | bitmask(DefineConstants.WHITE1BIT))))))) | ((byte)((g).currentwhite & (bitmask(DefineConstants.WHITE0BIT) | bitmask(DefineConstants.WHITE1BIT)))))))); // may be marked, if left from previous GC
		  reallymarkobject(g, u);
		} while (u != g.tmudata);
	  }
	}


	internal static int traversetable(global_State g, Table h)
	{
	  int i;
	  int weakkey = 0;
	  int weakvalue = 0;
	  lua_TValue mode;
	  if (h.metatable != null)
	  {
			if ((((((((union GCObject)((h.metatable))))).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))) != 0)
			{
				reallymarkobject(g, (((union GCObject)((h.metatable)))));
			}
	  };
	  mode = ((h.metatable) == null ? null : (((h.metatable).flags & (1u << (TMS.TM_MODE))) != 0) ? null : luaT_gettm(h.metatable, TMS.TM_MODE, (g).tmname[(int)TMS.TM_MODE]));
	  if (mode != null && (((mode).tt) == DefineConstants.LUA_TSTRING))
	  { // is there a weak mode?
		weakkey = (StringFunctions.StrChr(((string)((check_exp((((mode).tt) == DefineConstants.LUA_TSTRING), (mode).value.gc.ts)) + 1)), 'k') != null);
		weakvalue = (StringFunctions.StrChr(((string)((check_exp((((mode).tt) == DefineConstants.LUA_TSTRING), (mode).value.gc.ts)) + 1)), 'v') != null);
		if (weakkey != 0 || weakvalue != 0)
		{ // is really weak?
		  h.marked &= ~((1 << (DefineConstants.KEYWEAKBIT)) | (1 << (DefineConstants.VALUEWEAKBIT))); // clear bits
		  h.marked |= ((byte)(((weakkey << DefineConstants.KEYWEAKBIT) | (weakvalue << DefineConstants.VALUEWEAKBIT))));
		  h.gclist = g.weak; // must be cleared after GC, ...
		  g.weak = (((union GCObject)((h)))); // ... so put in the appropriate list
		}
	  }
	  if (weakkey != 0 && weakvalue != 0)
	  {
		  return 1;
	  }
	  if (weakvalue == 0)
	  {
		i = h.sizearray;
		while (i-- != 0)
		{
			  (c)(0)(!(((h.array[i]).tt) >= DefineConstants.LUA_TSTRING) || (((h.array[i]).tt) == (h.array[i]).value.gc.gch.tt));
			  if ((((h.array[i]).tt) >= DefineConstants.LUA_TSTRING) && (((check_exp((((h.array[i]).tt) >= DefineConstants.LUA_TSTRING), (h.array[i]).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))))
			  {
				  reallymarkobject(g, check_exp((((h.array[i]).tt) >= DefineConstants.LUA_TSTRING), (h.array[i]).value.gc));
			  }
		};
	  }
	  i = ((1 << ((h).lsizenode)));
	  while (i-- != 0)
	  {
		Node n = ((h).node[i]);
		(c)(0)(((((n).i_key.nk)).tt) != (DefineConstants.LUA_TTHREAD + 3) || (((((n).i_val)).tt) == DefineConstants.LUA_TNIL));
		if ((((((n).i_val)).tt) == DefineConstants.LUA_TNIL))
		{
		  removeentry(n); // remove empty entries
		}
		else
		{
		  (c)(0)(!(((((n).i_key.nk)).tt) == DefineConstants.LUA_TNIL));
		  if (weakkey == 0)
		  {
			  (c)(0)(!(((((n).i_key.nk)).tt) >= DefineConstants.LUA_TSTRING) || (((((n).i_key.nk)).tt) == (((n).i_key.nk)).value.gc.gch.tt));
			  if ((((((n).i_key.nk)).tt) >= DefineConstants.LUA_TSTRING) && (((check_exp((((((n).i_key.nk)).tt) >= DefineConstants.LUA_TSTRING), (((n).i_key.nk)).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))))
			  {
				  reallymarkobject(g, check_exp((((((n).i_key.nk)).tt) >= DefineConstants.LUA_TSTRING), (((n).i_key.nk)).value.gc));
			  }
		  };
		  if (weakvalue == 0)
		  {
			  (c)(0)(!(((((n).i_val)).tt) >= DefineConstants.LUA_TSTRING) || (((((n).i_val)).tt) == (((n).i_val)).value.gc.gch.tt));
			  if ((((((n).i_val)).tt) >= DefineConstants.LUA_TSTRING) && (((check_exp((((((n).i_val)).tt) >= DefineConstants.LUA_TSTRING), (((n).i_val)).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))))
			  {
				  reallymarkobject(g, check_exp((((((n).i_val)).tt) >= DefineConstants.LUA_TSTRING), (((n).i_val)).value.gc));
			  }
		  };
		}
	  }
	  return weakkey || weakvalue != 0;
	}


	/*
	** All marks are conditional because a GC may happen while the
	** prototype is still being created
	*/
	internal static void traverseproto(global_State g, Proto f)
	{
	  int i;
	  if (f.source != null)
	  {
		  (((f.source).tsv.marked) &= ((byte)(~((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))));
	  }
	  for (i = 0; i < f.sizek; i++) // mark literals
	  {
			(c)(0)(!(((f.k[i]).tt) >= DefineConstants.LUA_TSTRING) || (((f.k[i]).tt) == (f.k[i]).value.gc.gch.tt));
			if ((((f.k[i]).tt) >= DefineConstants.LUA_TSTRING) && (((check_exp((((f.k[i]).tt) >= DefineConstants.LUA_TSTRING), (f.k[i]).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))))
			{
				reallymarkobject(g, check_exp((((f.k[i]).tt) >= DefineConstants.LUA_TSTRING), (f.k[i]).value.gc));
			}
	  };
	  for (i = 0; i < f.sizeupvalues; i++)
	  { // mark upvalue names
		if (f.upvalues[i] != null)
		{
		  (((f.upvalues[i]).tsv.marked) &= ((byte)(~((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))));
		}
	  }
	  for (i = 0; i < f.sizep; i++)
	  { // mark nested protos
		if (f.p[i] != null)
		{
			  if ((((((((union GCObject)((f.p[i]))))).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))) != 0)
			  {
				  reallymarkobject(g, (((union GCObject)((f.p[i])))));
			  }
		};
	  }
	  for (i = 0; i < f.sizelocvars; i++)
	  { // mark local-variable names
		if (f.locvars[i].varname != null)
		{
		  (((f.locvars[i].varname).tsv.marked) &= ((byte)(~((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))));
		}
	  }
	}



	internal static void traverseclosure(global_State g, Closure cl)
	{
	  {
		  if ((((((((union GCObject)((cl.c.env))))).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))) != 0)
		  {
			  reallymarkobject(g, (((union GCObject)((cl.c.env)))));
		  }
  };
	  if (cl.c.isC != 0)
	  {
		int i;
		for (i = 0; i < cl.c.nupvalues; i++) // mark its upvalues
		{
			  (c)(0)(!(((cl.c.upvalue[i]).tt) >= DefineConstants.LUA_TSTRING) || (((cl.c.upvalue[i]).tt) == (cl.c.upvalue[i]).value.gc.gch.tt));
			  if ((((cl.c.upvalue[i]).tt) >= DefineConstants.LUA_TSTRING) && (((check_exp((((cl.c.upvalue[i]).tt) >= DefineConstants.LUA_TSTRING), (cl.c.upvalue[i]).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))))
			  {
				  reallymarkobject(g, check_exp((((cl.c.upvalue[i]).tt) >= DefineConstants.LUA_TSTRING), (cl.c.upvalue[i]).value.gc));
			  }
		};
	  }
	  else
	  {
		int i;
		(c)(0)(cl.l.nupvalues == cl.l.p.nups);
		{
			if ((((((((union GCObject)((cl.l.p))))).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))) != 0)
			{
				reallymarkobject(g, (((union GCObject)((cl.l.p)))));
			}
		};
		for (i = 0; i < cl.l.nupvalues; i++) // mark its upvalues
		{
			  if ((((((((union GCObject)((cl.l.upvals[i]))))).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))) != 0)
			  {
				  reallymarkobject(g, (((union GCObject)((cl.l.upvals[i])))));
			  }
		};
	  }
	}


	internal static void checkstacksizes(lua_State L, lua_TValue max)
	{
	  int ci_used = ((int)((L.ci - L.base_ci))); // number of `ci' in use
	  int s_used = ((int)((max - L.stack))); // part of stack in use
	  if (L.size_ci > DefineConstants.LUAI_MAXCALLS) // handling overflow?
	  {
		return; // do not touch the stacks
	  }
	  if (4 * ci_used < L.size_ci && 2 * DefineConstants.BASIC_CI_SIZE < L.size_ci)
	  {
		luaD_reallocCI(L, L.size_ci / 2); // still big enough...
	  }
	  (x)(0)(luaD_reallocCI(L, ci_used + 1));
	  if (4 * s_used < L.stacksize && 2 * ((2 * DefineConstants.LUA_MINSTACK) + DefineConstants.EXTRA_STACK) < L.stacksize)
	  {
		luaD_reallocstack(L, L.stacksize / 2); // still big enough...
	  }
	  (x)(0)(luaD_reallocstack(L, s_used));
	}


	internal static void traversestack(global_State g, lua_State l)
	{
	  lua_TValue o;
	  lua_TValue lim;
	  CallInfo ci;
	  {
		  (c)(0)(!((((l.l_gt)).tt) >= DefineConstants.LUA_TSTRING) || ((((l.l_gt)).tt) == ((l.l_gt)).value.gc.gch.tt));
		  if (((((l.l_gt)).tt) >= DefineConstants.LUA_TSTRING) && (((check_exp(((((l.l_gt)).tt) >= DefineConstants.LUA_TSTRING), ((l.l_gt)).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))))
		  {
			  reallymarkobject(g, check_exp(((((l.l_gt)).tt) >= DefineConstants.LUA_TSTRING), ((l.l_gt)).value.gc));
		  }
	  };
	  lim = l.top;
	  for (ci = l.base_ci; ci <= l.ci; ci++)
	  {
		(c)(0)(ci.top <= l.stack_last);
		if (lim < ci.top)
		{
			lim = ci.top;
		}
	  }
	  for (o = l.stack; o < l.top; o++)
	  {
			(c)(0)(!(((o).tt) >= DefineConstants.LUA_TSTRING) || (((o).tt) == (o).value.gc.gch.tt));
			if ((((o).tt) >= DefineConstants.LUA_TSTRING) && (((check_exp((((o).tt) >= DefineConstants.LUA_TSTRING), (o).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))))
			{
				reallymarkobject(g, check_exp((((o).tt) >= DefineConstants.LUA_TSTRING), (o).value.gc));
			}
	  };
	  for (; o <= lim; o++)
	  {
		((o).tt = DefineConstants.LUA_TNIL);
	  }
	  checkstacksizes(l, lim);
	}


	/*
	** traverse one gray object, turning it to black.
	** Returns `quantity' traversed.
	*/
	internal static LUAI_MEM propagatemark(global_State g)
	{
	  GCObject o = g.gray;
	  (c)(0)((!(((o).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))) && !(((o).gch.marked) & (((bitmask(DefineConstants.WHITE0BIT) | bitmask(DefineConstants.WHITE1BIT)))))));
	  (((o).gch.marked) |= ((1 << (DefineConstants.BLACKBIT))));
	  switch (o.gch.tt)
	  {
		case DefineConstants.LUA_TTABLE:
		{
		  Table h = check_exp((o).gch.tt == DefineConstants.LUA_TTABLE, ((o).h));
		  g.gray = h.gclist;
		  if (traversetable(g, h) != 0) // table is weak?
		  {
			(((o).gch.marked) &= ((byte)(~((1 << (DefineConstants.BLACKBIT)))))); // keep it gray
		  }
		  return sizeof(Table) + sizeof(lua_TValue) * h.sizearray + sizeof(Node) * ((1 << ((h).lsizenode)));
		}
		case DefineConstants.LUA_TFUNCTION:
		{
		  Closure cl = check_exp((o).gch.tt == DefineConstants.LUA_TFUNCTION, ((o).cl));
		  g.gray = cl.c.gclist;
		  traverseclosure(g, cl);
		  return (cl.c.isC) ? (((int)(sizeof(CClosure))) + ((int)(sizeof(lua_TValue) * ((cl.c.nupvalues) - 1)))) : (((int)(sizeof(LClosure))) + ((int)(sizeof(lua_TValue) * ((cl.l.nupvalues) - 1))));
		}
		case DefineConstants.LUA_TTHREAD:
		{
		  lua_State th = check_exp((o).gch.tt == DefineConstants.LUA_TTHREAD, ((o).th));
		  g.gray = th.gclist;
		  th.gclist = g.grayagain;
		  g.grayagain = o;
		  (((o).gch.marked) &= ((byte)(~((1 << (DefineConstants.BLACKBIT))))));
		  traversestack(g, th);
		  return sizeof(lua_State) + sizeof(lua_TValue) * th.stacksize + sizeof(CallInfo) * th.size_ci;
		}
		case (DefineConstants.LUA_TTHREAD + 1):
		{
		  Proto p = check_exp((o).gch.tt == (DefineConstants.LUA_TTHREAD + 1), ((o).p));
		  g.gray = p.gclist;
		  traverseproto(g, p);
		  return sizeof(Proto) + sizeof(LUAI_UINT32) * p.sizecode + sizeof(Proto) * p.sizep + sizeof(lua_TValue) * p.sizek + sizeof(int) * p.sizelineinfo + sizeof(LocVar) * p.sizelocvars + sizeof(TString) * p.sizeupvalues;
		}
		default:
			(c)(0)(0);
			return 0;
	  }
	}


	internal static size_t propagateall(global_State g)
	{
	  size_t m = 0;
	  while (g.gray != null)
	  {
		  m += propagatemark(g);
	  }
	  return m;
	}


	/*
	** The next function tells whether a key or value can be cleared from
	** a weak table. Non-collectable objects are never removed from weak
	** tables. Strings behave as `values', so are never removed too. for
	** other objects: if really collected, cannot keep them; for userdata
	** being finalized, keep them in keys, but not in values
	*/
	internal static int iscleared(lua_TValue o, int iskey)
	{
	  if (!(((o).tt) >= DefineConstants.LUA_TSTRING))
	  {
		  return 0;
	  }
	  if ((((o).tt) == DefineConstants.LUA_TSTRING))
	  {
		(((check_exp((((o).tt) == DefineConstants.LUA_TSTRING), (o).value.gc.ts)).tsv.marked) &= ((byte)(~((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))))); // strings are `values', so are never weak
		return 0;
	  }
	  return (((check_exp((((o).tt) >= DefineConstants.LUA_TSTRING), (o).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))) || ((((o).tt) == DefineConstants.LUA_TUSERDATA) && (iskey == 0 && ((((check_exp(ttisuserdata(o), (o).value.gc.u).uv)).marked) & ((1 << (DefineConstants.FINALIZEDBIT))))));
	}


	/*
	** clear collected entries from weaktables
	*/
	internal static void cleartable(GCObject l)
	{
	  while (l != null)
	  {
		Table h = check_exp((l).gch.tt == DefineConstants.LUA_TTABLE, ((l).h));
		int i = h.sizearray;
		(c)(0)(((h.marked) & ((1 << (DefineConstants.VALUEWEAKBIT)))) || ((h.marked) & ((1 << (DefineConstants.KEYWEAKBIT)))));
		if ((((h.marked) & ((1 << (DefineConstants.VALUEWEAKBIT))))) != 0)
		{
		  while (i-- != 0)
		  {
			lua_TValue o = h.array[i];
			if (iscleared(o, 0) != 0) // value was collected?
			{
			  ((o).tt = DefineConstants.LUA_TNIL); // remove value
			}
		  }
		}
		i = ((1 << ((h).lsizenode)));
		while (i-- != 0)
		{
		  Node n = ((h).node[i]);
		  if (!(((((n).i_val)).tt) == DefineConstants.LUA_TNIL) && (iscleared(((n).i_key.tvk), 1) != 0 || iscleared(((n).i_val), 0) != 0))
		  { // non-empty entry?
			((((n).i_val)).tt = DefineConstants.LUA_TNIL); // remove value ...
			removeentry(n); // remove entry from table
		  }
		}
		l = h.gclist;
	  }
	}


	internal static void freeobj(lua_State L, GCObject o)
	{
	  switch (o.gch.tt)
	  {
		case (DefineConstants.LUA_TTHREAD + 1):
			luaF_freeproto(L, check_exp((o).gch.tt == (DefineConstants.LUA_TTHREAD + 1), ((o).p)));
			break;
		case DefineConstants.LUA_TFUNCTION:
			luaF_freeclosure(L, check_exp((o).gch.tt == DefineConstants.LUA_TFUNCTION, ((o).cl)));
			break;
		case (DefineConstants.LUA_TTHREAD + 2):
			luaF_freeupval(L, check_exp((o).gch.tt == (DefineConstants.LUA_TTHREAD + 2), ((o).uv)));
			break;
		case DefineConstants.LUA_TTABLE:
			luaH_free(L, check_exp((o).gch.tt == DefineConstants.LUA_TTABLE, ((o).h)));
			break;
		case DefineConstants.LUA_TTHREAD:
		{
		  (c)(0)(check_exp((o).gch.tt == DefineConstants.LUA_TTHREAD, ((o).th)) != L && check_exp((o).gch.tt == DefineConstants.LUA_TTHREAD, ((o).th)) != (L.l_G).mainthread);
		  luaE_freethread(L, check_exp((o).gch.tt == DefineConstants.LUA_TTHREAD, ((o).th)));
		  break;
		}
		case DefineConstants.LUA_TSTRING:
		{
		  (L.l_G).strt.nuse--;
		  luaM_realloc_(L, (o), ((sizeof(TString) + (((check_exp((o).gch.tt == DefineConstants.LUA_TSTRING, ((o).ts)).tsv)).len + 1) * sizeof(sbyte))), 0);
		  break;
		}
		case DefineConstants.LUA_TUSERDATA:
		{
		  luaM_realloc_(L, (o), ((sizeof(Udata) + ((check_exp((o).gch.tt == DefineConstants.LUA_TUSERDATA, ((o).u)).uv)).len)), 0);
		  break;
		}
		default:
			(c)(0)(0);
		break;
	  }
	}



	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sweepwholelist(L,p) sweeplist(L,p,MAX_LUMEM)


	internal static GCObject[] sweeplist(lua_State L, GCObject[] p, LUAI_UMEM count)
	{
	  GCObject curr;
	  global_State g = (L.l_G);
	  int deadmask = (g.currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))));
	  while ((curr = p[0]) != null && count-- > 0)
	  {
		if (curr.gch.tt == DefineConstants.LUA_TTHREAD) // sweep open upvalues of each thread
		{
		  sweeplist(L, check_exp((curr).gch.tt == DefineConstants.LUA_TTHREAD, ((curr).th)).openupval, ((LUAI_UMEM)(~(LUAI_UMEM)0) - 2));
		}
		if (((curr.gch.marked ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & deadmask) != 0)
		{ // not dead?
		  (c)(0)(!((curr).gch.marked & (g.currentwhite ^ WHITEBITS) & (bitmask(DefineConstants.WHITE0BIT) | bitmask(DefineConstants.WHITE1BIT))) || ((curr.gch.marked) & ((1 << (DefineConstants.FIXEDBIT)))));
		  ((curr).gch.marked = ((byte)((((curr).gch.marked & ((byte)((~((1 << (DefineConstants.BLACKBIT)) | (bitmask(DefineConstants.WHITE0BIT) | bitmask(DefineConstants.WHITE1BIT))))))) | ((byte)((g).currentwhite & (bitmask(DefineConstants.WHITE0BIT) | bitmask(DefineConstants.WHITE1BIT)))))))); // make it white (for next cycle)
		  p = curr.gch.next;
		}
		else
		{ // must erase `curr'
		  (c)(0)(((curr).gch.marked & (g.currentwhite ^ WHITEBITS) & (bitmask(DefineConstants.WHITE0BIT) | bitmask(DefineConstants.WHITE1BIT))) || deadmask == (1 << (DefineConstants.SFIXEDBIT)));
		  p[0] = curr.gch.next;
		  if (curr == g.rootgc) // is the first element of the list?
		  {
			g.rootgc = curr.gch.next; // adjust first
		  }
		  freeobj(L, curr);
		}
	  }
	  return p;
	}


	internal static void checkSizes(lua_State L)
	{
	  global_State g = (L.l_G);
	  /* check size of string hash */
	  if (g.strt.nuse < ((LUAI_UINT32)(g.strt.size / 4)) && g.strt.size > DefineConstants.MINSTRTABSIZE * 2)
	  {
		luaS_resize(L, g.strt.size / 2); // table is too big
	  }
	  /* check size of buffer */
	  if (((g.buff).buffsize) > DefineConstants.LUA_MINBUFFER * 2)
	  { // buffer too big?
		size_t newsize = ((g.buff).buffsize) / 2;
		((((g.buff).buffer) = ((string)(((cast(size_t, (newsize) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(sbyte))) ? luaM_realloc_(L, ((g.buff).buffer), ((g.buff).buffsize) * (sizeof(sbyte)), (newsize) * (sizeof(sbyte))) : luaM_toobig(L))))), (g.buff).buffsize = newsize);
	  }
	}


	internal static void GCTM(lua_State L)
	{
	  global_State g = (L.l_G);
	  GCObject o = g.tmudata.gch.next; // get first element
	  Udata udata = check_exp((o).gch.tt == DefineConstants.LUA_TUSERDATA, ((o).u));
	  lua_TValue tm;
	  /* remove udata from `tmudata' */
	  if (o == g.tmudata) // last element?
	  {
		g.tmudata = null;
	  }
	  else
	  {
		g.tmudata.gch.next = udata.uv.next;
	  }
	  udata.uv.next = g.mainthread.next; // return it to `root' list
	  g.mainthread.next = o;
	  ((o).gch.marked = ((byte)((((o).gch.marked & ((byte)((~((1 << (DefineConstants.BLACKBIT)) | (bitmask(DefineConstants.WHITE0BIT) | bitmask(DefineConstants.WHITE1BIT))))))) | ((byte)((g).currentwhite & (bitmask(DefineConstants.WHITE0BIT) | bitmask(DefineConstants.WHITE1BIT))))))));
	  tm = ((udata.uv.metatable) == null ? null : (((udata.uv.metatable).flags & (1u << (TMS.TM_GC))) != 0) ? null : luaT_gettm(udata.uv.metatable, TMS.TM_GC, ((L.l_G)).tmname[(int)TMS.TM_GC]));
	  if (tm != null)
	  {
		byte oldah = L.allowhook;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: LUAI_UMEM oldt = g->GCthreshold;
		LUAI_UMEM oldt = new LUAI_UMEM(g.GCthreshold);
		L.allowhook = 0; // stop debug hooks during GC tag method
		g.GCthreshold = 2 * g.totalbytes; // avoid GC steps
		{
			lua_TValue o2 = (tm);
			lua_TValue o1 = (L.top);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
			o1.value.CopyFrom(o2.value);
			o1.tt = o2.tt;
			(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		};
		{
			lua_TValue i_o = (L.top + 1);
			i_o.value.gc = ((union GCObject)((udata)));
			i_o.tt = DefineConstants.LUA_TUSERDATA;
			(c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	};
		L.top += 2;
		luaD_call(L, L.top - 2, 0);
		L.allowhook = oldah; // restore hooks
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: g->GCthreshold = oldt;
		g.GCthreshold.CopyFrom(oldt); // restore threshold
	  }
	}


	internal static void markmt(global_State g)
	{
	  int i;
	  for (i = 0; i < (DefineConstants.LUA_TTHREAD + 1); i++)
	  {
		if (g.mt[i])
		{
		if ((((((((union GCObject)((g.mt[i]))))).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))) != 0)
		{
			reallymarkobject(g, (((union GCObject)((g.mt[i])))));
		}
		};
	  }
	}


	/* mark root set */
	internal static void markroot(lua_State L)
	{
	  global_State g = (L.l_G);
	  g.gray = null;
	  g.grayagain = null;
	  g.weak = null;
	  {
		  if ((((((((union GCObject)((g.mainthread))))).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))) != 0)
		  {
			  reallymarkobject(g, (((union GCObject)((g.mainthread)))));
		  }
	  };
	  /* make global table be traversed before main stack */
	  {
		  (c)(0)(!((((g.mainthread.l_gt)).tt) >= DefineConstants.LUA_TSTRING) || ((((g.mainthread.l_gt)).tt) == ((g.mainthread.l_gt)).value.gc.gch.tt));
		  if (((((g.mainthread.l_gt)).tt) >= DefineConstants.LUA_TSTRING) && (((check_exp(((((g.mainthread.l_gt)).tt) >= DefineConstants.LUA_TSTRING), ((g.mainthread.l_gt)).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))))
		  {
			  reallymarkobject(g, check_exp(((((g.mainthread.l_gt)).tt) >= DefineConstants.LUA_TSTRING), ((g.mainthread.l_gt)).value.gc));
		  }
  };
  {
		  (c)(0)(!(((((L.l_G).l_registry)).tt) >= DefineConstants.LUA_TSTRING) || (((((L.l_G).l_registry)).tt) == (((L.l_G).l_registry)).value.gc.gch.tt));
		  if ((((((L.l_G).l_registry)).tt) >= DefineConstants.LUA_TSTRING) && (((check_exp((((((L.l_G).l_registry)).tt) >= DefineConstants.LUA_TSTRING), (((L.l_G).l_registry)).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))))
		  {
			  reallymarkobject(g, check_exp((((((L.l_G).l_registry)).tt) >= DefineConstants.LUA_TSTRING), (((L.l_G).l_registry)).value.gc));
		  }
  };
	  markmt(g);
	  g.gcstate = DefineConstants.GCSpropagate;
	}


	internal static void remarkupvals(global_State g)
	{
	  UpVal uv;
	  for (uv = g.uvhead.u.l.next; uv != g.uvhead; uv = uv.u.l.next)
	  {
		(c)(0)(uv.u.l.next.u.l.prev == uv && uv.u.l.prev.u.l.next == uv);
		if ((!((((((union GCObject)((uv))))).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))) && !((((((union GCObject)((uv))))).gch.marked) & (((bitmask(DefineConstants.WHITE0BIT) | bitmask(DefineConstants.WHITE1BIT)))))))
		{
			  (c)(0)(!(((uv.v).tt) >= DefineConstants.LUA_TSTRING) || (((uv.v).tt) == (uv.v).value.gc.gch.tt));
			  if ((((uv.v).tt) >= DefineConstants.LUA_TSTRING) && (((check_exp((((uv.v).tt) >= DefineConstants.LUA_TSTRING), (uv.v).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))))
			  {
				  reallymarkobject(g, check_exp((((uv.v).tt) >= DefineConstants.LUA_TSTRING), (uv.v).value.gc));
			  }
		};
	  }
	}


	internal static void atomic(lua_State L)
	{
	  global_State g = (L.l_G);
	  size_t udsize = new size_t(); // total size of userdata to be finalized
	  /* remark occasional upvalues of (maybe) dead threads */
	  remarkupvals(g);
	  /* traverse objects cautch by write barrier and by 'remarkupvals' */
	  propagateall(g);
	  /* remark weak tables */
	  g.gray = g.weak;
	  g.weak = null;
	  (c)(0)(!((((((union GCObject)((g.mainthread))))).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))));
	  {
		  if ((((((((union GCObject)((L))))).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))) != 0)
		  {
			  reallymarkobject(g, (((union GCObject)((L)))));
		  }
	  }; // mark running thread
	  markmt(g); // mark basic metatables (again)
	  propagateall(g);
	  /* remark gray again */
	  g.gray = g.grayagain;
	  g.grayagain = null;
	  propagateall(g);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: udsize = luaC_separateudata(L, 0);
	  udsize.CopyFrom(luaC_separateudata(L, 0)); // separate userdata to be finalized
	  marktmu(g); // mark `preserved' userdata
	  udsize += propagateall(g); // remark, to propagate `preserveness'
	  cleartable(g.weak); // remove collected objects from weak tables
	  /* flip current white */
	  g.currentwhite = ((byte)(((g.currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))));
	  g.sweepstrgc = 0;
	  g.sweepgc = g.rootgc;
	  g.gcstate = DefineConstants.GCSsweepstring;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: g->estimate = g->totalbytes - udsize;
	  g.estimate.CopyFrom(g.totalbytes - udsize); // first estimate
	}


	internal static LUAI_MEM singlestep(lua_State L)
	{
	  global_State g = (L.l_G);
	  /*lua_checkmemory(L);*/
	  switch (g.gcstate)
	  {
		case DefineConstants.GCSpause:
		{
		  markroot(L); // start a new collection
		  return 0;
		}
		case DefineConstants.GCSpropagate:
		{
		  if (g.gray != null)
		  {
			return propagatemark(g);
		  }
		  else
		  { // no more `gray' objects
			atomic(L); // finish mark phase
			return 0;
		  }
		}
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		case DefineConstants.GCSsweepstring:
		{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: LUAI_UMEM old = g->totalbytes;
		  LUAI_UMEM old = new LUAI_UMEM(g.totalbytes);
		  sweeplist(L, g.strt.hash[g.sweepstrgc++], ((LUAI_UMEM)(~(LUAI_UMEM)0) - 2));
		  if (g.sweepstrgc >= g.strt.size) // nothing more to sweep?
		  {
			g.gcstate = DefineConstants.GCSsweep; // end sweep-string phase
		  }
		  (c)(0)(old >= g.totalbytes);
		  g.estimate -= old - g.totalbytes;
		  return DefineConstants.GCSWEEPCOST;
		}
		case DefineConstants.GCSsweep:
		{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: LUAI_UMEM old = g->totalbytes;
		  LUAI_UMEM old = new LUAI_UMEM(g.totalbytes);
		  g.sweepgc = sweeplist(L, g.sweepgc, DefineConstants.GCSWEEPMAX);
		  if (g.sweepgc[0] == null)
		  { // nothing more to sweep?
			checkSizes(L);
			g.gcstate = DefineConstants.GCSfinalize; // end sweep phase
		  }
		  (c)(0)(old >= g.totalbytes);
		  g.estimate -= old - g.totalbytes;
		  return DefineConstants.GCSWEEPMAX * DefineConstants.GCSWEEPCOST;
		}
		case DefineConstants.GCSfinalize:
		{
		  if (g.tmudata != null)
		  {
			GCTM(L);
			if (g.estimate > DefineConstants.GCFINALIZECOST)
			{
			  g.estimate -= DefineConstants.GCFINALIZECOST;
			}
			return DefineConstants.GCFINALIZECOST;
		  }
		  else
		  {
			g.gcstate = DefineConstants.GCSpause; // end collection
			g.gcdept = 0;
			return 0;
		  }
		}
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		default:
			(c)(0)(0);
			return 0;
	  }
	}


	/*
	** $Id: linit.c,v 1.14.1.1 2007/12/27 13:02:25 roberto Exp $
	** Initialization of libraries for lua.c
	** See Copyright Notice in lua.h
	*/



	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_VARARG
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_OPENLIB
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(x) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getn(L,i) ((int)lua_objlen(L, i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_setn(L,i,j) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaI_openlib luaL_openlib
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_ERRFILE (LUA_ERRERR+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_argcheck(L, cond,numarg,extramsg) ((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkstring(L,n) (luaL_checklstring(L, (n), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optstring(L,n,d) (luaL_optlstring(L, (n), (d), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkint(L,n) ((int)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optint(L,n,d) ((int)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checklong(L,n) ((long)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optlong(L,n,d) ((long)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_typename(L,i) lua_typename(L, lua_type(L,(i)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dofile(L, fn) (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dostring(L, s) (luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getmetatable(L,n) (lua_getfield(L, LUA_REGISTRYINDEX, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_opt(L,f,n,d) (lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addchar(B,c) ((void)((B)->p < ((B)->buffer+LUAL_BUFFERSIZE) || luaL_prepbuffer(B)), (*(B)->p++ = (char)(c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_putchar(B,c) luaL_addchar(B,c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addsize(B,n) ((B)->p += (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_ref(L,lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : (lua_pushstring(L, "unlocked references are obsolete"), lua_error(L), 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unref(L,ref) luaL_unref(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getref(L,ref) lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_reg luaL_Reg


	internal luaL_Reg[] lualibs =
	{
		new luaL_Reg("", luaopen_base),
		new luaL_Reg(DefineConstants.LUA_LOADLIBNAME, luaopen_package),
		new luaL_Reg(DefineConstants.LUA_TABLIBNAME, luaopen_table),
		new luaL_Reg(DefineConstants.LUA_IOLIBNAME, luaopen_io),
		new luaL_Reg(DefineConstants.LUA_OSLIBNAME, luaopen_os),
		new luaL_Reg(DefineConstants.LUA_STRLIBNAME, luaopen_string),
		new luaL_Reg(DefineConstants.LUA_MATHLIBNAME, luaopen_math),
		new luaL_Reg(DefineConstants.LUA_DBLIBNAME, luaopen_debug),
		new luaL_Reg(null, null)
	};


	public static void luaL_openlibs(lua_State L)
	{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: const luaL_Reg *lib = lualibs;
	  luaL_Reg[] lib = new luaL_Reg(lualibs);
	  for (; lib.func; lib++)
	  {
		lua_pushcclosure(L, (lib.func), 0);
		lua_pushstring(L, lib.name);
		lua_call(L, 1, 0);
	  }
	}


	/*
	** $Id: liolib.c,v 2.73.1.3 2008/01/18 17:47:43 roberto Exp $
	** Standard I/O (and system) library
	** See Copyright Notice in lua.h
	*/




	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_VARARG
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_OPENLIB
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getn(L,i) ((int)lua_objlen(L, i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_setn(L,i,j) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaI_openlib luaL_openlib
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_ERRFILE (LUA_ERRERR+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_argcheck(L, cond,numarg,extramsg) ((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkstring(L,n) (luaL_checklstring(L, (n), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optstring(L,n,d) (luaL_optlstring(L, (n), (d), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkint(L,n) ((int)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optint(L,n,d) ((int)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checklong(L,n) ((long)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optlong(L,n,d) ((long)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_typename(L,i) lua_typename(L, lua_type(L,(i)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dofile(L, fn) (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dostring(L, s) (luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getmetatable(L,n) (lua_getfield(L, LUA_REGISTRYINDEX, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_opt(L,f,n,d) (lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addchar(B,c) ((void)((B)->p < ((B)->buffer+LUAL_BUFFERSIZE) || luaL_prepbuffer(B)), (*(B)->p++ = (char)(c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_putchar(B,c) luaL_addchar(B,c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addsize(B,n) ((B)->p += (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_ref(L,lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : (lua_pushstring(L, "unlocked references are obsolete"), lua_error(L), 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unref(L,ref) luaL_unref(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getref(L,ref) lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_reg luaL_Reg
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(x) ((void)0)





	internal string[] fnames = {"input", "output"};


	internal static int pushresult(lua_State L, int i, string filename)
	{
	  int en = errno; // calls to Lua API may change this value
	  if (i != 0)
	  {
		lua_pushboolean(L, 1);
		return 1;
	  }
	  else
	  {
		lua_pushnil(L);
		if (filename != 0)
		{
		  lua_pushfstring(L, "%s: %s", filename, strerror(en));
		}
		else
		{
		  lua_pushfstring(L, "%s", strerror(en));
		}
		lua_pushinteger(L, en);
		return 3;
	  }
	}


	internal static void fileerror(lua_State L, int arg, string filename)
	{
	  lua_pushfstring(L, "%s: %s", filename, strerror(errno));
	  luaL_argerror(L, arg, lua_tolstring(L, (-1), null));
	}


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define tofilep(L) ((FILE **)luaL_checkudata(L, 1, LUA_FILEHANDLE))


	internal static int io_type(lua_State L)
	{
	  object ud;
	  luaL_checkany(L, 1);
	  ud = lua_touserdata(L, 1);
	  lua_getfield(L, DefineConstants.LUA_REGISTRYINDEX, DefineConstants.LUA_FILEHANDLE);
	  if (ud == null || !lua_getmetatable(L, 1) || !lua_rawequal(L, -2, -1))
	  {
		lua_pushnil(L); // not a file
	  }
	  else if ((FILE)ud == null)
	  {
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "closed file", (sizeof("closed file")/sizeof(sbyte))-1);
		lua_pushlstring(L, "" "closed file", (("closed file").Length) - 1);
	  }
	  else
	  {
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "file", (sizeof("file")/sizeof(sbyte))-1);
		lua_pushlstring(L, "" "file", (("file").Length) - 1);
	  }
	  return 1;
	}


	internal static FILE tofile(lua_State L)
	{
	  FILE[] f = ((FILE)luaL_checkudata(L, 1, DefineConstants.LUA_FILEHANDLE));
	  if (f[0] == null)
	  {
		luaL_error(L, "attempt to use a closed file");
	  }
	  return f[0];
	}



	/*
	** When creating file handles, always creates a `closed' file handle
	** before opening the actual file; so, if there is a memory error, the
	** file is not left opened.
	*/
	internal static FILE[] newfile(lua_State L)
	{
	  FILE[] pf = (FILE)lua_newuserdata(L, sizeof(FILE));
	  pf[0] = null; // file handle is currently `closed'
	  (lua_getfield(L, DefineConstants.LUA_REGISTRYINDEX, (DefineConstants.LUA_FILEHANDLE)));
	  lua_setmetatable(L, -2);
	  return pf;
	}


	/*
	** function to (not) close the standard files stdin, stdout, and stderr
	*/
	internal static int io_noclose(lua_State L)
	{
	  lua_pushnil(L);
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "cannot close standard file", (sizeof("cannot close standard file")/sizeof(sbyte))-1);
	  lua_pushlstring(L, "" "cannot close standard file", (("cannot close standard file").Length) - 1);
	  return 2;
	}


	/*
	** function to close 'popen' files
	*/
	internal static int io_pclose(lua_State L)
	{
	  FILE[] p = ((FILE)luaL_checkudata(L, 1, DefineConstants.LUA_FILEHANDLE));
	  (L, p[0]);
	  int = 0;
	  p[0] = null;
	  return pushresult(L, ok, null);
	}


	/*
	** function to close regular files
	*/
	internal static int io_fclose(lua_State L)
	{
	  FILE[] p = ((FILE)luaL_checkudata(L, 1, DefineConstants.LUA_FILEHANDLE));
	  int ok = (fclosep == 0);
	  p[0] = null;
	  return pushresult(L, ok, null);
	}


	internal static int aux_close(lua_State L)
	{
	  lua_getfenv(L, 1);
	  lua_getfield(L, -1, "__close");
	  return (lua_tocfunction(L, -1))(L);
	}


	internal static int io_close(lua_State L)
	{
	  if ((lua_type(L, (1)) == DefineConstants.LUA_TNONE))
	  {
		lua_rawgeti(L, DefineConstants.LUA_ENVIRONINDEX, DefineConstants.IO_OUTPUT);
	  }
	  tofile(L); // make sure argument is a file
	  return aux_close(L);
	}


	internal static int io_gc(lua_State L)
	{
	  FILE f = (FILE)luaL_checkudata(L, 1, DefineConstants.LUA_FILEHANDLE);
	  /* ignore closed files */
	  if (f != null)
	  {
		aux_close(L);
	  }
	  return 0;
	}


	internal static int io_tostring(lua_State L)
	{
	  FILE f = (FILE)luaL_checkudata(L, 1, DefineConstants.LUA_FILEHANDLE);
	  if (f == null)
	  {
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "file (closed)", (sizeof("file (closed)")/sizeof(sbyte))-1);
		lua_pushlstring(L, "" "file (closed)", (("file (closed)").Length) - 1);
	  }
	  else
	  {
		lua_pushfstring(L, "file (%p)", f);
	  }
	  return 1;
	}


	internal static int io_open(lua_State L)
	{
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *filename = (luaL_checklstring(L, (1), null));
	  sbyte filename = (luaL_checklstring(L, (1), null));
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *mode = (luaL_optlstring(L, (2), ("r"), null));
	  sbyte mode = (luaL_optlstring(L, (2), ("r"), null));
	  FILE[] pf = newfile(L);
	  pf[0] = fopen(filename, mode);
	  return (pf[0] == null) ? pushresult(L, 0, filename) : 1;
	}


	/*
	** this function has a separated environment, which defines the
	** correct __close for 'popen' files
	*/
	internal static int io_popen(lua_State L)
	{
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *filename = (luaL_checklstring(L, (1), null));
	  sbyte filename = (luaL_checklstring(L, (1), null));
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *mode = (luaL_optlstring(L, (2), ("r"), null));
	  sbyte mode = (luaL_optlstring(L, (2), ("r"), null));
	  FILE[] pf = newfile(L);
	  pf[0] = ((filename, mode), luaL_error(L, "'" "popen" "'" " not supported"), (FILE)0);
	  return (pf[0] == null) ? pushresult(L, 0, filename) : 1;
	}


	internal static int io_tmpfile(lua_State L)
	{
	  FILE[] pf = newfile(L);
	  pf[0] = tmpfile();
	  return (pf[0] == null) ? pushresult(L, 0, null) : 1;
	}


	internal static FILE getiofile(lua_State L, int findex)
	{
	  FILE f;
	  lua_rawgeti(L, DefineConstants.LUA_ENVIRONINDEX, findex);
	  f = (FILE)lua_touserdata(L, -1);
	  if (f == null)
	  {
		luaL_error(L, "standard %s file is closed", fnames[findex - 1]);
	  }
	  return f;
	}


	internal static int g_iofile(lua_State L, int f, string mode)
	{
	  if (!(lua_type(L, (1)) <= 0))
	  {
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *filename = lua_tolstring(L, (1), null);
		sbyte filename = lua_tolstring(L, (1), null);
		if (filename != 0)
		{
		  FILE[] pf = newfile(L);
		  pf[0] = fopen(filename, mode);
		  if (pf[0] == null)
		  {
			fileerror(L, 1, filename);
		  }
		}
		else
		{
		  tofile(L); // check that it's a valid file handle
		  lua_pushvalue(L, 1);
		}
		lua_rawseti(L, DefineConstants.LUA_ENVIRONINDEX, f);
	  }
	  /* return current value */
	  lua_rawgeti(L, DefineConstants.LUA_ENVIRONINDEX, f);
	  return 1;
	}


	internal static int io_input(lua_State L)
	{
	  return g_iofile(L, DefineConstants.IO_INPUT, "r");
	}


	internal static int io_output(lua_State L)
	{
	  return g_iofile(L, DefineConstants.IO_OUTPUT, "w");
	}


	internal static int io_readline(lua_State L)
	{
	  FILE f = (FILE)lua_touserdata(L, (DefineConstants.LUA_GLOBALSINDEX - (1)));
	  int sucess;
	  if (f == null) // file is already closed?
	  {
		luaL_error(L, "file is already closed");
	  }
	  sucess = read_line(L, f);
	  if (ferror(f))
	  {
		return luaL_error(L, "%s", strerror(errno));
	  }
	  if (sucess != 0)
	  {
		  return 1;
	  }
	  else
	  { // EOF
		if (lua_toboolean(L, (DefineConstants.LUA_GLOBALSINDEX - (2))))
		{ // generator created file?
		  lua_settop(L, 0);
		  lua_pushvalue(L, (DefineConstants.LUA_GLOBALSINDEX - (1)));
		  aux_close(L); // close it
		}
		return 0;
	  }
	}


	internal static void aux_lines(lua_State L, int idx, int toclose)
	{
	  lua_pushvalue(L, idx);
	  lua_pushboolean(L, toclose); // close/not close file when finished
	  lua_pushcclosure(L, io_readline, 2);
	}


	internal static int f_lines(lua_State L)
	{
	  tofile(L); // check that it's a valid file handle
	  aux_lines(L, 1, 0);
	  return 1;
	}


	internal static int io_lines(lua_State L)
	{
	  if ((lua_type(L, (1)) <= 0))
	  { // no arguments?
		/* will iterate over default input */
		lua_rawgeti(L, DefineConstants.LUA_ENVIRONINDEX, DefineConstants.IO_INPUT);
		return f_lines(L);
	  }
	  else
	  {
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *filename = (luaL_checklstring(L, (1), null));
		sbyte filename = (luaL_checklstring(L, (1), null));
		FILE[] pf = newfile(L);
		pf[0] = fopen(filename, "r");
		if (pf[0] == null)
		{
		  fileerror(L, 1, filename);
		}
		aux_lines(L, lua_gettop(L), 1);
		return 1;
	  }
	}


	/*
	** {======================================================
	** READ
	** =======================================================
	*/


	internal static int read_number(lua_State L, FILE f)
	{
	  double d;
	  if (fscanf(f, DefineConstants.LUA_NUMBER_SCAN, d) == 1)
	  {
		lua_pushnumber(L, d);
		return 1;
	  }
	  else
	  {
		  return 0; // read fails
	  }
	}


	internal static int test_eof(lua_State L, FILE f)
	{
	  int c = getc(f);
	  ungetc(c, f);
	  lua_pushlstring(L, null, 0);
	  return (c != EOF);
	}


	internal static int read_line(lua_State L, FILE f)
	{
	  luaL_Buffer b = new luaL_Buffer();
	  luaL_buffinit(L, b);
	  for (;;)
	  {
		size_t l = new size_t();
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: sbyte *p = luaL_prepbuffer(&b);
		sbyte p = luaL_prepbuffer(b);
		if (fgets(p, BUFSIZ, f) == null)
		{ // eof?
		  luaL_pushresult(b); // close buffer
		  return (lua_objlen(L, -1) > 0); // check whether read something
		}
		l = p.Length;
		if (l == 0 || p[l - 1] != '\n')
		{
		  ((b).p += (l));
		}
		else
		{
		  ((b).p += (l - 1)); // do not include `eol'
		  luaL_pushresult(b); // close buffer
		  return 1; // read at least an `eol'
		}
	  }
	}


	internal static int read_chars(lua_State L, FILE f, size_t n)
	{
	  size_t rlen = new size_t(); // how much to read
	  size_t nr = new size_t(); // number of chars actually read
	  luaL_Buffer b = new luaL_Buffer();
	  luaL_buffinit(L, b);
	  rlen = BUFSIZ; // try to read that much each time
	  do
	  {
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
		sbyte * p = luaL_prepbuffer(b);
		if (rlen > n)
		{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: rlen = n;
			rlen.CopyFrom(n); // cannot read more than asked
		}
		nr = fread(p, sizeof(sbyte), rlen, f);
		((b).p += (nr));
		n -= nr; // still have to read `n' chars
	  } while (n > 0 && nr == rlen); // until end of count or eof
	  luaL_pushresult(b); // close buffer
	  return (n == 0 || lua_objlen(L, -1) > 0);
	}


	internal static int g_read(lua_State L, FILE f, int first)
	{
	  int nargs = lua_gettop(L) - 1;
	  int success;
	  int n;
	  clearerr(f);
	  if (nargs == 0)
	  { // no arguments?
		success = read_line(L, f);
		n = first + 1; // to return 1 result
	  }
	  else
	  { // ensure stack space for all results and for auxlib's buffer
		luaL_checkstack(L, nargs + DefineConstants.LUA_MINSTACK, "too many arguments");
		success = 1;
		for (n = first; nargs-- && success != 0; n++)
		{
		  if (lua_type(L, n) == DefineConstants.LUA_TNUMBER)
		  {
			size_t l = (size_t)lua_tointeger(L, n);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: success = (l == 0) ? test_eof(L, f) : read_chars(L, f, l);
			success = (l == 0) ? test_eof(L, f) : read_chars(L, f, new size_t(l));
		  }
		  else
		  {
			sbyte[] p = lua_tolstring(L, (n), null);
			(((p && p[0] == (sbyte)'*') || luaL_argerror(L, (n), ("invalid option"))));
			switch (p[1])
			{
			  case 'n': // number
				success = read_number(L, f);
				break;
			  case 'l': // line
				success = read_line(L, f);
				break;
			  case 'a': // file
				read_chars(L, f, ~((size_t)0)); // read MAX_SIZE_T chars
				success = 1; // always success
				break;
			  default:
				return luaL_argerror(L, n, "invalid format");
			}
		  }
		}
	  }
	  if (ferror(f))
	  {
		return pushresult(L, 0, null);
	  }
	  if (success == 0)
	  {
		lua_settop(L, -(1) - 1); // remove last result
		lua_pushnil(L); // push nil instead
	  }
	  return n - first;
	}


	internal static int io_read(lua_State L)
	{
	  return g_read(L, getiofile(L, DefineConstants.IO_INPUT), 1);
	}


	internal static int f_read(lua_State L)
	{
	  return g_read(L, tofile(L), 2);
	}

	/* }====================================================== */


	internal static int g_write(lua_State L, FILE f, int arg)
	{
	  int nargs = lua_gettop(L) - 1;
	  int status = 1;
	  for (; nargs--; arg++)
	  {
		if (lua_type(L, arg) == DefineConstants.LUA_TNUMBER)
		{
		  /* optimization: could be done exactly as for strings */
		  status = status != 0 && fprintf(f, DefineConstants.LUA_NUMBER_FMT, lua_tonumber(L, arg)) > 0;
		}
		else
		{
		  size_t l = new size_t();
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *s = luaL_checklstring(L, arg, &l);
		  sbyte s = luaL_checklstring(L, arg, l);
		  status = status != 0 && (fwrite(s, sizeof(sbyte), l, f) == l);
		}
	  }
	  return pushresult(L, status, null);
	}


	internal static int io_write(lua_State L)
	{
	  return g_write(L, getiofile(L, DefineConstants.IO_OUTPUT), 1);
	}


	internal static int f_write(lua_State L)
	{
	  return g_write(L, tofile(L), 2);
	}


	internal static int f_seek(lua_State L)
	{
	  int[] mode = {SEEK_SET, SEEK_CUR, SEEK_END};
	  string[] modenames = {"set", "cur", "end", null};
	  FILE f = tofile(L);
	  int op = luaL_checkoption(L, 2, "cur", modenames);
	  int offset = ((int)luaL_optinteger(L, (3), (0)));
	  op = fseek(f, offset, mode[op]);
	  if (op != 0)
	  {
		return pushresult(L, 0, null); // error
	  }
	  else
	  {
		lua_pushinteger(L, ftell(f));
		return 1;
	  }
	}


	internal static int f_setvbuf(lua_State L)
	{
	  int[] mode = {_IONBF, _IOFBF, _IOLBF};
	  string[] modenames = {"no", "full", "line", null};
	  FILE f = tofile(L);
	  int op = luaL_checkoption(L, 2, null, modenames);
	  ptrdiff_t sz = luaL_optinteger(L, 3, BUFSIZ);
	  int res = setvbuf(f, null, mode[op], sz);
	  return pushresult(L, res == 0, null);
	}



	internal static int io_flush(lua_State L)
	{
	  return pushresult(L, fflush(getiofile(L, DefineConstants.IO_OUTPUT)) == 0, null);
	}


	internal static int f_flush(lua_State L)
	{
	  return pushresult(L, fflush(tofile(L)) == 0, null);
	}


	internal luaL_Reg[] iolib =
	{
		new luaL_Reg("close", io_close),
		new luaL_Reg("flush", io_flush),
		new luaL_Reg("input", io_input),
		new luaL_Reg("lines", io_lines),
		new luaL_Reg("open", io_open),
		new luaL_Reg("output", io_output),
		new luaL_Reg("popen", io_popen),
		new luaL_Reg("read", io_read),
		new luaL_Reg("tmpfile", io_tmpfile),
		new luaL_Reg("type", io_type),
		new luaL_Reg("write", io_write),
		new luaL_Reg(null, null)
	};


	internal luaL_Reg[] flib =
	{
		new luaL_Reg("close", io_close),
		new luaL_Reg("flush", f_flush),
		new luaL_Reg("lines", f_lines),
		new luaL_Reg("read", f_read),
		new luaL_Reg("seek", f_seek),
		new luaL_Reg("setvbuf", f_setvbuf),
		new luaL_Reg("write", f_write),
		new luaL_Reg("__gc", io_gc),
		new luaL_Reg("__tostring", io_tostring),
		new luaL_Reg(null, null)
	};


	internal static void createmeta(lua_State L)
	{
	  luaL_newmetatable(L, DefineConstants.LUA_FILEHANDLE); // create metatable for file handles
	  lua_pushvalue(L, -1); // push metatable
	  lua_setfield(L, -2, "__index"); // metatable.__index = metatable
	  luaL_register(L, null, flib); // file methods
	}


	internal static void createstdfile(lua_State L, FILE f, int k, string fname)
	{
	  newfile(L)[0] = f;
	  if (k > 0)
	  {
		lua_pushvalue(L, -1);
		lua_rawseti(L, DefineConstants.LUA_ENVIRONINDEX, k);
	  }
	  lua_pushvalue(L, -2); // copy environment
	  lua_setfenv(L, -2); // set it
	  lua_setfield(L, -3, fname);
	}


	internal static void newfenv(lua_State L, lua_CFunction cls)
	{
	  lua_createtable(L, 0, 1);
	  lua_pushcclosure(L, (cls), 0);
	  lua_setfield(L, -2, "__close");
	}


	public static int luaopen_io(lua_State L)
	{
	  createmeta(L);
	  /* create (private) environment (with fields IO_INPUT, IO_OUTPUT, __close) */
	  newfenv(L, io_fclose);
	  lua_replace(L, DefineConstants.LUA_ENVIRONINDEX);
	  /* open library */
	  luaL_register(L, DefineConstants.LUA_IOLIBNAME, iolib);
	  /* create (and set) default files */
	  newfenv(L, io_noclose); // close function for default files
	  createstdfile(L, stdin, DefineConstants.IO_INPUT, "stdin");
	  createstdfile(L, stdout, DefineConstants.IO_OUTPUT, "stdout");
	  createstdfile(L, stderr, 0, "stderr");
	  lua_settop(L, -(1) - 1); // pop environment for default files
	  lua_getfield(L, -1, "popen");
	  newfenv(L, io_pclose); // create environment for 'popen'
	  lua_setfenv(L, -2); // set fenv for 'popen'
	  lua_settop(L, -(1) - 1); // pop 'popen'
	  return 1;
	}



	/* number of reserved words */
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NUM_RESERVED (cast(int, TK_WHILE-FIRST_RESERVED+1))


	/* array with token `names' */
//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const sbyte *const luaX_tokens [];


	public static void luaX_init(lua_State L)
	{
	  int i;
	  for (i = 0; i < (((int)(RESERVED.TK_WHILE - DefineConstants.FIRST_RESERVED + 1))); i++)
	  {
		TString ts = (luaS_newlstr(L, luaX_tokens[i], Convert.ToString(luaX_tokens[i]).Length));
		(((ts).tsv.marked) |= ((1 << (DefineConstants.FIXEDBIT)))); // reserved words are never collected
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: (c)(0)(strlen(luaX_tokens[i])+1 <= (sizeof("function")/sizeof(sbyte)));
		(c)(0)(Convert.ToString(luaX_tokens[i]).Length + 1 <= (("function").Length));
		ts.tsv.reserved = ((byte)((i + 1))); // reserved word
	  }
	}
	public static void luaX_setinput(lua_State L, LexState ls, Zio z, TString source)
	{
	  ls.decpoint = (sbyte)'.';
	  ls.L = L;
	  ls.lookahead.token = (int)RESERVED.TK_EOS; // no look-ahead token
	  ls.z = z;
	  ls.fs = null;
	  ls.linenumber = 1;
	  ls.lastline = 1;
	  ls.source = source;
	  ((((ls.buff).buffer) = ((string)(((cast(size_t, (DefineConstants.LUA_MINBUFFER) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(sbyte))) ? luaM_realloc_(ls.L, ((ls.buff).buffer), ((ls.buff).buffsize) * (sizeof(sbyte)), (DefineConstants.LUA_MINBUFFER) * (sizeof(sbyte))) : luaM_toobig(ls.L))))), (ls.buff).buffsize = DefineConstants.LUA_MINBUFFER); // initialize buffer
	  (ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z))); // read first char
	}
	public static TString luaX_newstring(LexState ls, string str, size_t l)
	{
	  lua_State L = ls.L;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: TString *ts = luaS_newlstr(L, str, l);
	  TString ts = luaS_newlstr(L, str, new size_t(l));
	  lua_TValue o = luaH_setstr(L, ls.fs.h, ts); // entry for `str'
	  if ((((o).tt) == DefineConstants.LUA_TNIL))
	  {
			lua_TValue i_o = (o);
			i_o.value.b = (1);
			i_o.tt = DefineConstants.LUA_TBOOLEAN;
	  }; // make sure `str' will not be collected
	  return ts;
	}
	public static void luaX_next(LexState ls)
	{
	  ls.lastline = ls.linenumber;
	  if (ls.lookahead.token != (int)RESERVED.TK_EOS)
	  { // is there a look-ahead token?
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: ls->t = ls->lookahead;
		ls.t.CopyFrom(ls.lookahead); // use this one
		ls.lookahead.token = (int)RESERVED.TK_EOS; // and discharge it
	  }
	  else
	  {
		ls.t.token = llex(ls, ls.t.seminfo); // read next token
	  }
	}
	public static void luaX_lookahead(LexState ls)
	{
	  (c)(0)(ls.lookahead.token == (int)RESERVED.TK_EOS);
	  ls.lookahead.token = llex(ls, ls.lookahead.seminfo);
	}
	public static void luaX_lexerror(LexState ls, string msg, int token)
	{
	  string buff = new string(new char[DefineConstants.MAXSRC]);
	  luaO_chunkid(ref buff, ((string)((ls.source) + 1)), DefineConstants.MAXSRC);
	  msg = luaO_pushfstring(ls.L, "%s:%d: %s", buff, ls.linenumber, msg);
	  if (token != 0)
	  {
		luaO_pushfstring(ls.L, "%s near " "'" "%s" "'", msg, txtToken(ls, token));
	  }
	  luaD_throw(ls.L, DefineConstants.LUA_ERRSYNTAX);
	}
	public static void luaX_syntaxerror(LexState ls, string msg)
	{
	  luaX_lexerror(ls, msg, ls.t.token);
	}
	public static string luaX_token2str(LexState ls, int token)
	{
	  if (token < DefineConstants.FIRST_RESERVED)
	  {
		(c)(0)(token == ((byte)(token)));
		return (iscntrl(token)) ? luaO_pushfstring(ls.L, "char(%d)", token) : luaO_pushfstring(ls.L, "%c", token);
	  }
	  else
	  {
		return luaX_tokens[token - DefineConstants.FIRST_RESERVED];
	  }
	}



	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbits(x,m) ((x) &= cast(lu_byte, ~(m)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbits(x,m) ((x) |= (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbits(x,m) ((x) & (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bitmask(b) (1<<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bit2mask(b1,b2) (bitmask(b1) | bitmask(b2))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_setbit(x,b) setbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbit(x,b) resetbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbit(x,b) testbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define set2bits(x,b1,b2) setbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define reset2bits(x,b1,b2) resetbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define test2bits(x,b1,b2) testbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define WHITEBITS bit2mask(WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iswhite(x) test2bits((x)->gch.marked, WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isblack(x) testbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isgray(x) (!isblack(x) && !iswhite(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define otherwhite(g) (g->currentwhite ^ WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isdead(g,v) ((v)->gch.marked & otherwhite(g) & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define changewhite(x) ((x)->gch.marked ^= WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gray2black(x) l_setbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define valiswhite(x) (iscollectable(x) && iswhite(gcvalue(x)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_white(g) cast(lu_byte, (g)->currentwhite & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_checkGC(L) { condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1)); if (G(L)->totalbytes >= G(L)->GCthreshold) luaC_step(L); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),gcvalue(v)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barriert(L,t,v) { if (valiswhite(v) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarrier(L,p,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),obj2gco(o)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarriert(L,t,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizestring(s) (sizeof(union TString)+((s)->len+1)*sizeof(char))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeudata(u) (sizeof(union Udata)+(u)->len)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_new(L, s) (luaS_newlstr(L, s, strlen(s)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_newliteral(L, s) (luaS_newlstr(L, "" s, (sizeof(s)/sizeof(char))-1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_fix(s) l_setbit((s)->tsv.marked, FIXEDBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gnode(t,i) (&(t)->node[i])
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gkey(n) (&(n)->i_key.nk)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gval(n) (&(n)->i_val)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gnext(n) ((n)->i_key.nk.next)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define key2tval(n) (&(n)->i_key.tvk)



	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define next(ls) (ls->current = zgetc(ls->z))




	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define currIsNewline(ls) (ls->current == '\n' || ls->current == '\r')


	/* ORDER RESERVED */
	public static readonly string[] luaX_tokens = {"and", "break", "do", "else", "elseif", "end", "false", "for", "function", "if", "in", "local", "nil", "not", "or", "repeat", "return", "then", "true", "until", "while", "..", "...", "==", ">=", "<=", "~=", "<number>", "<name>", "<string>", "<eof>", null};


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define save_and_next(ls) (save(ls, ls->current), next(ls))


	internal static void save(LexState ls, int c)
	{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: Mbuffer *b = ls->buff;
	  Mbuffer[] b = new Mbuffer(ls.buff);
	  if (b.n + 1 > b.buffsize != null)
	  {
		size_t newsize = new size_t();
		if (b.buffsize >= ((size_t)(~(size_t)0) - 2) / 2)
		{
		  luaX_lexerror(ls, "lexical element too long", 0);
		}
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: newsize = b->buffsize * 2;
		newsize.CopyFrom(b.buffsize * 2);
		((((b).buffer) = ((string)(((cast(size_t, (newsize) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(sbyte))) ? luaM_realloc_(ls.L, ((b).buffer), ((b).buffsize) * (sizeof(sbyte)), (newsize) * (sizeof(sbyte))) : luaM_toobig(ls.L))))), (b).buffsize = newsize);
	  }
	  b.buffer[b.n++] = ((sbyte)(c));
	}




	internal static string txtToken(LexState ls, int token)
	{
	  switch (token)
	  {
		case RESERVED.TK_NAME:
		case RESERVED.TK_STRING:
		case RESERVED.TK_NUMBER:
		  save(ls, '\0');
		  return ((ls.buff).buffer);
		default:
		  return luaX_token2str(ls, token);
	  }
	}


//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'ls', so pointers on this parameter are left unchanged:
	internal static void inclinenumber(LexState * ls)
	{
	  int old = ls.current;
	  (c)(0)((ls.current == '\n' || ls.current == '\r'));
	  (ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z))); // skip `\n' or `\r'
	  if ((ls.current == '\n' || ls.current == '\r') && ls.current != old)
	  {
		(ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z))); // skip `\n\r' or `\r\n'
	  }
	  if (++ls.linenumber >= (INT_MAX - 2))
	  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaX_syntaxerror(ls, "chunk has too many lines");
		luaX_syntaxerror(new LexState(ls), "chunk has too many lines");
	  }
	}



	/*
	** =======================================================
	** LEXICAL ANALYZER
	** =======================================================
	*/



	internal static int check_next(LexState ls, string set)
	{
	  if (!StringFunctions.StrChr(set, ls.current))
	  {
		return 0;
	  }
	  (save(ls, ls.current), (ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z))));
	  return 1;
	}


	internal static void buffreplace(LexState ls, sbyte from, sbyte to)
	{
	  size_t n = ((ls.buff).n);
	  sbyte[] p = ((ls.buff).buffer);
	  while (n-- != null)
	  {
		if (p[n] == from)
		{
			p[n] = to;
		}
	  }
	}


	internal static void trydecpoint(LexState ls, SemInfo seminfo)
	{
	  /* format error: try to update decimal point separator */
	  lconv cv = localeconv();
	  sbyte old = ls.decpoint;
	  ls.decpoint = (cv != null ? cv.decimal_point[0] : '.');
	  buffreplace(ls, old, ls.decpoint); // try updated decimal separator
	  if (luaO_str2d(((ls.buff).buffer), ref seminfo.r) == 0)
	  {
		/* format error with correct decimal point: no more options */
		buffreplace(ls, ls.decpoint, (sbyte)'.'); // undo change (for error message)
		luaX_lexerror(ls, "malformed number", RESERVED.TK_NUMBER);
	  }
	}


	/* LUA_NUMBER */
	internal static void read_numeral(LexState ls, SemInfo seminfo)
	{
	  (c)(0)(isdigit(ls.current));
	  do
	  {
		(save(ls, ls.current), (ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z))));
	  } while (isdigit(ls.current) || ls.current == '.');
	  if (check_next(ls, "Ee") != 0) // `E'?
	  {
		check_next(ls, "+-"); // optional exponent sign
	  }
	  while (isalnum(ls.current) || ls.current == '_')
	  {
		(save(ls, ls.current), (ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z))));
	  }
	  save(ls, '\0');
	  buffreplace(ls, (sbyte)'.', ls.decpoint); // follow locale for decimal point
	  if (luaO_str2d(((ls.buff).buffer), ref seminfo.r) == 0) // format error?
	  {
		trydecpoint(ls, seminfo); // try to update decimal point separator
	  }
	}


	internal static int skip_sep(LexState ls)
	{
	  int count = 0;
	  int s = ls.current;
	  (c)(0)(s == '[' || s == ']');
	  (save(ls, ls.current), (ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z))));
	  while (ls.current == '=')
	  {
		(save(ls, ls.current), (ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z))));
		count++;
	  }
	  return (ls.current == s) ? count : (-count) - 1;
	}


	internal static void read_long_string(LexState ls, SemInfo seminfo, int sep)
	{
	  int cont = 0;
	  (cont); // avoid warnings when `cont' is not used
	  (save(ls, ls.current), (ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z)))); // skip 2nd `['
	  if ((ls.current == '\n' || ls.current == '\r')) // string starts with a newline?
	  {
		inclinenumber(ls); // skip it
	  }
	  for (;;)
	  {
		switch (ls.current)
		{
		  case DefineConstants.EOZ:
			luaX_lexerror(ls, (seminfo) != null ? "unfinished long string" : "unfinished long comment", RESERVED.TK_EOS);
			break; // to avoid warnings
	#if LUA_COMPAT_LSTR
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		  case '[':
		  {
			if (skip_sep(ls) == sep)
			{
			  (save(ls, ls.current), (ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z)))); // skip 2nd `['
			  cont++;
	//C++ TO C# CONVERTER TODO TASK: C# does not allow setting or comparing #define constants:
	#if LUA_COMPAT_LSTR == 1
			  if (sep == 0)
			  {
				luaX_lexerror(ls, "nesting of [[...]] is deprecated", '[');
			  }
	#endif
			}
			break;
		  }
	#endif
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		  case ']':
		  {
			if (skip_sep(ls) == sep)
			{
			  (save(ls, ls.current), (ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z)))); // skip 2nd `]'
	//C++ TO C# CONVERTER TODO TASK: C# does not allow setting or comparing #define constants:
	#if LUA_COMPAT_LSTR && LUA_COMPAT_LSTR == 2
			  cont--;
			  if (sep == 0 && cont >= 0)
			  {
				  break;
			  }
	#endif
			  goto endloop;
			}
			break;
		  }
		  case '\n':
		  case '\r':
		  {
			save(ls, '\n');
			inclinenumber(ls);
			if (seminfo == null)
			{
				((ls.buff).n = 0); // avoid wasting space
			}
			break;
		  }
		  default:
		  {
			if (seminfo != null)
			{
				(save(ls, ls.current), (ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z))));
			}
			else
			{
				(ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z)));
			}
		  }
	  break;
		}
	  }
	  endloop:
	  if (seminfo != null)
	  {
		seminfo.ts = luaX_newstring(ls, ((ls.buff).buffer) + (2 + sep), ((ls.buff).n) - 2 * (2 + sep));
	  }
	}


	internal static void read_string(LexState ls, int del, SemInfo seminfo)
	{
	  (save(ls, ls.current), (ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z))));
	  while (ls.current != del)
	  {
		switch (ls.current)
		{
		  case DefineConstants.EOZ:
			luaX_lexerror(ls, "unfinished string", RESERVED.TK_EOS);
			continue; // to avoid warnings
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		  case '\n':
		  case '\r':
			luaX_lexerror(ls, "unfinished string", RESERVED.TK_STRING);
			continue; // to avoid warnings
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		  case '\\':
		  {
			int c;
			(ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z))); // do not save the `\'
			switch (ls.current)
			{
			  case 'a':
				  c = '\a';
				  break;
			  case 'b':
				  c = '\b';
				  break;
			  case 'f':
				  c = '\f';
				  break;
			  case 'n':
				  c = '\n';
				  break;
			  case 'r':
				  c = '\r';
				  break;
			  case 't':
				  c = '\t';
				  break;
			  case 'v':
				  c = '\v';
				  break;
			  case '\n': // go through
			  case '\r':
				  save(ls, '\n');
				  inclinenumber(ls);
				  continue;
			  case DefineConstants.EOZ:
				  continue; // will raise an error next loop
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
			  default:
			  {
				if (!isdigit(ls.current))
				{
				  (save(ls, ls.current), (ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z)))); // handles \\, \", \', and \?
				}
				else
				{ // \xxx
				  int i = 0;
				  c = 0;
				  do
				  {
					c = 10 * c + (ls.current - '0');
					(ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z)));
				  } while (++i < 3 && isdigit(ls.current));
				  if (c > UCHAR_MAX)
				  {
					luaX_lexerror(ls, "escape sequence too large", RESERVED.TK_STRING);
				  }
				  save(ls, c);
				}
				continue;
			  }
			}
			save(ls, c);
			(ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z)));
			continue;
		  }
		  default:
			(save(ls, ls.current), (ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z))));
		break;
		}
	  }
	  (save(ls, ls.current), (ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z)))); // skip delimiter
	  seminfo.ts = luaX_newstring(ls, ((ls.buff).buffer) + 1, ((ls.buff).n) - 2);
	}


	internal static int llex(LexState ls, SemInfo seminfo)
	{
	  ((ls.buff).n = 0);
	  for (;;)
	  {
		switch (ls.current)
		{
		  case '\n':
		  case '\r':
		  {
			inclinenumber(ls);
			continue;
		  }
		  case '-':
		  {
			(ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z)));
			if (ls.current != '-')
			{
				return '-';
			}
			/* else is a comment */
			(ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z)));
			if (ls.current == '[')
			{
			  int sep = skip_sep(ls);
			  ((ls.buff).n = 0); // `skip_sep' may dirty the buffer
			  if (sep >= 0)
			  {
				read_long_string(ls, null, sep); // long comment
				((ls.buff).n = 0);
				continue;
			  }
			}
			/* else short comment */
			while (!(ls.current == '\n' || ls.current == '\r') && ls.current != DefineConstants.EOZ)
			{
			  (ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z)));
			}
			continue;
		  }
		  case '[':
		  {
			int sep = skip_sep(ls);
			if (sep >= 0)
			{
			  read_long_string(ls, seminfo, sep);
			  return RESERVED.TK_STRING;
			}
			else if (sep == -1)
			{
				return '[';
			}
			else
			{
				luaX_lexerror(ls, "invalid long string delimiter", RESERVED.TK_STRING);
			}
		  }
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		  case '=':
		  {
			(ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z)));
			if (ls.current != '=')
			{
				return '=';
			}
			else
			{
				(ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z)));
				return RESERVED.TK_EQ;
			}
		  }
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		  case '<':
		  {
			(ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z)));
			if (ls.current != '=')
			{
				return '<';
			}
			else
			{
				(ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z)));
				return RESERVED.TK_LE;
			}
		  }
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		  case '>':
		  {
			(ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z)));
			if (ls.current != '=')
			{
				return '>';
			}
			else
			{
				(ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z)));
				return RESERVED.TK_GE;
			}
		  }
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		  case '~':
		  {
			(ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z)));
			if (ls.current != '=')
			{
				return '~';
			}
			else
			{
				(ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z)));
				return RESERVED.TK_NE;
			}
		  }
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		  case '"':
		  case '\'':
		  {
			read_string(ls, ls.current, seminfo);
			return RESERVED.TK_STRING;
		  }
		  case '.':
		  {
			(save(ls, ls.current), (ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z))));
			if (check_next(ls, ".") != 0)
			{
			  if (check_next(ls, ".") != 0)
			  {
				return RESERVED.TK_DOTS; // ...
			  }
			  else
			  {
				  return RESERVED.TK_CONCAT; // ..
			  }
			}
			else if (!isdigit(ls.current))
			{
				return '.';
			}
			else
			{
			  read_numeral(ls, seminfo);
			  return RESERVED.TK_NUMBER;
			}
		  }
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		  case DefineConstants.EOZ:
		  {
			return RESERVED.TK_EOS;
		  }
		  default:
		  {
			if (isspace(ls.current))
			{
			  (c)(0)(!(ls.current == '\n' || ls.current == '\r'));
			  (ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z)));
			  continue;
			}
			else if (isdigit(ls.current))
			{
			  read_numeral(ls, seminfo);
			  return RESERVED.TK_NUMBER;
			}
			else if (isalpha(ls.current) || ls.current == '_')
			{
			  /* identifier or reserved word */
			  TString ts;
			  do
			  {
				(save(ls, ls.current), (ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z))));
			  } while (isalnum(ls.current) || ls.current == '_');
			  ts = luaX_newstring(ls, ((ls.buff).buffer), ((ls.buff).n));
			  if (ts.tsv.reserved > 0) // reserved word?
			  {
				return ts.tsv.reserved - 1 + DefineConstants.FIRST_RESERVED;
			  }
			  else
			  {
				seminfo.ts = ts;
				return RESERVED.TK_NAME;
			  }
			}
			else
			{
			  int c = ls.current;
			  (ls.current = (((ls.z).n--) > 0 ? ((int)(((byte)((*(ls.z).p++))))) : luaZ_fill(ls.z)));
			  return c; // single-char tokens (+ - / ...)
			}
		  }
	  break;
		}
	  }
	}


	/*
	** $Id: lmathlib.c,v 1.67.1.1 2007/12/27 13:02:25 roberto Exp $
	** Standard mathematical library
	** See Copyright Notice in lua.h
	*/




	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_VARARG
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_LSTR
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_OPENLIB
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getn(L,i) ((int)lua_objlen(L, i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_setn(L,i,j) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaI_openlib luaL_openlib
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_ERRFILE (LUA_ERRERR+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_argcheck(L, cond,numarg,extramsg) ((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkstring(L,n) (luaL_checklstring(L, (n), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optstring(L,n,d) (luaL_optlstring(L, (n), (d), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkint(L,n) ((int)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optint(L,n,d) ((int)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checklong(L,n) ((long)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optlong(L,n,d) ((long)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_typename(L,i) lua_typename(L, lua_type(L,(i)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dofile(L, fn) (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dostring(L, s) (luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getmetatable(L,n) (lua_getfield(L, LUA_REGISTRYINDEX, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_opt(L,f,n,d) (lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addchar(B,c) ((void)((B)->p < ((B)->buffer+LUAL_BUFFERSIZE) || luaL_prepbuffer(B)), (*(B)->p++ = (char)(c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_putchar(B,c) luaL_addchar(B,c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addsize(B,n) ((B)->p += (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_ref(L,lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : (lua_pushstring(L, "unlocked references are obsolete"), lua_error(L), 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unref(L,ref) luaL_unref(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getref(L,ref) lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_reg luaL_Reg
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(x) ((void)0)


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define RADIANS_PER_DEGREE (PI/180.0)



	internal static int math_abs(lua_State L)
	{
	  lua_pushnumber(L, Math.Abs(luaL_checknumber(L, 1)));
	  return 1;
	}

	internal static int math_sin(lua_State L)
	{
	  lua_pushnumber(L, Math.Sin(luaL_checknumber(L, 1)));
	  return 1;
	}

	internal static int math_sinh(lua_State L)
	{
	  lua_pushnumber(L, Math.Sinh(luaL_checknumber(L, 1)));
	  return 1;
	}

	internal static int math_cos(lua_State L)
	{
	  lua_pushnumber(L, Math.Cos(luaL_checknumber(L, 1)));
	  return 1;
	}

	internal static int math_cosh(lua_State L)
	{
	  lua_pushnumber(L, Math.Cosh(luaL_checknumber(L, 1)));
	  return 1;
	}

	internal static int math_tan(lua_State L)
	{
	  lua_pushnumber(L, Math.Tan(luaL_checknumber(L, 1)));
	  return 1;
	}

	internal static int math_tanh(lua_State L)
	{
	  lua_pushnumber(L, Math.Tanh(luaL_checknumber(L, 1)));
	  return 1;
	}

	internal static int math_asin(lua_State L)
	{
	  lua_pushnumber(L, Math.Asin(luaL_checknumber(L, 1)));
	  return 1;
	}

	internal static int math_acos(lua_State L)
	{
	  lua_pushnumber(L, Math.Acos(luaL_checknumber(L, 1)));
	  return 1;
	}

	internal static int math_atan(lua_State L)
	{
	  lua_pushnumber(L, Math.Atan(luaL_checknumber(L, 1)));
	  return 1;
	}

	internal static int math_atan2(lua_State L)
	{
	  lua_pushnumber(L, Math.Atan2(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
	  return 1;
	}

	internal static int math_ceil(lua_State L)
	{
	  lua_pushnumber(L, Math.Ceiling(luaL_checknumber(L, 1)));
	  return 1;
	}

	internal static int math_floor(lua_State L)
	{
	  lua_pushnumber(L, Math.Floor(luaL_checknumber(L, 1)));
	  return 1;
	}

	internal static int math_fmod(lua_State L)
	{
	  lua_pushnumber(L, fmod(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
	  return 1;
	}

	internal static int math_modf(lua_State L)
	{
	  double ip;
	  double fp = modf(luaL_checknumber(L, 1), ip);
	  lua_pushnumber(L, ip);
	  lua_pushnumber(L, fp);
	  return 2;
	}

	internal static int math_sqrt(lua_State L)
	{
	  lua_pushnumber(L, Math.Sqrt(luaL_checknumber(L, 1)));
	  return 1;
	}

	internal static int math_pow(lua_State L)
	{
	  lua_pushnumber(L, Math.Pow(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
	  return 1;
	}

	internal static int math_log(lua_State L)
	{
	  lua_pushnumber(L, Math.Log(luaL_checknumber(L, 1)));
	  return 1;
	}

	internal static int math_log10(lua_State L)
	{
	  lua_pushnumber(L, Math.Log10(luaL_checknumber(L, 1)));
	  return 1;
	}

	internal static int math_exp(lua_State L)
	{
	  lua_pushnumber(L, Math.Exp(luaL_checknumber(L, 1)));
	  return 1;
	}

	internal static int math_deg(lua_State L)
	{
	  lua_pushnumber(L, luaL_checknumber(L, 1) / (DefineConstants.PI / 180.0));
	  return 1;
	}

	internal static int math_rad(lua_State L)
	{
	  lua_pushnumber(L, luaL_checknumber(L, 1) * (DefineConstants.PI / 180.0));
	  return 1;
	}

	internal static int math_frexp(lua_State L)
	{
	  int e;
	  lua_pushnumber(L, frexp(luaL_checknumber(L, 1), e));
	  lua_pushinteger(L, e);
	  return 2;
	}

	internal static int math_ldexp(lua_State L)
	{
	  lua_pushnumber(L, ldexp(luaL_checknumber(L, 1), ((int)luaL_checkinteger(L, (2)))));
	  return 1;
	}



	internal static int math_min(lua_State L)
	{
	  int n = lua_gettop(L); // number of arguments
	  double dmin = luaL_checknumber(L, 1);
	  int i;
	  for (i = 2; i <= n; i++)
	  {
		double d = luaL_checknumber(L, i);
		if (d < dmin)
		{
		  dmin = d;
		}
	  }
	  lua_pushnumber(L, dmin);
	  return 1;
	}


	internal static int math_max(lua_State L)
	{
	  int n = lua_gettop(L); // number of arguments
	  double dmax = luaL_checknumber(L, 1);
	  int i;
	  for (i = 2; i <= n; i++)
	  {
		double d = luaL_checknumber(L, i);
		if (d > dmax)
		{
		  dmax = d;
		}
	  }
	  lua_pushnumber(L, dmax);
	  return 1;
	}


	internal static int math_random(lua_State L)
	{
	  /* the `%' avoids the (rare) case of r==1, and is needed also because on
	     some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */
	  double r = (double)(RandomNumbers.NextNumber() % RAND_MAX) / (double)RAND_MAX;
	  switch (lua_gettop(L))
	  { // check number of arguments
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		case 0:
		{ // no arguments
		  lua_pushnumber(L, r); // Number between 0 and 1
		  break;
		}
		case 1:
		{ // only upper limit
		  int u = ((int)luaL_checkinteger(L, (1)));
		  (((1 <= u) || luaL_argerror(L, (1), ("interval is empty"))));
		  lua_pushnumber(L, Math.Floor(r * u) + 1); // int between 1 and `u'
		  break;
		}
		case 2:
		{ // lower and upper limits
		  int l = ((int)luaL_checkinteger(L, (1)));
		  int u = ((int)luaL_checkinteger(L, (2)));
		  (((l <= u) || luaL_argerror(L, (2), ("interval is empty"))));
		  lua_pushnumber(L, Math.Floor(r * (u - l + 1)) + l); // int between `l' and `u'
		  break;
		}
		default:
			return luaL_error(L, "wrong number of arguments");
	  }
	  return 1;
	}


	internal static int math_randomseed(lua_State L)
	{
	  RandomNumbers.Seed(((int)luaL_checkinteger(L, (1))));
	  return 0;
	}


	internal luaL_Reg[] mathlib =
	{
		new luaL_Reg("abs", math_abs),
		new luaL_Reg("acos", math_acos),
		new luaL_Reg("asin", math_asin),
		new luaL_Reg("atan2", math_atan2),
		new luaL_Reg("atan", math_atan),
		new luaL_Reg("ceil", math_ceil),
		new luaL_Reg("cosh", math_cosh),
		new luaL_Reg("cos", math_cos),
		new luaL_Reg("deg", math_deg),
		new luaL_Reg("exp", math_exp),
		new luaL_Reg("floor", math_floor),
		new luaL_Reg("fmod", math_fmod),
		new luaL_Reg("frexp", math_frexp),
		new luaL_Reg("ldexp", math_ldexp),
		new luaL_Reg("log10", math_log10),
		new luaL_Reg("log", math_log),
		new luaL_Reg("max", math_max),
		new luaL_Reg("min", math_min),
		new luaL_Reg("modf", math_modf),
		new luaL_Reg("pow", math_pow),
		new luaL_Reg("rad", math_rad),
		new luaL_Reg("random", math_random),
		new luaL_Reg("randomseed", math_randomseed),
		new luaL_Reg("sinh", math_sinh),
		new luaL_Reg("sin", math_sin),
		new luaL_Reg("sqrt", math_sqrt),
		new luaL_Reg("tanh", math_tanh),
		new luaL_Reg("tan", math_tan),
		new luaL_Reg(null, null)
	};


	/*
	** Open math library
	*/
	public static int luaopen_math(lua_State L)
	{
	  luaL_register(L, DefineConstants.LUA_MATHLIBNAME, mathlib);
	  lua_pushnumber(L, DefineConstants.PI);
	  lua_setfield(L, -2, "pi");
	  lua_pushnumber(L, HUGE_VAL);
	  lua_setfield(L, -2, "huge");
	#if LUA_COMPAT_MOD
	  lua_getfield(L, -1, "fmod");
	  lua_setfield(L, -2, "mod");
	#endif
	  return 1;
	}



/*
** generic allocation routine.
*/
	/*
	** $Id: lmem.c,v 1.70.1.1 2007/12/27 13:02:25 roberto Exp $
	** Interface to Memory Manager
	** See Copyright Notice in lua.h
	*/




	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_VARARG
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_MOD
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_LSTR
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_OPENLIB
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_SIZET ((size_t)(~(size_t)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_LUMEM ((lu_mem)(~(lu_mem)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_INT (INT_MAX-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IntPoint(p) ((unsigned int)(lu_mem)(p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (lua_assert(c), (e))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check(l,e) lua_assert(e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(c) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check luai_apicheck
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define UNUSED(x) ((void)(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast(t, exp) ((t)(exp))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_byte(i) cast(lu_byte, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_num(i) cast(lua_Number, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_int(i) cast(int, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_lock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unlock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_threadyield(L) {lua_unlock(L); lua_lock(L);}
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) x
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LAST_TAG LUA_TTHREAD
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NUM_TAGS (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TPROTO (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TUPVAL (LAST_TAG+2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TDEADKEY (LAST_TAG+3)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define CommonHeader GCObject *next; lu_byte tt; lu_byte marked
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define TValuefields Value value; int tt
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnil(o) (ttype(o) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnumber(o) (ttype(o) == LUA_TNUMBER)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisstring(o) (ttype(o) == LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttistable(o) (ttype(o) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisfunction(o) (ttype(o) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisboolean(o) (ttype(o) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisuserdata(o) (ttype(o) == LUA_TUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisthread(o) (ttype(o) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttislightuserdata(o) (ttype(o) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttype(o) ((o)->tt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gcvalue(o) check_exp(iscollectable(o), (o)->value.gc)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pvalue(o) check_exp(ttislightuserdata(o), (o)->value.p)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define nvalue(o) check_exp(ttisnumber(o), (o)->value.n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawtsvalue(o) check_exp(ttisstring(o), &(o)->value.gc->ts)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define tsvalue(o) (&rawtsvalue(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawuvalue(o) check_exp(ttisuserdata(o), &(o)->value.gc->u)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define uvalue(o) (&rawuvalue(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define clvalue(o) check_exp(ttisfunction(o), &(o)->value.gc->cl)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define hvalue(o) check_exp(ttistable(o), &(o)->value.gc->h)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bvalue(o) check_exp(ttisboolean(o), (o)->value.b)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define thvalue(o) check_exp(ttisthread(o), &(o)->value.gc->th)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_isfalse(o) (ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkconsistency(obj) lua_assert(!iscollectable(obj) || (ttype(obj) == (obj)->value.gc->gch.tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkliveness(g,obj) lua_assert(!iscollectable(obj) || ((ttype(obj) == (obj)->value.gc->gch.tt) && !isdead(g, (obj)->value.gc)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnilvalue(obj) ((obj)->tt=LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnvalue(obj,x) { TValue *i_o=(obj); i_o->value.n=(x); i_o->tt=LUA_TNUMBER; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setpvalue(obj,x) { TValue *i_o=(obj); i_o->value.p=(x); i_o->tt=LUA_TLIGHTUSERDATA; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbvalue(obj,x) { TValue *i_o=(obj); i_o->value.b=(x); i_o->tt=LUA_TBOOLEAN; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TSTRING; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setuvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TUSERDATA; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setthvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTHREAD; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setclvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TFUNCTION; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTABLE; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TPROTO; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj(L,obj1,obj2) { const TValue *o2=(obj2); TValue *o1=(obj1); o1->value = o2->value; o1->tt=o2->tt; checkliveness(G(L),o1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjs2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2s setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue2s sethvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue2s setptvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjt2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2n setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2n setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setttype(obj, tt) (ttype(obj) = (tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscollectable(o) (ttype(o) >= LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getstr(ts) cast(const char *, (ts) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define svalue(o) getstr(rawtsvalue(o))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ClosureHeader CommonHeader; lu_byte isC; lu_byte nupvalues; GCObject *gclist; struct Table *env
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscfunction(o) (ttype(o) == LUA_TFUNCTION && clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLfunction(o) (ttype(o) == LUA_TFUNCTION && !clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lmod(s,size) (check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define twoto(x) (1<<(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizenode(t) (twoto((t)->lsizenode))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaO_nilobject (&luaO_nilobject_)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ceillog2(x) (luaO_log2((x)-1) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gfasttm(g,et,e) ((et) == NULL ? NULL : ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define fasttm(l,et,e) gfasttm(G(l), et, e)
	/*
	** $Id: lmem.h,v 1.31.1.1 2007/12/27 13:02:25 roberto Exp $
	** Interface to Memory Manager
	** See Copyright Notice in lua.h
	*/







	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocv(L,b,on,n,e) ((cast(size_t, (n)+1) <= MAX_SIZET/(e)) ? luaM_realloc_(L, (b), (on)*(e), (n)*(e)) : luaM_toobig(L))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freemem(L, b, s) luaM_realloc_(L, (b), (s), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_free(L, b) luaM_realloc_(L, (b), sizeof(*(b)), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freearray(L, b, n, t) luaM_reallocv(L, (b), n, 0, sizeof(t))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_malloc(L,t) luaM_realloc_(L, NULL, 0, (t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_new(L,t) cast(t *, luaM_malloc(L, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_newvector(L,n,t) cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_growvector(L,v,nelems,size,t,limit,e) if ((nelems)+1 > (size)) ((v)=cast(t *, luaM_growaux_(L,v,&(size),sizeof(t),limit,e)))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocvector(L, v,oldn,n,t) ((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))


	public static object luaM_realloc_(lua_State L, object block, size_t osize, size_t nsize)
	{
	  global_State g = (L.l_G);
	  (c)(0)((osize == 0) == (block == null));
	  block = g.frealloc(g.ud, block, osize, nsize);
	  if (block == null && nsize > 0)
	  {
		luaD_throw(L, DefineConstants.LUA_ERRMEM);
	  }
	  (c)(0)((nsize == 0) == (block == null));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: g->totalbytes = (g->totalbytes - osize) + nsize;
	  g.totalbytes.CopyFrom((g.totalbytes - osize) + nsize);
	  return block;
	}
	public static object luaM_toobig(lua_State L)
	{
	  luaG_runerror(L, "memory allocation error: block too big");
	  return null; // to avoid warnings
	}
	public static object luaM_growaux_(lua_State L, object block, ref int size, size_t size_elems, int limit, string errormsg)
	{
	  object newblock;
	  int newsize;
	  if (size >= limit / 2)
	  { // cannot double it?
		if (size >= limit) // cannot grow even a little?
		{
		  luaG_runerror(L, errormsg);
		}
		newsize = limit; // still have at least one free place
	  }
	  else
	  {
		newsize = size * 2;
		if (newsize < DefineConstants.MINSIZEARRAY)
		{
		  newsize = DefineConstants.MINSIZEARRAY; // minimum size
		}
	  }
	  newblock = ((((size_t)((newsize) + 1)) <= ((size_t)(~(size_t)0) - 2) / (size_elems)) ? luaM_realloc_(L, (block), size * (size_elems), (newsize) * (size_elems)) : luaM_toobig(L));
	  size = newsize; // update only when everything else is OK
	  return newblock;
	}



	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define char2int(c) cast(int, cast(unsigned char, (c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define zgetc(z) (((z)->n--)>0 ? char2int(*(z)->p++) : luaZ_fill(z))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_buffer(buff) ((buff)->buffer)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_sizebuffer(buff) ((buff)->buffsize)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_bufflen(buff) ((buff)->n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resetbuffer(buff) ((buff)->n = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resizebuffer(L, buff, size) (luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), (buff)->buffsize = size)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_freebuffer(L, buff) luaZ_resizebuffer(L, buff, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gt(L) (&L->l_gt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define registry(L) (&G(L)->l_registry)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BASIC_STACK_SIZE (2*LUA_MINSTACK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define curr_func(L) (clvalue(L->ci->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ci_func(ci) (clvalue((ci)->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define f_isLua(ci) (!ci_func(ci)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLua(ci) (ttisfunction((ci)->func) && f_isLua(ci))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define G(L) (L->l_G)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2ts(o) check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2ts(o) (&rawgco2ts(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2u(o) check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2u(o) (&rawgco2u(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2cl(o) check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2h(o) check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2p(o) check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2uv(o) check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ngcotouv(o) check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2th(o) check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define obj2gco(v) (cast(GCObject *, (v)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pcRel(pc, p) (cast(int, (pc) - (p)->code) - 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getline(f,pc) (((f)->lineinfo) ? (f)->lineinfo[pc] : 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resethookcount(L) (L->hookcount = L->basehookcount)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaD_checkstack(L,n) if ((char *)L->stack_last - (char *)L->top <= (n)*(int)sizeof(TValue)) luaD_growstack(L, n); else condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define incr_top(L) {luaD_checkstack(L,1); L->top++;}
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define savestack(L,p) ((char *)(p) - (char *)L->stack)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define restorestack(L,n) ((TValue *)((char *)L->stack + (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define saveci(L,p) ((char *)(p) - (char *)L->base_ci)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define restoreci(L,n) ((CallInfo *)((char *)L->base_ci + (n)))



	/*
	** About the realloc function:
	** void * frealloc (void *ud, void *ptr, size_t osize, size_t nsize);
	** (`osize' is the old size, `nsize' is the new size)
	**
	** Lua ensures that (ptr == NULL) iff (osize == 0).
	**
	** * frealloc(ud, NULL, 0, x) creates a new block of size `x'
	**
	** * frealloc(ud, p, x, 0) frees the block `p'
	** (in this specific case, frealloc must return NULL).
	** particularly, frealloc(ud, NULL, 0, 0) does nothing
	** (which is equivalent to free(NULL) in ANSI C)
	**
	** frealloc returns NULL if it cannot create or reallocate the area
	** (any reallocation to an equal or smaller size cannot fail!)
	*/





/*
** {========================================================================
** This is an implementation of loadlib based on the dlfcn interface.
** The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,
** NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least
** as an emulation layer on top of native functions.
** =========================================================================
*/


	/*
	** $Id: loadlib.c,v 1.52.1.3 2008/08/06 13:29:28 roberto Exp $
	** Dynamic library loader for Lua
	** See Copyright Notice in lua.h
	**
	** This module contains an implementation of loadlib for Unix systems
	** that have dlfcn, an implementation for Darwin (Mac OS X), an
	** implementation for Windows, and a stub for other systems.
	*/





	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_VARARG
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_MOD
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_LSTR
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_OPENLIB
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getn(L,i) ((int)lua_objlen(L, i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_setn(L,i,j) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaI_openlib luaL_openlib
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_ERRFILE (LUA_ERRERR+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_argcheck(L, cond,numarg,extramsg) ((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkstring(L,n) (luaL_checklstring(L, (n), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optstring(L,n,d) (luaL_optlstring(L, (n), (d), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkint(L,n) ((int)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optint(L,n,d) ((int)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checklong(L,n) ((long)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optlong(L,n,d) ((long)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_typename(L,i) lua_typename(L, lua_type(L,(i)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dofile(L, fn) (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dostring(L, s) (luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getmetatable(L,n) (lua_getfield(L, LUA_REGISTRYINDEX, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_opt(L,f,n,d) (lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addchar(B,c) ((void)((B)->p < ((B)->buffer+LUAL_BUFFERSIZE) || luaL_prepbuffer(B)), (*(B)->p++ = (char)(c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_putchar(B,c) luaL_addchar(B,c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addsize(B,n) ((B)->p += (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_ref(L,lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : (lua_pushstring(L, "unlocked references are obsolete"), lua_error(L), 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unref(L,ref) luaL_unref(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getref(L,ref) lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_reg luaL_Reg
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(x) ((void)0)


	/* prefix for open functions in C libraries */

	/* separator for open functions in C libraries */



	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define POF LUA_POF


	/* error codes for ll_loadfunc */

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setprogdir(L) ((void)0)


	#if LUA_DL_DLOPEN
	internal static void ll_unloadlib(object lib)
	{
	  dlclose(lib);
	}
	internal static object ll_load(lua_State L, string path)
	{
	  object lib = dlopen(path, RTLD_NOW);
	  if (lib == null)
	  {
		  lua_pushstring(L, dlerror());
	  }
	  return lib;
	}
	internal static lua_CFunction ll_sym(lua_State L, object lib, string sym)
	{
	  lua_CFunction f = (lua_CFunction)dlsym(lib, sym);
	  if (f == null)
	  {
		  lua_pushstring(L, dlerror());
	  }
	  return f;
	}




	/* }====================================================== */



	#elif LUA_DL_DLL
	/*
	** {======================================================================
	** This is an implementation of loadlib for Windows using native functions.
	** =======================================================================
	*/



	#undef setprogdir

	internal static void(L UnnamedParameter)(0)(struct lua_State * L)
	{
	  string buff = new string(new char[MAX_PATH + 1]);
	  string lb;
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: uint nsize = sizeof(buff)/sizeof(sbyte);
	  uint nsize = buff.Length;
	  uint n = GetModuleFileNameA(null, buff, nsize);
	  if (n == 0 || n == nsize || (lb = StringFunctions.StrRChr(buff, '\\')) == null)
	  {
		luaL_error(L, "unable to get ModuleFileName");
	  }
	  else
	  {
		lb = (sbyte)'\0';
		luaL_gsub(L, lua_tolstring(L, (-1), null), DefineConstants.LUA_EXECDIR, buff);
		lua_remove(L, -2); // remove original string
	  }
	}


	internal static void pusherror(lua_State L)
	{
	  int error = GetLastError();
	  string buffer = new string(new char[128]);
	  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM, null, error, 0, buffer, sizeof(sbyte), null))
	  {
		lua_pushstring(L, buffer);
	  }
	  else
	  {
		lua_pushfstring(L, "system error %d\n", error);
	  }
	}

	internal static void ll_unloadlib(object lib)
	{
//C++ TO C# CONVERTER NOTE: There is no C# equivalent to 'FreeLibrary':
	//  FreeLibrary((System.IntPtr)lib);
	}


	internal static object ll_load(lua_State L, string path)
	{
	  IntPtr lib = LoadLibraryA(path);
	  if (lib == null)
	  {
		  pusherror(L);
	  }
	  return lib;
	}


	internal static lua_CFunction ll_sym(lua_State L, object lib, string sym)
	{
	  lua_CFunction f = (lua_CFunction)GetProcAddress((IntPtr)lib, sym);
	  if (f == null)
	  {
		  pusherror(L);
	  }
	  return f;
	}

	/* }====================================================== */



	#elif LUA_DL_DYLD
	/*
	** {======================================================================
	** Native Mac OS X / Darwin Implementation
	** =======================================================================
	*/



	/* Mac appends a `_' before C function names */
	#undef POF
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define POF "_" LUA_POF
	#define POF


	internal static void pusherror(lua_State L)
	{
	  string err_str;
	  string err_file;
	  NSLinkEditErrors err = new NSLinkEditErrors();
	  int err_num;
	  NSLinkEditError(err, err_num, err_file, err_str);
	  lua_pushstring(L, err_str);
	}


	internal static string errorfromcode(NSObjectFileImageReturnCode ret)
	{
	  switch (ret)
	  {
		case NSObjectFileImageInappropriateFile:
		  return "file is not a bundle";
		case NSObjectFileImageArch:
		  return "library is for wrong CPU type";
		case NSObjectFileImageFormat:
		  return "bad format";
		case NSObjectFileImageAccess:
		  return "cannot access file";
		case NSObjectFileImageFailure:
		default:
		  return "unable to load library";
	  }
	}


	internal static void ll_unloadlib(object lib)
	{
	  NSUnLinkModule((NSModule)lib, NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES);
	}


	internal static object ll_load(lua_State L, string path)
	{
	  NSObjectFileImage img = new NSObjectFileImage();
	  NSObjectFileImageReturnCode ret = new NSObjectFileImageReturnCode();
	  /* this would be a rare case, but prevents crashing if it happens */
	  if (!_dyld_present())
	  {
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "dyld not present", (sizeof("dyld not present")/sizeof(sbyte))-1);
		lua_pushlstring(L, "" "dyld not present", (("dyld not present").Length) - 1);
		return null;
	  }
	  ret = NSCreateObjectFileImageFromFile(path, img);
	  if (ret == NSObjectFileImageSuccess)
	  {
		NSModule mod = NSLinkModule(img, path, NSLINKMODULE_OPTION_PRIVATE | NSLINKMODULE_OPTION_RETURN_ON_ERROR);
		NSDestroyObjectFileImage(img);
		if (mod == null)
		{
			pusherror(L);
		}
		return mod;
	  }
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: lua_pushstring(L, errorfromcode(ret));
	  lua_pushstring(L, errorfromcode(new NSObjectFileImageReturnCode(ret)));
	  return null;
	}


	internal static lua_CFunction ll_sym(lua_State L, object lib, string sym)
	{
	  NSSymbol nss = NSLookupSymbolInModule((NSModule)lib, sym);
	  if (nss == null)
	  {
		lua_pushfstring(L, "symbol " "'" "%s" "'" " not found", sym);
		return null;
	  }
	  return (lua_CFunction)NSAddressOfSymbol(nss);
	}

	/* }====================================================== */



	#else
	/*
	** {======================================================
	** Fallback for other systems
	** =======================================================
	*/

	#undef LIB_FAIL
	#define LIB_FAIL


	#define DLMSG


	internal static void ll_unloadlib(object lib)
	{
	  lib; // to avoid warnings
	}


	internal static object ll_load(lua_State L, string path)
	{
	  path; // to avoid warnings
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" DefineConstants.DLMSG, (sizeof(DefineConstants.DLMSG)/sizeof(sbyte))-1);
	  lua_pushlstring(L, "" DefineConstants.DLMSG, (DefineConstants.DLMSG.Length) - 1);
	  return null;
	}


	internal static lua_CFunction ll_sym(lua_State L, object lib, string sym)
	{
	  lib;
	  sym; // to avoid warnings
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" DefineConstants.DLMSG, (sizeof(DefineConstants.DLMSG)/sizeof(sbyte))-1);
	  lua_pushlstring(L, "" DefineConstants.DLMSG, (DefineConstants.DLMSG.Length) - 1);
	  return null;
	}

	/* }====================================================== */
	#endif



	internal static object[] ll_register(lua_State L, string path)
	{
	  object[] plib;
	  lua_pushfstring(L, "%s%s", DefineConstants.LIBPREFIX, path);
	  lua_gettable(L, DefineConstants.LUA_REGISTRYINDEX); // check library in registry?
	  if (!(lua_type(L, (-1)) == DefineConstants.LUA_TNIL)) // is there an entry?
	  {
		plib = (object)lua_touserdata(L, -1);
	  }
	  else
	  { // no entry yet; create one
		lua_settop(L, -(1) - 1);
		plib = (object)lua_newuserdata(L, sizeof(object));
		plib[0] = null;
		(lua_getfield(L, DefineConstants.LUA_REGISTRYINDEX, ("_LOADLIB")));
		lua_setmetatable(L, -2);
		lua_pushfstring(L, "%s%s", DefineConstants.LIBPREFIX, path);
		lua_pushvalue(L, -2);
		lua_settable(L, DefineConstants.LUA_REGISTRYINDEX);
	  }
	  return plib;
	}


	/*
	** __gc tag method: calls library's `ll_unloadlib' function with the lib
	** handle
	*/
	internal static int gctm(lua_State L)
	{
	  object[] lib = (object)luaL_checkudata(L, 1, "_LOADLIB");
	  if lib
	  {
		  ll_unloadliblib;
	  }
	  lib[0] = null; // mark library as closed
	  return 0;
	}


	internal static int ll_loadfunc(lua_State L, string path, string sym)
	{
	  object[] reg = ll_register(L, path);
	  if (reg[0] == null)
	  {
		  reg[0] = ll_load(L, path);
	  }
	  if (reg[0] == null)
	  {
		return DefineConstants.ERRLIB; // unable to load library
	  }
	  else
	  {
		lua_CFunction f = ll_sym(L, reg[0], sym);
		if (f == null)
		{
		  return DefineConstants.ERRFUNC; // unable to find function
		}
		lua_pushcclosure(L, (f), 0);
		return 0; // return function
	  }
	}


	internal static int ll_loadlib(lua_State L)
	{
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *path = (luaL_checklstring(L, (1), null));
	  sbyte path = (luaL_checklstring(L, (1), null));
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *init = (luaL_checklstring(L, (2), null));
	  sbyte init = (luaL_checklstring(L, (2), null));
	  int stat = ll_loadfunc(L, path, init);
	  if (stat == 0) // no errors?
	  {
		return 1; // return the loaded function
	  }
	  else
	  { // error; error message is on stack top
		lua_pushnil(L);
		lua_insert(L, -2);
		lua_pushstring(L, (stat == DefineConstants.ERRLIB) ? DefineConstants.LIB_FAIL : "init");
		return 3; // return nil, error message, and where
	  }
	}



	/*
	** {======================================================
	** 'require' function
	** =======================================================
	*/


	internal static int readable(string filename)
	{
	  FILE f = fopen(filename, "r"); // try to open file
	  if (f == null)
	  {
		  return 0; // open failed
	  }
	  fclose(f);
	  return 1;
	}


//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'path', so pointers on this parameter are left unchanged:
	internal static string pushnexttemplate(lua_State L, sbyte * path)
	{
	  string l;
	  while (*path == *DefineConstants.LUA_PATHSEP)
	  {
		  path = path.Substring(1); // skip separators
	  }
	  if (*path == (sbyte)'\0')
	  {
		  return null; // no more templates
	  }
	  l = StringFunctions.StrChr(path, *DefineConstants.LUA_PATHSEP); // find next separator
	  if (l == null)
	  {
		  l = path.Substring(path.Length);
	  }
	  lua_pushlstring(L, path, l - path); // template
	  return l;
	}


	internal static string findfile(lua_State L, string name, string pname)
	{
	  string path;
	  name = luaL_gsub(L, name, ".", DefineConstants.LUA_DIRSEP);
	  lua_getfield(L, DefineConstants.LUA_ENVIRONINDEX, pname);
	  path = lua_tolstring(L, (-1), null);
	  if (path == null)
	  {
		luaL_error(L, "'" "package.%s" "'" " must be a string", pname);
	  }
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "", (sizeof("")/sizeof(sbyte))-1);
	  lua_pushlstring(L, "" "", (("").Length) - 1); // error accumulator
	  while ((path = pushnexttemplate(L, path)) != null)
	  {
		string filename;
		filename = luaL_gsub(L, lua_tolstring(L, (-1), null), DefineConstants.LUA_PATH_MARK, name);
		lua_remove(L, -2); // remove path template
		if (readable(filename) != 0) // does file exist and is readable?
		{
		  return filename; // return that file name
		}
		lua_pushfstring(L, "\n\tno file " "'" "%s" "'", filename);
		lua_remove(L, -2); // remove file name
		lua_concat(L, 2); // add entry to possible error message
	  }
	  return null; // not found
	}


	internal static void loaderror(lua_State L, string filename)
	{
	  luaL_error(L, "error loading module " "'" "%s" "'" " from file " "'" "%s" "'" ":\n\t%s", lua_tolstring(L, (1), null), filename, lua_tolstring(L, (-1), null));
	}


	internal static int loader_Lua(lua_State L)
	{
	  string filename;
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *name = (luaL_checklstring(L, (1), null));
	  sbyte name = (luaL_checklstring(L, (1), null));
	  filename = findfile(L, name, "path");
	  if (filename == null)
	  {
		  return 1; // library not found in this path
	  }
	  if (luaL_loadfile(L, filename) != 0)
	  {
		loaderror(L, filename);
	  }
	  return 1; // library loaded successfully
	}


	internal static string mkfuncname(lua_State L, string modname)
	{
	  string funcname;
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *mark = strchr(modname, *DefineConstants.LUA_IGMARK);
	  sbyte mark = StringFunctions.StrChr(modname, *DefineConstants.LUA_IGMARK);
	  if (mark != 0)
	  {
		  modname = mark + 1;
	  }
	  funcname = luaL_gsub(L, modname, ".", DefineConstants.LUA_OFSEP);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'POF' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	  funcname = lua_pushfstring(L, POF"%s", funcname);
	  lua_remove(L, -2); // remove 'gsub' result
	  return funcname;
	}


	internal static int loader_C(lua_State L)
	{
	  string funcname;
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *name = (luaL_checklstring(L, (1), null));
	  sbyte name = (luaL_checklstring(L, (1), null));
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *filename = findfile(L, name, "cpath");
	  sbyte filename = findfile(L, name, "cpath");
	  if (filename == null)
	  {
		  return 1; // library not found in this path
	  }
	  funcname = mkfuncname(L, name);
	  if (ll_loadfunc(L, filename, funcname) != 0)
	  {
		loaderror(L, filename);
	  }
	  return 1; // library loaded successfully
	}


	internal static int loader_Croot(lua_State L)
	{
	  string funcname;
	  string filename;
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *name = (luaL_checklstring(L, (1), null));
	  sbyte name = (luaL_checklstring(L, (1), null));
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *p = strchr(name, '.');
	  sbyte p = StringFunctions.StrChr(name, '.');
	  int stat;
	  if (p == null)
	  {
		  return 0; // is root
	  }
	  lua_pushlstring(L, name, p - name);
	  filename = findfile(L, lua_tolstring(L, (-1), null), "cpath");
	  if (filename == null)
	  {
		  return 1; // root not found
	  }
	  funcname = mkfuncname(L, name);
	  if ((stat = ll_loadfunc(L, filename, funcname)) != 0)
	  {
		if (stat != DefineConstants.ERRFUNC)
		{
			loaderror(L, filename); // real error
		}
		lua_pushfstring(L, "\n\tno module " "'" "%s" "'" " in file " "'" "%s" "'", name, filename);
		return 1; // function not found
	  }
	  return 1;
	}


	internal static int loader_preload(lua_State L)
	{
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *name = (luaL_checklstring(L, (1), null));
	  sbyte name = (luaL_checklstring(L, (1), null));
	  lua_getfield(L, DefineConstants.LUA_ENVIRONINDEX, "preload");
	  if (!(lua_type(L, (-1)) == DefineConstants.LUA_TTABLE))
	  {
		luaL_error(L, "'" "package.preload" "'" " must be a table");
	  }
	  lua_getfield(L, -1, name);
	  if ((lua_type(L, (-1)) == DefineConstants.LUA_TNIL)) // not found?
	  {
		lua_pushfstring(L, "\n\tno field package.preload['%s']", name);
	  }
	  return 1;
	}


	internal const int sentinel_ = 0;
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sentinel ((void *)&sentinel_)


	internal static int ll_require(lua_State L)
	{
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *name = (luaL_checklstring(L, (1), null));
	  sbyte name = (luaL_checklstring(L, (1), null));
	  int i;
	  lua_settop(L, 1); // _LOADED table will be at index 2
	  lua_getfield(L, DefineConstants.LUA_REGISTRYINDEX, "_LOADED");
	  lua_getfield(L, 2, name);
	  if (lua_toboolean(L, -1))
	  { // is it there?
		if (lua_touserdata(L, -1) == ((object)sentinel_)) // check loops
		{
		  luaL_error(L, "loop or previous error loading module " "'" "%s" "'", name);
		}
		return 1; // package is already loaded
	  }
	  /* else must load it; iterate over available loaders */
	  lua_getfield(L, DefineConstants.LUA_ENVIRONINDEX, "loaders");
	  if (!(lua_type(L, (-1)) == DefineConstants.LUA_TTABLE))
	  {
		luaL_error(L, "'" "package.loaders" "'" " must be a table");
	  }
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "", (sizeof("")/sizeof(sbyte))-1);
	  lua_pushlstring(L, "" "", (("").Length) - 1); // error message accumulator
	  for (i = 1; ; i++)
	  {
		lua_rawgeti(L, -2, i); // get a loader
		if ((lua_type(L, (-1)) == DefineConstants.LUA_TNIL))
		{
		  luaL_error(L, "module " "'" "%s" "'" " not found:%s", name, lua_tolstring(L, (-2), null));
		}
		lua_pushstring(L, name);
		lua_call(L, 1, 1); // call it
		if ((lua_type(L, (-1)) == DefineConstants.LUA_TFUNCTION)) // did it find module?
		{
		  break; // module loaded successfully
		}
		else if (lua_isstring(L, -1)) // loader returned error message?
		{
		  lua_concat(L, 2); // accumulate it
		}
		else
		{
		  lua_settop(L, -(1) - 1);
		}
	  }
	  lua_pushlightuserdata(L, ((object)sentinel_));
	  lua_setfield(L, 2, name); // _LOADED[name] = sentinel
	  lua_pushstring(L, name); // pass name as argument to module
	  lua_call(L, 1, 1); // run loaded module
	  if (!(lua_type(L, (-1)) == DefineConstants.LUA_TNIL)) // non-nil return?
	  {
		lua_setfield(L, 2, name); // _LOADED[name] = returned value
	  }
	  lua_getfield(L, 2, name);
	  if (lua_touserdata(L, -1) == ((object)sentinel_))
	  { // module did not set a value?
		lua_pushboolean(L, 1); // use true as result
		lua_pushvalue(L, -1); // extra copy to be returned
		lua_setfield(L, 2, name); // _LOADED[name] = true
	  }
	  return 1;
	}

	/* }====================================================== */



	/*
	** {======================================================
	** 'module' function
	** =======================================================
	*/


	internal static void setfenv(lua_State L)
	{
	  lua_Debug ar = new lua_Debug();
	  if (lua_getstack(L, 1, ar) == 0 || lua_getinfo(L, "f", ar) == 0 || lua_iscfunction(L, -1)) // get calling function
	  {
		luaL_error(L, "'" "module" "'" " not called from a Lua function");
	  }
	  lua_pushvalue(L, -2);
	  lua_setfenv(L, -2);
	  lua_settop(L, -(1) - 1);
	}


	internal static void dooptions(lua_State L, int n)
	{
	  int i;
	  for (i = 2; i <= n; i++)
	  {
		lua_pushvalue(L, i); // get option (a function)
		lua_pushvalue(L, -2); // module
		lua_call(L, 1, 0);
	  }
	}


	internal static void modinit(lua_State L, string modname)
	{
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  sbyte * dot;
	  lua_pushvalue(L, -1);
	  lua_setfield(L, -2, "_M"); // module._M = module
	  lua_pushstring(L, modname);
	  lua_setfield(L, -2, "_NAME");
	  dot = StringFunctions.StrRChr(modname, '.'); // look for last dot in module name
	  if (dot == null)
	  {
		  dot = modname;
	  }
	  else
	  {
		  dot++;
	  }
	  /* set _PACKAGE as package name (full module name minus last part) */
	  lua_pushlstring(L, modname, dot - modname);
	  lua_setfield(L, -2, "_PACKAGE");
	}


	internal static int ll_module(lua_State L)
	{
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *modname = (luaL_checklstring(L, (1), null));
	  sbyte modname = (luaL_checklstring(L, (1), null));
	  int loaded = lua_gettop(L) + 1; // index of _LOADED table
	  lua_getfield(L, DefineConstants.LUA_REGISTRYINDEX, "_LOADED");
	  lua_getfield(L, loaded, modname); // get _LOADED[modname]
	  if (!(lua_type(L, (-1)) == DefineConstants.LUA_TTABLE))
	  { // not found?
		lua_settop(L, -(1) - 1); // remove previous result
		/* try global variable (and create one if it does not exist) */
		if (luaL_findtable(L, DefineConstants.LUA_GLOBALSINDEX, modname, 1) != null)
		{
		  return luaL_error(L, "name conflict for module " "'" "%s" "'", modname);
		}
		lua_pushvalue(L, -1);
		lua_setfield(L, loaded, modname); // _LOADED[modname] = new table
	  }
	  /* check whether table already has a _NAME field */
	  lua_getfield(L, -1, "_NAME");
	  if (!(lua_type(L, (-1)) == DefineConstants.LUA_TNIL)) // is table an initialized module?
	  {
		lua_settop(L, -(1) - 1);
	  }
	  else
	  { // no; initialize it
		lua_settop(L, -(1) - 1);
		modinit(L, modname);
	  }
	  lua_pushvalue(L, -1);
	  setfenv(L);
	  dooptions(L, loaded - 1);
	  return 0;
	}


	internal static int ll_seeall(lua_State L)
	{
	  luaL_checktype(L, 1, DefineConstants.LUA_TTABLE);
	  if (!lua_getmetatable(L, 1))
	  {
		lua_createtable(L, 0, 1); // create new metatable
		lua_pushvalue(L, -1);
		lua_setmetatable(L, 1);
	  }
	  lua_pushvalue(L, DefineConstants.LUA_GLOBALSINDEX);
	  lua_setfield(L, -2, "__index"); // mt.__index = _G
	  return 0;
	}


	/* }====================================================== */



	/* auxiliary mark (for internal use) */

	internal static void setpath(lua_State L, string fieldname, string envname, string def)
	{
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *path = getenv(envname);
	  sbyte path = getenv(envname);
	  if (path == null) // no environment variable?
	  {
		lua_pushstring(L, def); // use default
	  }
	  else
	  {
		/* replace ";;" by ";AUXMARK;" and then AUXMARK by default path */
		path = luaL_gsub(L, path, DefineConstants.LUA_PATHSEP DefineConstants.LUA_PATHSEP, DefineConstants.LUA_PATHSEP DefineConstants.AUXMARK DefineConstants.LUA_PATHSEP);
		luaL_gsub(L, path, DefineConstants.AUXMARK, def);
		lua_remove(L, -2);
	  }
	  (L)(0)(L);
	  lua_setfield(L, -2, fieldname);
	}


	internal luaL_Reg[] pk_funcs =
	{
		new luaL_Reg("loadlib", ll_loadlib),
		new luaL_Reg("seeall", ll_seeall),
		new luaL_Reg(null, null)
	};


	internal luaL_Reg[] ll_funcs =
	{
		new luaL_Reg("module", ll_module),
		new luaL_Reg("require", ll_require),
		new luaL_Reg(null, null)
	};


	internal lua_CFunction[] loaders = {loader_preload, loader_Lua, loader_C, loader_Croot, null};


	public static int luaopen_package(lua_State L)
	{
	  int i;
	  /* create new type _LOADLIB */
	  luaL_newmetatable(L, "_LOADLIB");
	  lua_pushcclosure(L, (gctm), 0);
	  lua_setfield(L, -2, "__gc");
	  /* create `package' table */
	  luaL_register(L, DefineConstants.LUA_LOADLIBNAME, pk_funcs);
	#if LUA_COMPAT_LOADLIB
	  lua_getfield(L, -1, "loadlib");
	  lua_setfield(L, DefineConstants.LUA_GLOBALSINDEX, "loadlib");
	#endif
	  lua_pushvalue(L, -1);
	  lua_replace(L, DefineConstants.LUA_ENVIRONINDEX);
	  /* create `loaders' table */
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_createtable(L, 0, sizeof(loaders)/sizeof(loaders[0]) - 1);
	  lua_createtable(L, 0, loaders.Length - 1);
	  /* fill it with pre-defined loaders */
	  for (i = 0; loaders[i] != null; i++)
	  {
		lua_pushcclosure(L, (loaders[i]), 0);
		lua_rawseti(L, -2, i + 1);
	  }
	  lua_setfield(L, -2, "loaders"); // put it in field `loaders'
	  setpath(L, "path", DefineConstants.LUA_PATH, LUA_PATH_DEFAULT); // set field `path'
	  setpath(L, "cpath", DefineConstants.LUA_CPATH, LUA_CPATH_DEFAULT); // set field `cpath'
	  /* store config information */
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" DefineConstants.LUA_DIRSEP "\n" DefineConstants.LUA_PATHSEP "\n" DefineConstants.LUA_PATH_MARK "\n" DefineConstants.LUA_EXECDIR "\n" DefineConstants.LUA_IGMARK, (sizeof(DefineConstants.LUA_DIRSEP "\n" DefineConstants.LUA_PATHSEP "\n" DefineConstants.LUA_PATH_MARK "\n" DefineConstants.LUA_EXECDIR "\n" DefineConstants.LUA_IGMARK)/sizeof(sbyte))-1);
	  lua_pushlstring(L, "" DefineConstants.LUA_DIRSEP "\n" DefineConstants.LUA_PATHSEP "\n" DefineConstants.LUA_PATH_MARK "\n" DefineConstants.LUA_EXECDIR "\n" DefineConstants.LUA_IGMARK, ((DefineConstants.LUA_DIRSEP "\n" DefineConstants.LUA_PATHSEP "\n" DefineConstants.LUA_PATH_MARK "\n" DefineConstants.LUA_EXECDIR "\n" DefineConstants.LUA_IGMARK).Length) - 1);
	  lua_setfield(L, -2, "config");
	  /* set field `loaded' */
	  luaL_findtable(L, DefineConstants.LUA_REGISTRYINDEX, "_LOADED", 2);
	  lua_setfield(L, -2, "loaded");
	  /* set field `preload' */
	  lua_createtable(L, 0, 0);
	  lua_setfield(L, -2, "preload");
	  lua_pushvalue(L, DefineConstants.LUA_GLOBALSINDEX);
	  luaL_register(L, null, ll_funcs); // open lib into global table
	  lua_settop(L, -(1) - 1);
	  return 1; // return 'package' table
	}





	/*
	** `module' operation for hashing (size is always a power of 2)
	*/
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lmod(s,size) (check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define twoto(x) (1<<(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizenode(t) (twoto((t)->lsizenode))


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaO_nilobject (&luaO_nilobject_)

//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const lua_TValue luaO_nilobject_;

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ceillog2(x) (luaO_log2((x)-1) + 1)

	public static int luaO_log2(uint x)
	{
	  byte[] log_2 = {0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8};
	  int l = -1;
	  while (x >= 256)
	  {
		  l += 8;
		  x >>= 8;
	  }
	  return l + log_2[x];

	}

/*
** converts an integer to a "floating point byte", represented as
** (eeeeexxx), where the real value is (1xxx) * 2^(eeeee - 1) if
** eeeee != 0 and (xxx) otherwise.
*/
	public static int luaO_int2fb(uint x)
	{
	  int e = 0; // expoent
	  while (x >= 16)
	  {
		x = (x + 1) >> 1;
		e++;
	  }
	  if (x < 8)
	  {
		  return x;
	  }
	  else
	  {
		  return ((e+1) << 3) | (((int)((x))) - 8);
	  }
	}

/* converts back */
	public static int luaO_fb2int(int x)
	{
	  int e = (x >> 3) & 31;
	  if (e == 0)
	  {
		  return x;
	  }
	  else
	  {
		  return ((x & 7) + 8) << (e - 1);
	  }
	}
	public static int luaO_rawequalObj(lua_TValue t1, lua_TValue t2)
	{
	  if (((t1).tt) != ((t2).tt))
	  {
		  return 0;
	  }
	  else
	  {
		  switch (((t1).tt))
		  {
		case DefineConstants.LUA_TNIL:
		  return 1;
		case DefineConstants.LUA_TNUMBER:
		  return ((check_exp((((t1).tt) == DefineConstants.LUA_TNUMBER), (t1).value.n)) == (check_exp((((t2).tt) == DefineConstants.LUA_TNUMBER), (t2).value.n)));
		case DefineConstants.LUA_TBOOLEAN:
		  return check_exp((((t1).tt) == DefineConstants.LUA_TBOOLEAN), (t1).value.b) == check_exp((((t2).tt) == DefineConstants.LUA_TBOOLEAN), (t2).value.b); // boolean true must be 1 !!
		case DefineConstants.LUA_TLIGHTUSERDATA:
		  return check_exp((((t1).tt) == DefineConstants.LUA_TLIGHTUSERDATA), (t1).value.p) == check_exp((((t2).tt) == DefineConstants.LUA_TLIGHTUSERDATA), (t2).value.p);
		default:
		  (c)(0)((((t1).tt) >= DefineConstants.LUA_TSTRING));
		  return check_exp((((t1).tt) >= DefineConstants.LUA_TSTRING), (t1).value.gc) == check_exp((((t2).tt) >= DefineConstants.LUA_TSTRING), (t2).value.gc);
		  }
	  }
	}
	public static int luaO_str2d(string s, ref double result)
	{
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  sbyte * endptr;
	  result = strtod((s), (endptr));
	  if (endptr == s)
	  {
		  return 0; // conversion failed
	  }
	  if (*endptr == (sbyte)'x' || *endptr == (sbyte)'X') // maybe an hexadecimal constant?
	  {
		result = ((double)((strtoul(s, endptr, 16))));
	  }
	  if (*endptr == (sbyte)'\0')
	  {
		  return 1; // most common case
	  }
	  while (isspace(((byte)(*endptr))))
	  {
		  endptr++;
	  }
	  if (*endptr != (sbyte)'\0')
	  {
		  return 0; // invalid trailing characters?
	  }
	  return 1;
	}

/* this function handles only `%d', `%c', %f, %p, and `%s' formats */
	public static string luaO_pushvfstring(lua_State L, string fmt, va_list argp)
	{
	  int n = 1;
	  pushstr(L, "");
	  for (;;)
	  {
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *e = strchr(fmt, '%');
		sbyte e = StringFunctions.StrChr(fmt, '%');
		if (e == null)
		{
			break;
		}
		{
			lua_TValue i_o = (L.top);
			i_o.value.gc = ((union GCObject)(luaS_newlstr(L, fmt, e - fmt)));
			i_o.tt = DefineConstants.LUA_TSTRING;
			(c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	};
	{
			if ((string)L.stack_last - (string)L.top <= (1) * (int)sizeof(lua_TValue) != null)
			{
				luaD_growstack(L, 1);
			}
			else
			{
				(x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
			}
			;
			L.top++;
	};
		switch (*(e+1))
		{
		  case 's':
		  {
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *s = va_arg(argp, sbyte *);
			sbyte s = va_arg(argp, sbyte *);
			if (s == null)
			{
				s = "(null)";
			}
			pushstr(L, s);
			break;
		  }
		  case 'c':
		  {
			string buff = new string(new char[2]);
			buff = StringFunctions.ChangeCharacter(buff, 0, ((sbyte)(va_arg(argp, int))));
			buff = StringFunctions.ChangeCharacter(buff, 1, '\0');
			pushstr(L, buff);
			break;
		  }
		  case 'd':
		  {
			{
				lua_TValue i_o = (L.top);
				i_o.value.n = (((double)((va_arg(argp, int)))));
				i_o.tt = DefineConstants.LUA_TNUMBER;
		};
		{
				if ((string)L.stack_last - (string)L.top <= (1) * (int)sizeof(lua_TValue) != null)
				{
					luaD_growstack(L, 1);
				}
				else
				{
					(x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
				}
				;
				L.top++;
		};
			break;
		  }
		  case 'f':
		  {
			{
				lua_TValue i_o = (L.top);
				i_o.value.n = (((double)((va_arg(argp, double)))));
				i_o.tt = DefineConstants.LUA_TNUMBER;
		};
		{
				if ((string)L.stack_last - (string)L.top <= (1) * (int)sizeof(lua_TValue) != null)
				{
					luaD_growstack(L, 1);
				}
				else
				{
					(x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
				}
				;
				L.top++;
		};
			break;
		  }
		  case 'p':
		  {
			string buff = new string(new char[4 * sizeof(object) + 8]); // should be enough space for a `%p'
//C++ TO C# CONVERTER TODO TASK: The following line has a C format specifier which cannot be directly translated to C#:
//ORIGINAL LINE: sprintf(buff, "%p", va_arg(argp, object*));
			buff = string.Format("%p", va_arg(argp, object));
			pushstr(L, buff);
			break;
		  }
		  case '%':
		  {
			pushstr(L, "%");
			break;
		  }
		  default:
		  {
			string buff = new string(new char[3]);
			buff = StringFunctions.ChangeCharacter(buff, 0, '%');
			buff = StringFunctions.ChangeCharacter(buff, 1, *(e+1));
			buff = StringFunctions.ChangeCharacter(buff, 2, '\0');
			pushstr(L, buff);
			break;
		  }
		}
		n += 2;
		fmt = e+2;
	  }
	  pushstr(L, fmt);
	  luaV_concat(L, n + 1, ((int)((L.top - L.@base))) - 1);
	  L.top -= n;
	  return ((string)((check_exp((((L.top - 1).tt) == DefineConstants.LUA_TSTRING), (L.top - 1).value.gc.ts)) + 1));
	}
	public static string luaO_pushfstring(lua_State L, string fmt, params object[] LegacyParamArray)
	{
	  string msg;
	//  va_list argp;
  int ParamCount = -1;
	//  va_start(argp, fmt);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: msg = luaO_pushvfstring(L, fmt, argp);
	  msg = luaO_pushvfstring(L, fmt, new va_list(argp));
	//  va_end(argp);
	  return msg;
	}
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'source', so pointers on this parameter are left unchanged:
	public static void luaO_chunkid(ref string @out, sbyte * source, size_t bufflen)
	{
	  if (*source == (sbyte)'=')
	  {
		@out = source.Substring(1, bufflen); // remove first char
		@out[bufflen - 1] = '\0'; // ensures null termination
	  }
	  else
	  { // out = "source", or "...source"
		if (*source == (sbyte)'@')
		{
		  size_t l = new size_t();
		  source = source.Substring(1); // skip the `@'
		  bufflen -= sizeof(string);
		  l = source.Length;
		  @out = "";
		  if (l > bufflen)
		  {
			source += (l - bufflen); // get last part of file name
			@out += "...";
		  }
		  @out += source;
		}
		else
		{ // out = [string "string"]
		  size_t len = strcspn(source, "\n\r"); // stop at first newline
		  bufflen -= sizeof(string);
		  if (len > bufflen)
		  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: len = bufflen;
			  len.CopyFrom(bufflen);
		  }
		  @out = "[string \"";
		  if (source[len] != '\0')
		  { // must truncate?
			strncat(@out, source, len);
			@out += "...";
		  }
		  else
		  {
			@out += source;
		  }
		  @out += "\"]";
		}
	  }
	}




	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gfasttm(g,et,e) ((et) == NULL ? NULL : ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define fasttm(l,et,e) gfasttm(G(l), et, e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocv(L,b,on,n,e) ((cast(size_t, (n)+1) <= MAX_SIZET/(e)) ? luaM_realloc_(L, (b), (on)*(e), (n)*(e)) : luaM_toobig(L))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freemem(L, b, s) luaM_realloc_(L, (b), (s), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_free(L, b) luaM_realloc_(L, (b), sizeof(*(b)), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freearray(L, b, n, t) luaM_reallocv(L, (b), n, 0, sizeof(t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_malloc(L,t) luaM_realloc_(L, NULL, 0, (t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_new(L,t) cast(t *, luaM_malloc(L, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_newvector(L,n,t) cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_growvector(L,v,nelems,size,t,limit,e) if ((nelems)+1 > (size)) ((v)=cast(t *, luaM_growaux_(L,v,&(size),sizeof(t),limit,e)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocvector(L, v,oldn,n,t) ((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define char2int(c) cast(int, cast(unsigned char, (c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define zgetc(z) (((z)->n--)>0 ? char2int(*(z)->p++) : luaZ_fill(z))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_buffer(buff) ((buff)->buffer)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_sizebuffer(buff) ((buff)->buffsize)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_bufflen(buff) ((buff)->n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resetbuffer(buff) ((buff)->n = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resizebuffer(L, buff, size) (luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), (buff)->buffsize = size)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_freebuffer(L, buff) luaZ_resizebuffer(L, buff, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gt(L) (&L->l_gt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define registry(L) (&G(L)->l_registry)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BASIC_STACK_SIZE (2*LUA_MINSTACK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define curr_func(L) (clvalue(L->ci->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ci_func(ci) (clvalue((ci)->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define f_isLua(ci) (!ci_func(ci)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLua(ci) (ttisfunction((ci)->func) && f_isLua(ci))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define G(L) (L->l_G)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2ts(o) check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2ts(o) (&rawgco2ts(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2u(o) check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2u(o) (&rawgco2u(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2cl(o) check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2h(o) check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2p(o) check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2uv(o) check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ngcotouv(o) check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2th(o) check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define obj2gco(v) (cast(GCObject *, (v)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaD_checkstack(L,n) if ((char *)L->stack_last - (char *)L->top <= (n)*(int)sizeof(TValue)) luaD_growstack(L, n); else condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define incr_top(L) {luaD_checkstack(L,1); L->top++;}
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define savestack(L,p) ((char *)(p) - (char *)L->stack)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define restorestack(L,n) ((TValue *)((char *)L->stack + (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define saveci(L,p) ((char *)(p) - (char *)L->base_ci)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define restoreci(L,n) ((CallInfo *)((char *)L->base_ci + (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbits(x,m) ((x) &= cast(lu_byte, ~(m)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbits(x,m) ((x) |= (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbits(x,m) ((x) & (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bitmask(b) (1<<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bit2mask(b1,b2) (bitmask(b1) | bitmask(b2))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_setbit(x,b) setbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbit(x,b) resetbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbit(x,b) testbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define set2bits(x,b1,b2) setbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define reset2bits(x,b1,b2) resetbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define test2bits(x,b1,b2) testbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define WHITEBITS bit2mask(WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iswhite(x) test2bits((x)->gch.marked, WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isblack(x) testbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isgray(x) (!isblack(x) && !iswhite(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define otherwhite(g) (g->currentwhite ^ WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isdead(g,v) ((v)->gch.marked & otherwhite(g) & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define changewhite(x) ((x)->gch.marked ^= WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gray2black(x) l_setbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define valiswhite(x) (iscollectable(x) && iswhite(gcvalue(x)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_white(g) cast(lu_byte, (g)->currentwhite & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_checkGC(L) { condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1)); if (G(L)->totalbytes >= G(L)->GCthreshold) luaC_step(L); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),gcvalue(v)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barriert(L,t,v) { if (valiswhite(v) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarrier(L,p,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),obj2gco(o)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarriert(L,t,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizestring(s) (sizeof(union TString)+((s)->len+1)*sizeof(char))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeudata(u) (sizeof(union Udata)+(u)->len)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_new(L, s) (luaS_newlstr(L, s, strlen(s)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_newliteral(L, s) (luaS_newlstr(L, "" s, (sizeof(s)/sizeof(char))-1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_fix(s) l_setbit((s)->tsv.marked, FIXEDBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define tostring(L,o) ((ttype(o) == LUA_TSTRING) || (luaV_tostring(L, o)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define tonumber(o,n) (ttype(o) == LUA_TNUMBER || (((o) = luaV_tonumber(o,n)) != NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define equalobj(L,o1,o2) (ttype(o1) == ttype(o2) && luaV_equalval(L, o1, o2))



	public static readonly lua_TValue luaO_nilobject_ = new lua_TValue({null}, DefineConstants.LUA_TNIL);



	internal static void pushstr(lua_State L, string str)
	{
	  {
		  lua_TValue i_o = (L.top);
		  i_o.value.gc = ((union GCObject)((luaS_newlstr(L, str, str.Length))));
		  i_o.tt = DefineConstants.LUA_TSTRING;
		  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
  };
  {
		  if ((string)L.stack_last - (string)L.top <= (1) * (int)sizeof(lua_TValue) != null)
		  {
			  luaD_growstack(L, 1);
		  }
		  else
		  {
			  (x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
		  }
		  ;
		  L.top++;
  };
	}


	extern const byte luaP_opmodes[(((int)(OP_VARARG)) + 1)];

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getOpMode(m) (cast(enum OpMode, luaP_opmodes[m] & 3))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getBMode(m) (cast(enum OpArgMask, (luaP_opmodes[m] >> 4) & 3))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getCMode(m) (cast(enum OpArgMask, (luaP_opmodes[m] >> 2) & 3))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testAMode(m) (luaP_opmodes[m] & (1 << 6))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testTMode(m) (luaP_opmodes[m] & (1 << 7))


//C++ TO C# CONVERTER TODO TASK: The following statement was not recognized, possibly due to an unrecognized macro:
	extern const sbyte * const luaP_opnames[(((int)(OP_VARARG)) + 1) + 1]; // opcode names


	/* number of list items to accumulate before a SETLIST instruction */





	/* ORDER OP */

//C++ TO C# CONVERTER TODO TASK: The following statement was not recognized, possibly due to an unrecognized macro:
	const sbyte * const luaP_opnames[(((int)(OP_VARARG)) + 1) + 1] = {"MOVE", "LOADK", "LOADBOOL", "LOADNIL", "GETUPVAL", "GETGLOBAL", "GETTABLE", "SETGLOBAL", "SETUPVAL", "SETTABLE", "NEWTABLE", "SELF", "ADD", "SUB", "MUL", "DIV", "MOD", "POW", "UNM", "NOT", "LEN", "CONCAT", "JMP", "EQ", "LT", "LE", "TEST", "TESTSET", "CALL", "TAILCALL", "RETURN", "FORLOOP", "FORPREP", "TFORLOOP", "SETLIST", "CLOSE", "CLOSURE", "VARARG", null};


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define opmode(t,a,b,c,m) (((t)<<7) | ((a)<<6) | ((b)<<4) | ((c)<<2) | (m))

	const byte luaP_opmodes[(((int)(OP_VARARG)) + 1)] = {(((0) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgN) << 2) | (iABC)),(((0) << 7) | ((1) << 6) | ((OpArgK) << 4) | ((OpArgN) << 2) | (iABx)),(((0) << 7) | ((1) << 6) | ((OpArgU) << 4) | ((OpArgU) << 2) | (iABC)),(((0) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgN) << 2) | (iABC)),(((0) << 7) | ((1) << 6) | ((OpArgU) << 4) | ((OpArgN) << 2) | (iABC)),(((0) << 7) | ((1) << 6) | ((OpArgK) << 4) | ((OpArgN) << 2) | (iABx)),(((0) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgK) << 2) | (iABC)),(((0) << 7) | ((0) << 6) | ((OpArgK) << 4) | ((OpArgN) << 2) | (iABx)),(((0) << 7) | ((0) << 6) | ((OpArgU) << 4) | ((OpArgN) << 2) | (iABC)),(((0) << 7) | ((0) << 6) | ((OpArgK) << 4) | ((OpArgK) << 2) | (iABC)),(((0) << 7) | ((1) << 6) | ((OpArgU) << 4) | ((OpArgU) << 2) | (iABC)),(((0) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgK) << 2) | (iABC)),(((0) << 7) | ((1) << 6) | ((OpArgK) << 4) | ((OpArgK) << 2) | (iABC)),(((0) << 7) | ((1) << 6) | ((OpArgK) << 4) | ((OpArgK) << 2) | (iABC)),(((0) << 7) | ((1) << 6) | ((OpArgK) << 4) | ((OpArgK) << 2) | (iABC)),(((0) << 7) | ((1) << 6) | ((OpArgK) << 4) | ((OpArgK) << 2) | (iABC)),(((0) << 7) | ((1) << 6) | ((OpArgK) << 4) | ((OpArgK) << 2) | (iABC)),(((0) << 7) | ((1) << 6) | ((OpArgK) << 4) | ((OpArgK) << 2) | (iABC)),(((0) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgN) << 2) | (iABC)),(((0) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgN) << 2) | (iABC)),(((0) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgN) << 2) | (iABC)),(((0) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgR) << 2) | (iABC)),(((0) << 7) | ((0) << 6) | ((OpArgR) << 4) | ((OpArgN) << 2) | (iAsBx)),(((1) << 7) | ((0) << 6) | ((OpArgK) << 4) | ((OpArgK) << 2) | (iABC)),(((1) << 7) | ((0) << 6) | ((OpArgK) << 4) | ((OpArgK) << 2) | (iABC)),(((1) << 7) | ((0) << 6) | ((OpArgK) << 4) | ((OpArgK) << 2) | (iABC)),(((1) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgU) << 2) | (iABC)),(((1) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgU) << 2) | (iABC)),(((0) << 7) | ((1) << 6) | ((OpArgU) << 4) | ((OpArgU) << 2) | (iABC)),(((0) << 7) | ((1) << 6) | ((OpArgU) << 4) | ((OpArgU) << 2) | (iABC)),(((0) << 7) | ((0) << 6) | ((OpArgU) << 4) | ((OpArgN) << 2) | (iABC)),(((0) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgN) << 2) | (iAsBx)),(((0) << 7) | ((1) << 6) | ((OpArgR) << 4) | ((OpArgN) << 2) | (iAsBx)),(((1) << 7) | ((0) << 6) | ((OpArgN) << 4) | ((OpArgU) << 2) | (iABC)),(((0) << 7) | ((0) << 6) | ((OpArgU) << 4) | ((OpArgU) << 2) | (iABC)),(((0) << 7) | ((0) << 6) | ((OpArgN) << 4) | ((OpArgN) << 2) | (iABC)),(((0) << 7) | ((1) << 6) | ((OpArgU) << 4) | ((OpArgN) << 2) | (iABx)),(((0) << 7) | ((1) << 6) | ((OpArgU) << 4) | ((OpArgN) << 2) | (iABC))};


	/*
	** $Id: loslib.c,v 1.19.1.3 2008/01/18 16:38:18 roberto Exp $
	** Standard Operating System library
	** See Copyright Notice in lua.h
	*/




//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DYLD
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_VARARG
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_MOD
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_LSTR
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_OPENLIB
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DLOPEN
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DLL
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getn(L,i) ((int)lua_objlen(L, i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_setn(L,i,j) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaI_openlib luaL_openlib
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_ERRFILE (LUA_ERRERR+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_argcheck(L, cond,numarg,extramsg) ((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkstring(L,n) (luaL_checklstring(L, (n), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optstring(L,n,d) (luaL_optlstring(L, (n), (d), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkint(L,n) ((int)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optint(L,n,d) ((int)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checklong(L,n) ((long)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optlong(L,n,d) ((long)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_typename(L,i) lua_typename(L, lua_type(L,(i)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dofile(L, fn) (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dostring(L, s) (luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getmetatable(L,n) (lua_getfield(L, LUA_REGISTRYINDEX, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_opt(L,f,n,d) (lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addchar(B,c) ((void)((B)->p < ((B)->buffer+LUAL_BUFFERSIZE) || luaL_prepbuffer(B)), (*(B)->p++ = (char)(c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_putchar(B,c) luaL_addchar(B,c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addsize(B,n) ((B)->p += (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_ref(L,lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : (lua_pushstring(L, "unlocked references are obsolete"), lua_error(L), 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unref(L,ref) luaL_unref(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getref(L,ref) lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_reg luaL_Reg
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(x) ((void)0)


	internal static int os_pushresult(lua_State L, int i, string filename)
	{
	  int en = errno; // calls to Lua API may change this value
	  if (i != 0)
	  {
		lua_pushboolean(L, 1);
		return 1;
	  }
	  else
	  {
		lua_pushnil(L);
		lua_pushfstring(L, "%s: %s", filename, strerror(en));
		lua_pushinteger(L, en);
		return 3;
	  }
	}


	internal static int os_execute(lua_State L)
	{
	  lua_pushinteger(L, system((luaL_optlstring(L, (1), (null), null))));
	  return 1;
	}


	internal static int os_remove(lua_State L)
	{
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *filename = (luaL_checklstring(L, (1), null));
	  sbyte filename = (luaL_checklstring(L, (1), null));
	  return os_pushresult(L, remove(filename) == 0, filename);
	}


	internal static int os_rename(lua_State L)
	{
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *fromname = (luaL_checklstring(L, (1), null));
	  sbyte fromname = (luaL_checklstring(L, (1), null));
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *toname = (luaL_checklstring(L, (2), null));
	  sbyte toname = (luaL_checklstring(L, (2), null));
	  return os_pushresult(L, rename(fromname, toname) == 0, fromname);
	}


	internal static int os_tmpname(lua_State L)
	{
	  string buff = new string(new char[L_tmpnam]);
	  int err;
	  lua_tmpnam(buff, err);
	  if (err != 0)
	  {
		return luaL_error(L, "unable to generate a unique filename");
	  }
	  lua_pushstring(L, buff);
	  return 1;
	}


	internal static int os_getenv(lua_State L)
	{
	  lua_pushstring(L, getenv((luaL_checklstring(L, (1), null)))); // if NULL push nil
	  return 1;
	}


	internal static int os_clock(lua_State L)
	{
	  lua_pushnumber(L, ((double)clock()) / (double)CLOCKS_PER_SEC);
	  return 1;
	}


	/*
	** {======================================================
	** Time/Date operations
	** { year=%Y, month=%m, day=%d, hour=%H, min=%M, sec=%S,
	**   wday=%w+1, yday=%j, isdst=? }
	** =======================================================
	*/

	internal static void setfield(lua_State L, string key, int value)
	{
	  lua_pushinteger(L, value);
	  lua_setfield(L, -2, key);
	}

	internal static void setboolfield(lua_State L, string key, int value)
	{
	  if (value < 0) // undefined?
	  {
		return; // does not set field
	  }
	  lua_pushboolean(L, value);
	  lua_setfield(L, -2, key);
	}

	internal static int getboolfield(lua_State L, string key)
	{
	  int res;
	  lua_getfield(L, -1, key);
	  res = (lua_type(L, (-1)) == DefineConstants.LUA_TNIL) ? -1 : lua_toboolean(L, -1);
	  lua_settop(L, -(1) - 1);
	  return res;
	}


	internal static int getfield(lua_State L, string key, int d)
	{
	  int res;
	  lua_getfield(L, -1, key);
	  if (lua_isnumber(L, -1))
	  {
		res = (int)lua_tointeger(L, -1);
	  }
	  else
	  {
		if (d < 0)
		{
		  return luaL_error(L, "field " "'" "%s" "'" " missing in date table", key);
		}
		res = d;
	  }
	  lua_settop(L, -(1) - 1);
	  return res;
	}


	internal static int os_date(lua_State L)
	{
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  sbyte * s = (luaL_optlstring(L, (1), ("%c"), null));
	  time_t t = ((lua_type(L, ((2))) <= 0) ? (time(null)) : (time_t)luaL_checknumber(L,(2)));
	  tm stm;
	  if (*s == (sbyte)'!')
	  { // UTC?
		stm = gmtime(t);
		s++; // skip `!'
	  }
	  else
	  {
		stm = localtime(t);
	  }
	  if (stm == null) // invalid date?
	  {
		lua_pushnil(L);
	  }
	  else if (string.Compare(s, "*t") == 0)
	  {
		lua_createtable(L, 0, 9); // 9 = number of fields
		setfield(L, "sec", stm.tm_sec);
		setfield(L, "min", stm.tm_min);
		setfield(L, "hour", stm.tm_hour);
		setfield(L, "day", stm.tm_mday);
		setfield(L, "month", stm.tm_mon + 1);
		setfield(L, "year", stm.tm_year + 1900);
		setfield(L, "wday", stm.tm_wday + 1);
		setfield(L, "yday", stm.tm_yday + 1);
		setboolfield(L, "isdst", stm.tm_isdst);
	  }
	  else
	  {
		string cc = new string(new char[3]);
		luaL_Buffer b = new luaL_Buffer();
		cc = StringFunctions.ChangeCharacter(cc, 0, '%');
		cc = StringFunctions.ChangeCharacter(cc, 2, '\0');
		luaL_buffinit(L, b);
		for (; * s; s++)
		{
		  if (*s != (sbyte)'%' || *(s + 1) == '\0') // no conversion specifier?
		  {
			(((b).p < ((b).buffer + BUFSIZ) || luaL_prepbuffer(b)), (*(b).p ++= (sbyte)(*s)));
		  }
		  else
		  {
			size_t reslen = new size_t();
			string buff = new string(new char[200]); // should be big enough for any conversion result
			cc = StringFunctions.ChangeCharacter(cc, 1, *(++s));
			reslen = strftime(buff, sizeof(sbyte), cc, stm);
			luaL_addlstring(b, buff, reslen);
		  }
		}
		luaL_pushresult(b);
	  }
	  return 1;
	}


	internal static int os_time(lua_State L)
	{
	  time_t t = new time_t();
	  if ((lua_type(L, (1)) <= 0)) // called without args?
	  {
		t = time(null); // get current time
	  }
	  else
	  {
		tm ts = new tm();
		luaL_checktype(L, 1, DefineConstants.LUA_TTABLE);
		lua_settop(L, 1); // make sure table is at the top
		ts.tm_sec = getfield(L, "sec", 0);
		ts.tm_min = getfield(L, "min", 0);
		ts.tm_hour = getfield(L, "hour", 12);
		ts.tm_mday = getfield(L, "day", -1);
		ts.tm_mon = getfield(L, "month", -1) - 1;
		ts.tm_year = getfield(L, "year", -1) - 1900;
		ts.tm_isdst = getboolfield(L, "isdst");
		t = mktime(ts);
	  }
	  if (t == (time_t)(-1))
	  {
		lua_pushnil(L);
	  }
	  else
	  {
		lua_pushnumber(L, (double)t);
	  }
	  return 1;
	}


	internal static int os_difftime(lua_State L)
	{
	  lua_pushnumber(L, difftime((time_t)(luaL_checknumber(L, 1)), (time_t)(luaL_optnumber(L, 2, 0))));
	  return 1;
	}

	/* }====================================================== */


	internal static int os_setlocale(lua_State L)
	{
	  int[] cat = {LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME};
	  string[] catnames = {"all", "collate", "ctype", "monetary", "numeric", "time", null};
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *l = (luaL_optlstring(L, (1), (null), null));
	  sbyte l = (luaL_optlstring(L, (1), (null), null));
	  int op = luaL_checkoption(L, 2, "all", catnames);
	  lua_pushstring(L, setlocale(cat[op], l));
	  return 1;
	}


	internal static int os_exit(lua_State L)
	{
	  Environment.Exit(((int)luaL_optinteger(L, (1), (EXIT_SUCCESS))));
	}

	internal luaL_Reg[] syslib =
	{
		new luaL_Reg("clock", os_clock),
		new luaL_Reg("date", os_date),
		new luaL_Reg("difftime", os_difftime),
		new luaL_Reg("execute", os_execute),
		new luaL_Reg("exit", os_exit),
		new luaL_Reg("getenv", os_getenv),
		new luaL_Reg("remove", os_remove),
		new luaL_Reg("rename", os_rename),
		new luaL_Reg("setlocale", os_setlocale),
		new luaL_Reg("time", os_time),
		new luaL_Reg("tmpname", os_tmpname),
		new luaL_Reg(null, null)
	};

	/* }====================================================== */



	public static int luaopen_os(lua_State L)
	{
	  luaL_register(L, DefineConstants.LUA_OSLIBNAME, syslib);
	  return 1;
	}




	public static Proto luaY_parser(lua_State L, Zio z, Mbuffer buff, string name)
	{
	  LexState lexstate = new LexState();
	  FuncState funcstate = new FuncState();
	  lexstate.buff = buff;
	  luaX_setinput(L, lexstate, z, (luaS_newlstr(L, name, name.Length)));
	  open_func(lexstate, funcstate);
	  funcstate.f.is_vararg = DefineConstants.VARARG_ISVARARG; // main func. is always vararg
	  luaX_next(lexstate); // read first token
	  chunk(lexstate);
	  check(lexstate, RESERVED.TK_EOS);
	  close_func(lexstate);
	  (c)(0)(funcstate.prev == null);
	  (c)(0)(funcstate.f.nups == 0);
	  (c)(0)(lexstate.fs == null);
	  return funcstate.f;
	}



	/*
	** prototypes for recursive non-terminal functions
	*/
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'ls', so pointers on this parameter are left unchanged:
	internal static void chunk(LexState * ls)
	{
	  /* chunk -> { stat [`;'] } */
	  int islast = 0;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: enterlevel(ls);
	  enterlevel(new LexState(ls));
	  while (islast == 0 && block_follow(ls.t.token) == 0)
	  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: islast = statement(ls);
		islast = statement(new LexState(ls));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: testnext(ls, ';');
		testnext(new LexState(ls), ';');
		(c)(0)(ls.fs.f.maxstacksize >= ls.fs.freereg != 0 && ls.fs.freereg >= ls.fs.nactvar);
		ls.fs.freereg = ls.fs.nactvar; // free registers
	  }
	  ((ls).L.nCcalls--);
	}
	internal static void expr(LexState ls, expdesc v)
	{
	  subexpr(ls, v, 0);
	}


	internal static void anchor_token(LexState ls)
	{
	  if (ls.t.token == (int)RESERVED.TK_NAME || ls.t.token == (int)RESERVED.TK_STRING)
	  {
		TString ts = ls.t.seminfo.ts;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaX_newstring(ls, ((const sbyte *)((ts) + 1)), ts->tsv.len);
		luaX_newstring(ls, ((string)((ts) + 1)), new size_t(ts.tsv.len));
	  }
	}


	internal static void error_expected(LexState ls, int token)
	{
	  luaX_syntaxerror(ls, luaO_pushfstring(ls.L, "'" "%s" "'" " expected", luaX_token2str(ls, token)));
	}


	internal static void errorlimit(FuncState fs, int limit, string what)
	{
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *msg = (fs->f->linedefined == 0) ? luaO_pushfstring(fs->L, "main function has more than %d %s", limit, what) : luaO_pushfstring(fs->L, "function at line %d has more than %d %s", fs->f->linedefined, limit, what);
	  sbyte msg = (fs.f.linedefined == 0) ? luaO_pushfstring(fs.L, "main function has more than %d %s", limit, what) : luaO_pushfstring(fs.L, "function at line %d has more than %d %s", fs.f.linedefined, limit, what);
	  luaX_lexerror(fs.ls, msg, 0);
	}


	internal static int testnext(LexState ls, int c)
	{
	  if (ls.t.token == c)
	  {
		luaX_next(ls);
		return 1;
	  }
	  else
	  {
		  return 0;
	  }
	}


	internal static void check(LexState ls, int c)
	{
	  if (ls.t.token != c)
	  {
		error_expected(ls, c);
	  }
	}

	internal static void checknext(LexState ls, int c)
	{
	  check(ls, c);
	  luaX_next(ls);
	}


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_condition(ls,c,msg) { if (!(c)) luaX_syntaxerror(ls, msg); }



	internal static void check_match(LexState ls, int what, int who, int where)
	{
	  if (testnext(ls, what) == 0)
	  {
		if (where == ls.linenumber)
		{
		  error_expected(ls, what);
		}
		else
		{
		  luaX_syntaxerror(ls, luaO_pushfstring(ls.L, "'" "%s" "'" " expected (to close " "'" "%s" "'" " at line %d)", luaX_token2str(ls, what), luaX_token2str(ls, who), where));
		}
	  }
	}


	internal static TString str_checkname(LexState ls)
	{
	  TString ts;
	  check(ls, RESERVED.TK_NAME);
	  ts = ls.t.seminfo.ts;
	  luaX_next(ls);
	  return ts;
	}


	internal static void init_exp(expdesc e, expkind k, int i)
	{
	  e.f = e.t = DefineConstants.NO_JUMP;
	  e.k = k;
	  e.u.s.info = i;
	}


	internal static void codestring(LexState ls, expdesc e, TString s)
	{
	  init_exp(e, expkind.VK, luaK_stringK(ls.fs, s));
	}


	internal static void checkname(LexState ls, expdesc e)
	{
	  codestring(ls, e, str_checkname(ls));
	}


	internal static int registerlocalvar(LexState ls, TString varname)
	{
	  FuncState fs = ls.fs;
	  Proto f = fs.f;
	  int oldsize = f.sizelocvars;
	  if ((fs.nlocvars) + 1 > (f.sizelocvars))
	  {
		  ((f.locvars) = ((LocVar)(luaM_growaux_(ls.L, f.locvars, ref (f.sizelocvars), sizeof(LocVar), SHRT_MAX, "too many local variables"))));
	  }
	  while (oldsize < f.sizelocvars)
	  {
		  f.locvars[oldsize++].varname = null;
	  }
	  f.locvars[fs.nlocvars].varname = varname;
	  {
		  if (((((((union GCObject)((varname))))).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))) && ((((((union GCObject)((f))))).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))))
		  {
			  luaC_barrierf(ls.L, (((union GCObject)((f)))), (((union GCObject)((varname)))));
		  }
	  };
	  return fs.nlocvars++;
	}


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define new_localvarliteral(ls,v,n) new_localvar(ls, luaX_newstring(ls, "" v, (sizeof(v)/sizeof(char))-1), n)


	internal static void new_localvar(LexState ls, TString name, int n)
	{
	  FuncState fs = ls.fs;
	  if ((fs.nactvar + n + 1) > (DefineConstants.LUAI_MAXVARS))
	  {
		  errorlimit(fs, DefineConstants.LUAI_MAXVARS, "local variables");
	  }
	  fs.actvar[fs.nactvar + n] = ((ushort)(registerlocalvar(ls, name)));
	}


	internal static void adjustlocalvars(LexState ls, int nvars)
	{
	  FuncState fs = ls.fs;
	  fs.nactvar = ((byte)((fs.nactvar + nvars)));
	  for (; nvars != 0; nvars--)
	  {
		((fs).f.locvars[(fs).actvar[fs.nactvar - nvars]]).startpc = fs.pc;
	  }
	}


	internal static void removevars(LexState ls, int tolevel)
	{
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: FuncState *fs = ls->fs;
	  FuncState * fs = new FuncState(ls.fs);
	  while (fs.nactvar > tolevel)
	  {
		((fs).f.locvars[(fs).actvar[--fs.nactvar]]).endpc = fs.pc;
	  }
	}


	internal static int indexupvalue(FuncState fs, TString name, expdesc v)
	{
	  int i;
	  Proto f = fs.f;
	  int oldsize = f.sizeupvalues;
	  for (i = 0; i < f.nups; i++)
	  {
		if (fs.upvalues[i].k == (int)v.k && fs.upvalues[i].info == v.u.s.info)
		{
		  (c)(0)(f.upvalues[i] == name);
		  return i;
		}
	  }
	  /* new one */
	  if ((f.nups + 1) > (DefineConstants.LUAI_MAXUPVALUES))
	  {
		  errorlimit(fs, DefineConstants.LUAI_MAXUPVALUES, "upvalues");
	  }
	  if ((f.nups) + 1 > (f.sizeupvalues))
	  {
		  ((f.upvalues) = ((TString)(luaM_growaux_(fs.L, f.upvalues, ref (f.sizeupvalues), sizeof(TString), (INT_MAX - 2), ""))));
	  }
	  while (oldsize < f.sizeupvalues)
	  {
		  f.upvalues[oldsize++] = null;
	  }
	  f.upvalues[f.nups] = name;
	  {
		  if (((((((union GCObject)((name))))).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))) && ((((((union GCObject)((f))))).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))))
		  {
			  luaC_barrierf(fs.L, (((union GCObject)((f)))), (((union GCObject)((name)))));
		  }
	  };
	  (c)(0)(v.k == expkind.VLOCAL || v.k == expkind.VUPVAL);
	  fs.upvalues[f.nups].k = ((byte)((v.k)));
	  fs.upvalues[f.nups].info = ((byte)((v.u.s.info)));
	  return f.nups++;
	}


	internal static int searchvar(FuncState fs, TString n)
	{
	  int i;
	  for (i = fs.nactvar - 1; i >= 0; i--)
	  {
		if (n == ((fs).f.locvars[(fs).actvar[i]]).varname)
		{
		  return i;
		}
	  }
	  return -1; // not found
	}


	internal static void markupval(FuncState fs, int level)
	{
	  BlockCnt bl = fs.bl;
	  while (bl != null && bl.nactvar > level)
	  {
		  bl = bl.previous;
	  }
	  if (bl != null)
	  {
		  bl.upval = 1;
	  }
	}


	internal static int singlevaraux(FuncState fs, TString n, expdesc @var, int @base)
	{
	  if (fs == null)
	  { // no more levels?
		init_exp(@var, expkind.VGLOBAL, ((1 << DefineConstants.SIZE_A) - 1)); // default is global variable
		return expkind.VGLOBAL;
	  }
	  else
	  {
		int v = searchvar(fs, n); // look up at current level
		if (v >= 0)
		{
		  init_exp(@var, expkind.VLOCAL, v);
		  if (@base == 0)
		  {
			markupval(fs, v); // local will be used as an upval
		  }
		  return expkind.VLOCAL;
		}
		else
		{ // not found at current level; try upper one
		  if (singlevaraux(fs.prev, n, @var, 0) == (int)expkind.VGLOBAL)
		  {
			return expkind.VGLOBAL;
		  }
		  @var.u.s.info = indexupvalue(fs, n, @var); // else was LOCAL or UPVAL
		  @var.k = expkind.VUPVAL; // upvalue in this level
		  return expkind.VUPVAL;
		}
	  }
	}


	internal static void singlevar(LexState ls, expdesc @var)
	{
	  TString varname = str_checkname(ls);
	  FuncState fs = ls.fs;
	  if (singlevaraux(fs, varname, @var, 1) == (int)expkind.VGLOBAL)
	  {
		@var.u.s.info = luaK_stringK(fs, varname); // info points to global name
	  }
	}


	internal static void adjust_assign(LexState ls, int nvars, int nexps, expdesc e)
	{
	  FuncState fs = ls.fs;
	  int extra = nvars - nexps;
	  if (((e.k) == expkind.VCALL || (e.k) == expkind.VVARARG))
	  {
		extra++; // includes call itself
		if (extra < 0)
		{
			extra = 0;
		}
		luaK_setreturns(fs, e, extra); // last exp. provides the difference
		if (extra > 1)
		{
			luaK_reserveregs(fs, extra - 1);
		}
	  }
	  else
	  {
		if (e.k != expkind.VVOID)
		{
			luaK_exp2nextreg(fs, e); // close last expression
		}
		if (extra > 0)
		{
		  int reg = fs.freereg;
		  luaK_reserveregs(fs, extra);
		  luaK_nil(fs, reg, extra);
		}
	  }
	}


//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'ls', so pointers on this parameter are left unchanged:
	internal static void enterlevel(LexState * ls)
	{
	  if (++ls.L.nCcalls > DefineConstants.LUAI_MAXCCALLS)
	  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaX_lexerror(ls, "chunk has too many syntax levels", 0);
		luaX_lexerror(new LexState(ls), "chunk has too many syntax levels", 0);
	  }
	}


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define leavelevel(ls) ((ls)->L->nCcalls--)


	internal static void enterblock(FuncState fs, BlockCnt bl, byte isbreakable)
	{
	  bl.breaklist = DefineConstants.NO_JUMP;
	  bl.isbreakable = isbreakable;
	  bl.nactvar = fs.nactvar;
	  bl.upval = 0;
	  bl.previous = fs.bl;
	  fs.bl = bl;
	  (c)(0)(fs.freereg == fs.nactvar);
	}


	internal static void leaveblock(FuncState fs)
	{
	  BlockCnt bl = fs.bl;
	  fs.bl = bl.previous;
	  removevars(fs.ls, bl.nactvar);
	  if (bl.upval != 0)
	  {
		luaK_codeABC(fs, OpCode.OP_CLOSE, bl.nactvar, 0, 0);
	  }
	  /* a block either controls scope or breaks (never both) */
	  (c)(0)(bl.isbreakable == 0 || bl.upval == 0);
	  (c)(0)(bl.nactvar == fs.nactvar);
	  fs.freereg = fs.nactvar; // free registers
	  luaK_patchtohere(fs, bl.breaklist);
	}


	internal static void pushclosure(LexState ls, FuncState func, expdesc v)
	{
	  FuncState fs = ls.fs;
	  Proto f = fs.f;
	  int oldsize = f.sizep;
	  int i;
	  if ((fs.np) + 1 > (f.sizep))
	  {
		  ((f.p) = ((Proto)(luaM_growaux_(ls.L, f.p, ref (f.sizep), sizeof(Proto), MAXARG_Bx, "constant table overflow"))));
	  }
	  while (oldsize < f.sizep)
	  {
		  f.p[oldsize++] = null;
	  }
	  f.p[fs.np++] = func.f;
	  {
		  if (((((((union GCObject)((func.f))))).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))) && ((((((union GCObject)((f))))).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))))
		  {
			  luaC_barrierf(ls.L, (((union GCObject)((f)))), (((union GCObject)((func.f)))));
		  }
	  };
	  init_exp(v, expkind.VRELOCABLE, luaK_codeABx(fs, OpCode.OP_CLOSURE, 0, fs.np - 1));
	  for (i = 0; i < func.f.nups; i++)
	  {
		OpCode o = (func.upvalues[i].k == (int)expkind.VLOCAL) ? OpCode.OP_MOVE : OpCode.OP_GETUPVAL;
		luaK_codeABC(fs, o, 0, func.upvalues[i].info, 0);
	  }
	}


	internal static void open_func(LexState ls, FuncState fs)
	{
	  lua_State L = ls.L;
	  Proto f = luaF_newproto(L);
	  fs.f = f;
	  fs.prev = ls.fs; // linked list of funcstates
	  fs.ls = ls;
	  fs.L = L;
	  ls.fs = fs;
	  fs.pc = 0;
	  fs.lasttarget = -1;
	  fs.jpc = DefineConstants.NO_JUMP;
	  fs.freereg = 0;
	  fs.nk = 0;
	  fs.np = 0;
	  fs.nlocvars = 0;
	  fs.nactvar = 0;
	  fs.bl = null;
	  f.source = ls.source;
	  f.maxstacksize = 2; // registers 0/1 are always valid
	  fs.h = luaH_new(L, 0, 0);
	  /* anchor table of constants and prototype (to avoid being collected) */
	  {
		  lua_TValue i_o = (L.top);
		  i_o.value.gc = ((union GCObject)((fs.h)));
		  i_o.tt = DefineConstants.LUA_TTABLE;
		  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  {
		  if ((string)L.stack_last - (string)L.top <= (1) * (int)sizeof(lua_TValue) != null)
		  {
			  luaD_growstack(L, 1);
		  }
		  else
		  {
			  (x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
		  }
		  ;
		  L.top++;
  };
  {
		  lua_TValue i_o = (L.top);
		  i_o.value.gc = ((union GCObject)((f)));
		  i_o.tt = (DefineConstants.LUA_TTHREAD + 1);
		  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
  };
  {
		  if ((string)L.stack_last - (string)L.top <= (1) * (int)sizeof(lua_TValue) != null)
		  {
			  luaD_growstack(L, 1);
		  }
		  else
		  {
			  (x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
		  }
		  ;
		  L.top++;
  };
	}


	internal static void close_func(LexState ls)
	{
	  lua_State L = ls.L;
	  FuncState fs = ls.fs;
	  Proto f = fs.f;
	  removevars(ls, 0);
	  luaK_ret(fs, 0, 0); // final return
	  ((f.code) = ((LUAI_UINT32)(((cast(size_t, (fs.pc) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(LUAI_UINT32))) ? luaM_realloc_(L, (f.code), (f.sizecode) * (sizeof(LUAI_UINT32)), (fs.pc) * (sizeof(LUAI_UINT32))) : luaM_toobig(L)))));
	  f.sizecode = fs.pc;
	  ((f.lineinfo) = ((int)(((cast(size_t, (fs.pc) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(int))) ? luaM_realloc_(L, (f.lineinfo), (f.sizelineinfo) * (sizeof(int)), (fs.pc) * (sizeof(int))) : luaM_toobig(L)))));
	  f.sizelineinfo = fs.pc;
	  ((f.k) = ((lua_TValue)(((cast(size_t, (fs.nk) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(lua_TValue))) ? luaM_realloc_(L, (f.k), (f.sizek) * (sizeof(lua_TValue)), (fs.nk) * (sizeof(lua_TValue))) : luaM_toobig(L)))));
	  f.sizek = fs.nk;
	  ((f.p) = ((Proto)(((cast(size_t, (fs.np) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(Proto))) ? luaM_realloc_(L, (f.p), (f.sizep) * (sizeof(Proto)), (fs.np) * (sizeof(Proto))) : luaM_toobig(L)))));
	  f.sizep = fs.np;
	  ((f.locvars) = ((LocVar)(((cast(size_t, (fs.nlocvars) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(LocVar))) ? luaM_realloc_(L, (f.locvars), (f.sizelocvars) * (sizeof(LocVar)), (fs.nlocvars) * (sizeof(LocVar))) : luaM_toobig(L)))));
	  f.sizelocvars = fs.nlocvars;
	  ((f.upvalues) = ((TString)(((cast(size_t, (f.nups) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(TString))) ? luaM_realloc_(L, (f.upvalues), (f.sizeupvalues) * (sizeof(TString)), (f.nups) * (sizeof(TString))) : luaM_toobig(L)))));
	  f.sizeupvalues = f.nups;
	  (c)(0)(luaG_checkcode(f));
	  (c)(0)(fs.bl == null);
	  ls.fs = fs.prev;
	  L.top -= 2; // remove table and prototype from the stack
	  /* last token read was anchored in defunct function; must reanchor it */
	  if (fs != null)
	  {
		  anchor_token(ls);
	  }
	}



	/*============================================================*/
	/* GRAMMAR RULES */
	/*============================================================*/


	internal static void field(LexState ls, expdesc v)
	{
	  /* field -> ['.' | ':'] NAME */
	  FuncState fs = ls.fs;
	  expdesc key = new expdesc();
	  luaK_exp2anyreg(fs, v);
	  luaX_next(ls); // skip the dot or colon
	  checkname(ls, key);
	  luaK_indexed(fs, v, key);
	}


	internal static void yindex(LexState ls, expdesc v)
	{
	  /* index -> '[' expr ']' */
	  luaX_next(ls); // skip the '['
	  expr(ls, v);
	  luaK_exp2val(ls.fs, v);
	  checknext(ls, ']');
	}


	internal static void recfield(LexState ls, ConsControl cc)
	{
	  /* recfield -> (NAME | `['exp1`]') = exp1 */
	  FuncState fs = ls.fs;
	  int reg = ls.fs.freereg;
	  expdesc key = new expdesc();
	  expdesc val = new expdesc();
	  int rkkey;
	  if (ls.t.token == (int)RESERVED.TK_NAME)
	  {
		if ((cc.nh) > ((INT_MAX - 2)))
		{
			errorlimit(fs, (INT_MAX - 2), "items in a constructor");
		}
		checkname(ls, key);
	  }
	  else // ls->t.token == '['
	  {
		yindex(ls, key);
	  }
	  cc.nh++;
	  checknext(ls, '=');
	  rkkey = luaK_exp2RK(fs, key);
	  expr(ls, val);
	  luaK_codeABC(fs, OpCode.OP_SETTABLE, cc.t.u.s.info, rkkey, luaK_exp2RK(fs, val));
	  fs.freereg = reg; // free registers
	}


	internal static void closelistfield(FuncState fs, ConsControl cc)
	{
	  if (cc.v.k == expkind.VVOID)
	  {
		  return; // there is no list item
	  }
	  luaK_exp2nextreg(fs, cc.v);
	  cc.v.k = expkind.VVOID;
	  if (cc.tostore == DefineConstants.LFIELDS_PER_FLUSH)
	  {
		luaK_setlist(fs, cc.t.u.s.info, cc.na, cc.tostore); // flush
		cc.tostore = 0; // no more items pending
	  }
	}


	internal static void lastlistfield(FuncState fs, ConsControl cc)
	{
	  if (cc.tostore == 0)
	  {
		  return;
	  }
	  if (((cc.v.k) == expkind.VCALL || (cc.v.k) == expkind.VVARARG))
	  {
		luaK_setreturns(fs, cc.v, DefineConstants.LUA_MULTRET);
		luaK_setlist(fs, cc.t.u.s.info, cc.na, DefineConstants.LUA_MULTRET);
		cc.na--; // do not count last expression (unknown number of elements)
	  }
	  else
	  {
		if (cc.v.k != expkind.VVOID)
		{
		  luaK_exp2nextreg(fs, cc.v);
		}
		luaK_setlist(fs, cc.t.u.s.info, cc.na, cc.tostore);
	  }
	}


	internal static void listfield(LexState ls, ConsControl cc)
	{
	  expr(ls, cc.v);
	  if ((cc.na) > ((INT_MAX - 2)))
	  {
		  errorlimit(ls.fs, (INT_MAX - 2), "items in a constructor");
	  }
	  cc.na++;
	  cc.tostore++;
	}


	internal static void constructor(LexState ls, expdesc t)
	{
	  /* constructor -> ?? */
	  FuncState fs = ls.fs;
	  int line = ls.linenumber;
	  int pc = luaK_codeABC(fs, OpCode.OP_NEWTABLE, 0, 0, 0);
	  ConsControl cc = new ConsControl();
	  cc.na = cc.nh = cc.tostore = 0;
	  cc.t = t;
	  init_exp(t, expkind.VRELOCABLE, pc);
	  init_exp(cc.v, expkind.VVOID, 0); // no value (yet)
	  luaK_exp2nextreg(ls.fs, t); // fix it at stack top (for gc)
	  checknext(ls, '{');
	  do
	  {
		(c)(0)(cc.v.k == expkind.VVOID || cc.tostore > 0);
		if (ls.t.token == '}')
		{
			break;
		}
		closelistfield(fs, cc);
		switch (ls.t.token)
		{
		  case RESERVED.TK_NAME:
		  { // may be listfields or recfields
			luaX_lookahead(ls);
			if (ls.lookahead.token != '=') // expression?
			{
			  listfield(ls, cc);
			}
			else
			{
			  recfield(ls, cc);
			}
			break;
		  }
		  case '[':
		  { // constructor_item -> recfield
			recfield(ls, cc);
			break;
		  }
		  default:
		  { // constructor_part -> listfield
			listfield(ls, cc);
			break;
		  }
		}
	  } while (testnext(ls, ',') != 0 || testnext(ls, ';') != 0);
	  check_match(ls, '}', '{', line);
	  lastlistfield(fs, cc);
	  ((fs.f.code[pc]) = (((fs.f.code[pc]) & (~MASK1(DefineConstants.SIZE_B,(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)))) | ((((LUAI_UINT32)(luaO_int2fb(cc.na))) << (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C))))); // set initial array size
	  ((fs.f.code[pc]) = (((fs.f.code[pc]) & (~MASK1(DefineConstants.SIZE_C,((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)))) | ((((LUAI_UINT32)(luaO_int2fb(cc.nh))) << ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A))))); // set initial table size
	}

	/* }====================================================================== */



	internal static void parlist(LexState ls)
	{
	  /* parlist -> [ param { `,' param } ] */
	  FuncState fs = ls.fs;
	  Proto f = fs.f;
	  int nparams = 0;
	  f.is_vararg = 0;
	  if (ls.t.token != ')')
	  { // is `parlist' not empty?
		do
		{
		  switch (ls.t.token)
		  {
			case RESERVED.TK_NAME:
			{ // param -> NAME
			  new_localvar(ls, str_checkname(ls), nparams++);
			  break;
			}
			case RESERVED.TK_DOTS:
			{ // param -> `...'
			  luaX_next(ls);
	#if LUA_COMPAT_VARARG
			  /* use `arg' as default name */
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: new_localvar(ls, luaX_newstring(ls, "" "arg", (sizeof("arg")/sizeof(sbyte))-1), nparams++);
			  new_localvar(ls, luaX_newstring(ls, "" "arg", (("arg").Length) - 1), nparams++);
			  f.is_vararg = DefineConstants.VARARG_HASARG | DefineConstants.VARARG_NEEDSARG;
	#endif
			  f.is_vararg |= DefineConstants.VARARG_ISVARARG;
			  break;
			}
			default:
				luaX_syntaxerror(ls, "<name> or " "'" "..." "'" " expected");
			break;
		  }
		} while (f.is_vararg == 0 && testnext(ls, ',') != 0);
	  }
	  adjustlocalvars(ls, nparams);
	  f.numparams = ((byte)((fs.nactvar - (f.is_vararg & DefineConstants.VARARG_HASARG))));
	  luaK_reserveregs(fs, fs.nactvar); // reserve register for parameters
	}


	internal static void body(LexState ls, expdesc e, int needself, int line)
	{
	  /* body ->  `(' parlist `)' chunk END */
	  FuncState new_fs = new FuncState();
	  open_func(ls, new_fs);
	  new_fs.f.linedefined = line;
	  checknext(ls, '(');
	  if (needself != 0)
	  {
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: new_localvar(ls, luaX_newstring(ls, "" "self", (sizeof("self")/sizeof(sbyte))-1), 0);
		new_localvar(ls, luaX_newstring(ls, "" "self", (("self").Length) - 1), 0);
		adjustlocalvars(ls, 1);
	  }
	  parlist(ls);
	  checknext(ls, ')');
	  chunk(ls);
	  new_fs.f.lastlinedefined = ls.linenumber;
	  check_match(ls, RESERVED.TK_END, RESERVED.TK_FUNCTION, line);
	  close_func(ls);
	  pushclosure(ls, new_fs, e);
	}


	internal static int explist1(LexState ls, expdesc v)
	{
	  /* explist1 -> expr { `,' expr } */
	  int n = 1; // at least one expression
	  expr(ls, v);
	  while (testnext(ls, ',') != 0)
	  {
		luaK_exp2nextreg(ls.fs, v);
		expr(ls, v);
		n++;
	  }
	  return n;
	}


	internal static void funcargs(LexState ls, expdesc f)
	{
	  FuncState fs = ls.fs;
	  expdesc args = new expdesc();
	  int @base;
	  int nparams;
	  int line = ls.linenumber;
	  switch (ls.t.token)
	  {
		case '(':
		{ // funcargs -> `(' [ explist1 ] `)'
		  if (line != ls.lastline)
		  {
			luaX_syntaxerror(ls, "ambiguous syntax (function call x new statement)");
		  }
		  luaX_next(ls);
		  if (ls.t.token == ')') // arg list is empty?
		  {
			args.k = expkind.VVOID;
		  }
		  else
		  {
			explist1(ls, args);
			luaK_setreturns(fs, args, DefineConstants.LUA_MULTRET);
		  }
		  check_match(ls, ')', '(', line);
		  break;
		}
		case '{':
		{ // funcargs -> constructor
		  constructor(ls, args);
		  break;
		}
		case RESERVED.TK_STRING:
		{ // funcargs -> STRING
		  codestring(ls, args, ls.t.seminfo.ts);
		  luaX_next(ls); // must use `seminfo' before `next'
		  break;
		}
		default:
		{
		  luaX_syntaxerror(ls, "function arguments expected");
		  return;
		}
	  }
	  (c)(0)(f.k == expkind.VNONRELOC);
	  @base = f.u.s.info; // base register for call
	  if (((args.k) == expkind.VCALL || (args.k) == expkind.VVARARG))
	  {
		nparams = DefineConstants.LUA_MULTRET; // open call
	  }
	  else
	  {
		if (args.k != expkind.VVOID)
		{
		  luaK_exp2nextreg(fs, args); // close last argument
		}
		nparams = fs.freereg - (@base+1);
	  }
	  init_exp(f, expkind.VCALL, luaK_codeABC(fs, OpCode.OP_CALL, @base, nparams + 1, 2));
	  luaK_fixline(fs, line);
	  fs.freereg = @base+1; /* call remove function and arguments and leaves
	                            (unless changed) one result */
	}




	/*
	** {======================================================================
	** Expression parsing
	** =======================================================================
	*/


	internal static void prefixexp(LexState ls, expdesc v)
	{
	  /* prefixexp -> NAME | '(' expr ')' */
	  switch (ls.t.token)
	  {
		case '(':
		{
		  int line = ls.linenumber;
		  luaX_next(ls);
		  expr(ls, v);
		  check_match(ls, ')', '(', line);
		  luaK_dischargevars(ls.fs, v);
		  return;
		}
		case RESERVED.TK_NAME:
		{
		  singlevar(ls, v);
		  return;
		}
		default:
		{
		  luaX_syntaxerror(ls, "unexpected symbol");
		  return;
		}
	  }
	}


	internal static void primaryexp(LexState ls, expdesc v)
	{
	  /* primaryexp ->
	        prefixexp { `.' NAME | `[' exp `]' | `:' NAME funcargs | funcargs } */
	  FuncState fs = ls.fs;
	  prefixexp(ls, v);
	  for (;;)
	  {
		switch (ls.t.token)
		{
		  case '.':
		  { // field
			field(ls, v);
			break;
		  }
		  case '[':
		  { // `[' exp1 `]'
			expdesc key = new expdesc();
			luaK_exp2anyreg(fs, v);
			yindex(ls, key);
			luaK_indexed(fs, v, key);
			break;
		  }
		  case ':':
		  { // `:' NAME funcargs
			expdesc key = new expdesc();
			luaX_next(ls);
			checkname(ls, key);
			luaK_self(fs, v, key);
			funcargs(ls, v);
			break;
		  }
		  case '(':
	  case RESERVED.TK_STRING:
	case '{':
	{ // funcargs
			luaK_exp2nextreg(fs, v);
			funcargs(ls, v);
			break;
	}
		  default:
			  return;
		}
	  }
	}


	internal static void simpleexp(LexState ls, expdesc v)
	{
	  /* simpleexp -> NUMBER | STRING | NIL | true | false | ... |
	                  constructor | FUNCTION body | primaryexp */
	  switch (ls.t.token)
	  {
		case RESERVED.TK_NUMBER:
		{
		  init_exp(v, expkind.VKNUM, 0);
		  v.u.nval = ls.t.seminfo.r;
		  break;
		}
		case RESERVED.TK_STRING:
		{
		  codestring(ls, v, ls.t.seminfo.ts);
		  break;
		}
		case RESERVED.TK_NIL:
		{
		  init_exp(v, expkind.VNIL, 0);
		  break;
		}
		case RESERVED.TK_TRUE:
		{
		  init_exp(v, expkind.VTRUE, 0);
		  break;
		}
		case RESERVED.TK_FALSE:
		{
		  init_exp(v, expkind.VFALSE, 0);
		  break;
		}
		case RESERVED.TK_DOTS:
		{ // vararg
		  FuncState fs = ls.fs;
		  {
			  if ((fs.f.is_vararg) == 0)
			  {
				  luaX_syntaxerror(ls, "cannot use " "'" "..." "'" " outside a vararg function");
			  }
		  };
		  fs.f.is_vararg &= ~DefineConstants.VARARG_NEEDSARG; // don't need 'arg'
		  init_exp(v, expkind.VVARARG, luaK_codeABC(fs, OpCode.OP_VARARG, 0, 1, 0));
		  break;
		}
		case '{':
		{ // constructor
		  constructor(ls, v);
		  return;
		}
		case RESERVED.TK_FUNCTION:
		{
		  luaX_next(ls);
		  body(ls, v, 0, ls.linenumber);
		  return;
		}
		default:
		{
		  primaryexp(ls, v);
		  return;
		}
	  }
	  luaX_next(ls);
	}


	internal static UnOpr getunopr(int op)
	{
	  switch (op)
	  {
		case RESERVED.TK_NOT:
			return UnOpr.OPR_NOT;
		case '-':
			return UnOpr.OPR_MINUS;
		case '#':
			return UnOpr.OPR_LEN;
		default:
			return UnOpr.OPR_NOUNOPR;
	  }
	}


	internal static BinOpr getbinopr(int op)
	{
	  switch (op)
	  {
		case '+':
			return BinOpr.OPR_ADD;
		case '-':
			return BinOpr.OPR_SUB;
		case '*':
			return BinOpr.OPR_MUL;
		case '/':
			return BinOpr.OPR_DIV;
		case '%':
			return BinOpr.OPR_MOD;
		case '^':
			return BinOpr.OPR_POW;
		case RESERVED.TK_CONCAT:
			return BinOpr.OPR_CONCAT;
		case RESERVED.TK_NE:
			return BinOpr.OPR_NE;
		case RESERVED.TK_EQ:
			return BinOpr.OPR_EQ;
		case '<':
			return BinOpr.OPR_LT;
		case RESERVED.TK_LE:
			return BinOpr.OPR_LE;
		case '>':
			return BinOpr.OPR_GT;
		case RESERVED.TK_GE:
			return BinOpr.OPR_GE;
		case RESERVED.TK_AND:
			return BinOpr.OPR_AND;
		case RESERVED.TK_OR:
			return BinOpr.OPR_OR;
		default:
			return BinOpr.OPR_NOBINOPR;
	  }
	}
	public static AnonymousClass6[] priority =
	{
		new AnonymousClass6(6, 6),
		new AnonymousClass6(6, 6),
		new AnonymousClass6(7, 7),
		new AnonymousClass6(7, 7),
		new AnonymousClass6(7, 7),
		new AnonymousClass6(10, 9),
		new AnonymousClass6(5, 4),
		new AnonymousClass6(3, 3),
		new AnonymousClass6(3, 3),
		new AnonymousClass6(3, 3),
		new AnonymousClass6(3, 3),
		new AnonymousClass6(3, 3),
		new AnonymousClass6(3, 3),
		new AnonymousClass6(2, 2),
		new AnonymousClass6(1, 1)
	};



	/*
	** subexpr -> (simpleexp | unop subexpr) { binop subexpr }
	** where `binop' is any binary operator with a priority higher than `limit'
	*/
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'ls', so pointers on this parameter are left unchanged:
	internal static BinOpr subexpr(LexState * ls, expdesc v, uint limit)
	{
	  BinOpr op;
	  UnOpr uop;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: enterlevel(ls);
	  enterlevel(new LexState(ls));
	  uop = getunopr(ls.t.token);
	  if (uop != UnOpr.OPR_NOUNOPR)
	  {
		luaX_next(ls);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: subexpr(ls, v, DefineConstants.UNARY_PRIORITY);
		subexpr(new LexState(ls), v, DefineConstants.UNARY_PRIORITY);
		luaK_prefix(ls.fs, uop, v);
	  }
	  else
	  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: simpleexp(ls, v);
		  simpleexp(new LexState(ls), v);
	  }
	  /* expand while operators have priorities higher than `limit' */
	  op = getbinopr(ls.t.token);
	  while (op != BinOpr.OPR_NOBINOPR && priority[(int)op].left > limit)
	  {
		expdesc v2 = new expdesc();
		BinOpr nextop;
		luaX_next(ls);
		luaK_infix(ls.fs, op, v);
		/* read sub-expression with higher priority */
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: nextop = subexpr(ls, &v2, priority[op].right);
		nextop = subexpr(new LexState(ls), v2, priority[(int)op].right);
		luaK_posfix(ls.fs, op, v, v2);
		op = nextop;
	  }
	  ((ls).L.nCcalls--);
	  return op; // return first untreated operator
	}

	/* }==================================================================== */



	/*
	** {======================================================================
	** Rules for Statements
	** =======================================================================
	*/


	internal static int block_follow(int token)
	{
	  switch (token)
	  {
		case RESERVED.TK_ELSE:
	case RESERVED.TK_ELSEIF:
	case RESERVED.TK_END:
		case RESERVED.TK_UNTIL:
	case RESERVED.TK_EOS:
		  return 1;
		default:
			return 0;
	  }
	}


	internal static void block(LexState ls)
	{
	  /* block -> chunk */
	  FuncState fs = ls.fs;
	  BlockCnt bl = new BlockCnt();
	  enterblock(fs, bl, 0);
	  chunk(ls);
	  (c)(0)(bl.breaklist == DefineConstants.NO_JUMP);
	  leaveblock(fs);
	}


	/*
	** check whether, in an assignment to a local variable, the local variable
	** is needed in a previous assignment (to a table). If so, save original
	** local value in a safe place and use this safe copy in the previous
	** assignment.
	*/
	internal static void check_conflict(LexState ls, LHS_assign lh, expdesc v)
	{
	  FuncState fs = ls.fs;
	  int extra = fs.freereg; // eventual position to save local variable
	  int conflict = 0;
	  for (; lh != null; lh = lh.prev)
	  {
		if (lh.v.k == expkind.VINDEXED)
		{
		  if (lh.v.u.s.info == v.u.s.info)
		  { // conflict?
			conflict = 1;
			lh.v.u.s.info = extra; // previous assignment will use safe copy
		  }
		  if (lh.v.u.s.aux == v.u.s.info)
		  { // conflict?
			conflict = 1;
			lh.v.u.s.aux = extra; // previous assignment will use safe copy
		  }
		}
	  }
	  if (conflict != 0)
	  {
		luaK_codeABC(fs, OpCode.OP_MOVE, fs.freereg, v.u.s.info, 0); // make copy
		luaK_reserveregs(fs, 1);
	  }
	}


	internal static void assignment(LexState ls, LHS_assign lh, int nvars)
	{
	  expdesc e = new expdesc();
	  {
		  if (!(expkind.VLOCAL <= ((int)lh.v.k) != 0 && lh.v.k <= expkind.VINDEXED))
		  {
			  luaX_syntaxerror(ls, "syntax error");
		  }
	  };
	  if (testnext(ls, ',') != 0)
	  { // assignment -> `,' primaryexp assignment
		LHS_assign nv = new LHS_assign();
		nv.prev = lh;
		primaryexp(ls, nv.v);
		if (nv.v.k == expkind.VLOCAL)
		{
		  check_conflict(ls, lh, nv.v);
		}
		if ((nvars) > (DefineConstants.LUAI_MAXCCALLS - ls.L.nCcalls))
		{
			errorlimit(ls.fs, DefineConstants.LUAI_MAXCCALLS - ls.L.nCcalls, "variables in assignment");
		}
		assignment(ls, nv, nvars + 1);
	  }
	  else
	  { // assignment -> `=' explist1
		int nexps;
		checknext(ls, '=');
		nexps = explist1(ls, e);
		if (nexps != nvars)
		{
		  adjust_assign(ls, nvars, nexps, e);
		  if (nexps > nvars)
		  {
			ls.fs.freereg -= nexps - nvars; // remove extra values
		  }
		}
		else
		{
		  luaK_setoneret(ls.fs, e); // close last expression
		  luaK_storevar(ls.fs, lh.v, e);
		  return; // avoid default
		}
	  }
	  init_exp(e, expkind.VNONRELOC, ls.fs.freereg - 1); // default assignment
	  luaK_storevar(ls.fs, lh.v, e);
	}


	internal static int cond(LexState ls)
	{
	  /* cond -> exp */
	  expdesc v = new expdesc();
	  expr(ls, v); // read condition
	  if (v.k == expkind.VNIL)
	  {
		  v.k = expkind.VFALSE; // `falses' are all equal here
	  }
	  luaK_goiftrue(ls.fs, v);
	  return v.f;
	}


	internal static void breakstat(LexState ls)
	{
	  FuncState fs = ls.fs;
	  BlockCnt bl = fs.bl;
	  int upval = 0;
	  while (bl != null && bl.isbreakable == 0)
	  {
		upval |= bl.upval;
		bl = bl.previous;
	  }
	  if (bl == null)
	  {
		luaX_syntaxerror(ls, "no loop to break");
	  }
	  if (upval != 0)
	  {
		luaK_codeABC(fs, OpCode.OP_CLOSE, bl.nactvar, 0, 0);
	  }
	  luaK_concat(fs, ref bl.breaklist, luaK_jump(fs));
	}


	internal static void whilestat(LexState ls, int line)
	{
	  /* whilestat -> WHILE cond DO block END */
	  FuncState fs = ls.fs;
	  int whileinit;
	  int condexit;
	  BlockCnt bl = new BlockCnt();
	  luaX_next(ls); // skip WHILE
	  whileinit = luaK_getlabel(fs);
	  condexit = cond(ls);
	  enterblock(fs, bl, 1);
	  checknext(ls, RESERVED.TK_DO);
	  block(ls);
	  luaK_patchlist(fs, luaK_jump(fs), whileinit);
	  check_match(ls, RESERVED.TK_END, RESERVED.TK_WHILE, line);
	  leaveblock(fs);
	  luaK_patchtohere(fs, condexit); // false conditions finish the loop
	}


	internal static void repeatstat(LexState ls, int line)
	{
	  /* repeatstat -> REPEAT block UNTIL cond */
	  int condexit;
	  FuncState fs = ls.fs;
	  int repeat_init = luaK_getlabel(fs);
	  BlockCnt bl1 = new BlockCnt();
	  BlockCnt bl2 = new BlockCnt();
	  enterblock(fs, bl1, 1); // loop block
	  enterblock(fs, bl2, 0); // scope block
	  luaX_next(ls); // skip REPEAT
	  chunk(ls);
	  check_match(ls, RESERVED.TK_UNTIL, RESERVED.TK_REPEAT, line);
	  condexit = cond(ls); // read condition (inside scope block)
	  if (bl2.upval == 0)
	  { // no upvalues?
		leaveblock(fs); // finish scope
		luaK_patchlist(ls.fs, condexit, repeat_init); // close the loop
	  }
	  else
	  { // complete semantics when there are upvalues
		breakstat(ls); // if condition then break
		luaK_patchtohere(ls.fs, condexit); // else...
		leaveblock(fs); // finish scope...
		luaK_patchlist(ls.fs, luaK_jump(fs), repeat_init); // and repeat
	  }
	  leaveblock(fs); // finish loop
	}


	internal static int exp1(LexState ls)
	{
	  expdesc e = new expdesc();
	  int k;
	  expr(ls, e);
	  k = (int)e.k;
	  luaK_exp2nextreg(ls.fs, e);
	  return k;
	}


	internal static void forbody(LexState ls, int @base, int line, int nvars, int isnum)
	{
	  /* forbody -> DO block */
	  BlockCnt bl = new BlockCnt();
	  FuncState fs = ls.fs;
	  int prep;
	  int endfor;
	  adjustlocalvars(ls, 3); // control variables
	  checknext(ls, RESERVED.TK_DO);
	  prep = isnum != 0 ? luaK_codeABx(fs, OpCode.OP_FORPREP, @base, (DefineConstants.NO_JUMP) + MAXARG_sBx) : luaK_jump(fs);
	  enterblock(fs, bl, 0); // scope for declared variables
	  adjustlocalvars(ls, nvars);
	  luaK_reserveregs(fs, nvars);
	  block(ls);
	  leaveblock(fs); // end of scope for declared variables
	  luaK_patchtohere(fs, prep);
	  endfor = (isnum) != 0 ? luaK_codeABx(fs, OpCode.OP_FORLOOP, @base, (DefineConstants.NO_JUMP) + MAXARG_sBx) : luaK_codeABC(fs, OpCode.OP_TFORLOOP, @base, 0, nvars);
	  luaK_fixline(fs, line); // pretend that `OP_FOR' starts the loop
	  luaK_patchlist(fs, (isnum != 0 ? endfor : luaK_jump(fs)), prep + 1);
	}


	internal static void fornum(LexState ls, TString varname, int line)
	{
	  /* fornum -> NAME = exp1,exp1[,exp1] forbody */
	  FuncState fs = ls.fs;
	  int @base = fs.freereg;
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: new_localvar(ls, luaX_newstring(ls, "" "(for index)", (sizeof("(for index)")/sizeof(sbyte))-1), 0);
	  new_localvar(ls, luaX_newstring(ls, "" "(for index)", (("(for index)").Length) - 1), 0);
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: new_localvar(ls, luaX_newstring(ls, "" "(for limit)", (sizeof("(for limit)")/sizeof(sbyte))-1), 1);
	  new_localvar(ls, luaX_newstring(ls, "" "(for limit)", (("(for limit)").Length) - 1), 1);
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: new_localvar(ls, luaX_newstring(ls, "" "(for step)", (sizeof("(for step)")/sizeof(sbyte))-1), 2);
	  new_localvar(ls, luaX_newstring(ls, "" "(for step)", (("(for step)").Length) - 1), 2);
	  new_localvar(ls, varname, 3);
	  checknext(ls, '=');
	  exp1(ls); // initial value
	  checknext(ls, ',');
	  exp1(ls); // limit
	  if (testnext(ls, ',') != 0)
	  {
		exp1(ls); // optional step
	  }
	  else
	  { // default step = 1
		luaK_codeABx(fs, OpCode.OP_LOADK, fs.freereg, luaK_numberK(fs, 1));
		luaK_reserveregs(fs, 1);
	  }
	  forbody(ls, @base, line, 1, 1);
	}


	internal static void forlist(LexState ls, TString indexname)
	{
	  /* forlist -> NAME {,NAME} IN explist1 forbody */
	  FuncState fs = ls.fs;
	  expdesc e = new expdesc();
	  int nvars = 0;
	  int line;
	  int @base = fs.freereg;
	  /* create control variables */
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: new_localvar(ls, luaX_newstring(ls, "" "(for generator)", (sizeof("(for generator)")/sizeof(sbyte))-1), nvars++);
	  new_localvar(ls, luaX_newstring(ls, "" "(for generator)", (("(for generator)").Length) - 1), nvars++);
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: new_localvar(ls, luaX_newstring(ls, "" "(for state)", (sizeof("(for state)")/sizeof(sbyte))-1), nvars++);
	  new_localvar(ls, luaX_newstring(ls, "" "(for state)", (("(for state)").Length) - 1), nvars++);
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: new_localvar(ls, luaX_newstring(ls, "" "(for control)", (sizeof("(for control)")/sizeof(sbyte))-1), nvars++);
	  new_localvar(ls, luaX_newstring(ls, "" "(for control)", (("(for control)").Length) - 1), nvars++);
	  /* create declared variables */
	  new_localvar(ls, indexname, nvars++);
	  while (testnext(ls, ',') != 0)
	  {
		new_localvar(ls, str_checkname(ls), nvars++);
	  }
	  checknext(ls, RESERVED.TK_IN);
	  line = ls.linenumber;
	  adjust_assign(ls, 3, explist1(ls, e), e);
	  luaK_checkstack(fs, 3); // extra space to call generator
	  forbody(ls, @base, line, nvars - 3, 0);
	}


	internal static void forstat(LexState ls, int line)
	{
	  /* forstat -> FOR (fornum | forlist) END */
	  FuncState fs = ls.fs;
	  TString varname;
	  BlockCnt bl = new BlockCnt();
	  enterblock(fs, bl, 1); // scope for loop and control variables
	  luaX_next(ls); // skip `for'
	  varname = str_checkname(ls); // first variable name
	  switch (ls.t.token)
	  {
		case '=':
			fornum(ls, varname, line);
			break;
		case ',':
	case RESERVED.TK_IN:
		forlist(ls, varname);
		break;
		default:
			luaX_syntaxerror(ls, "'" "=" "'" " or " "'" "in" "'" " expected");
		break;
	  }
	  check_match(ls, RESERVED.TK_END, RESERVED.TK_FOR, line);
	  leaveblock(fs); // loop scope (`break' jumps to this point)
	}


	internal static int test_then_block(LexState ls)
	{
	  /* test_then_block -> [IF | ELSEIF] cond THEN block */
	  int condexit;
	  luaX_next(ls); // skip IF or ELSEIF
	  condexit = cond(ls);
	  checknext(ls, RESERVED.TK_THEN);
	  block(ls); // `then' part
	  return condexit;
	}


	internal static void ifstat(LexState ls, int line)
	{
	  /* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
	  FuncState fs = ls.fs;
	  int flist;
	  int escapelist = DefineConstants.NO_JUMP;
	  flist = test_then_block(ls); // IF cond THEN block
	  while (ls.t.token == (int)RESERVED.TK_ELSEIF)
	  {
		luaK_concat(fs, ref escapelist, luaK_jump(fs));
		luaK_patchtohere(fs, flist);
		flist = test_then_block(ls); // ELSEIF cond THEN block
	  }
	  if (ls.t.token == (int)RESERVED.TK_ELSE)
	  {
		luaK_concat(fs, ref escapelist, luaK_jump(fs));
		luaK_patchtohere(fs, flist);
		luaX_next(ls); // skip ELSE (after patch, for correct line info)
		block(ls); // `else' part
	  }
	  else
	  {
		luaK_concat(fs, ref escapelist, flist);
	  }
	  luaK_patchtohere(fs, escapelist);
	  check_match(ls, RESERVED.TK_END, RESERVED.TK_IF, line);
	}


	internal static void localfunc(LexState ls)
	{
	  expdesc v = new expdesc();
	  expdesc b = new expdesc();
	  FuncState fs = ls.fs;
	  new_localvar(ls, str_checkname(ls), 0);
	  init_exp(v, expkind.VLOCAL, fs.freereg);
	  luaK_reserveregs(fs, 1);
	  adjustlocalvars(ls, 1);
	  body(ls, b, 0, ls.linenumber);
	  luaK_storevar(fs, v, b);
	  /* debug information will only see the variable after this point! */
	  ((fs).f.locvars[(fs).actvar[fs.nactvar - 1]]).startpc = fs.pc;
	}


	internal static void localstat(LexState ls)
	{
	  /* stat -> LOCAL NAME {`,' NAME} [`=' explist1] */
	  int nvars = 0;
	  int nexps;
	  expdesc e = new expdesc();
	  do
	  {
		new_localvar(ls, str_checkname(ls), nvars++);
	  } while (testnext(ls, ',') != 0);
	  if (testnext(ls, '=') != 0)
	  {
		nexps = explist1(ls, e);
	  }
	  else
	  {
		e.k = expkind.VVOID;
		nexps = 0;
	  }
	  adjust_assign(ls, nvars, nexps, e);
	  adjustlocalvars(ls, nvars);
	}


	internal static int funcname(LexState ls, expdesc v)
	{
	  /* funcname -> NAME {field} [`:' NAME] */
	  int needself = 0;
	  singlevar(ls, v);
	  while (ls.t.token == '.')
	  {
		field(ls, v);
	  }
	  if (ls.t.token == ':')
	  {
		needself = 1;
		field(ls, v);
	  }
	  return needself;
	}


	internal static void funcstat(LexState ls, int line)
	{
	  /* funcstat -> FUNCTION funcname body */
	  int needself;
	  expdesc v = new expdesc();
	  expdesc b = new expdesc();
	  luaX_next(ls); // skip FUNCTION
	  needself = funcname(ls, v);
	  body(ls, b, needself, line);
	  luaK_storevar(ls.fs, v, b);
	  luaK_fixline(ls.fs, line); // definition `happens' in the first line
	}


	internal static void exprstat(LexState ls)
	{
	  /* stat -> func | assignment */
	  FuncState fs = ls.fs;
	  LHS_assign v = new LHS_assign();
	  primaryexp(ls, v.v);
	  if (v.v.k == expkind.VCALL) // stat -> func
	  {
		((((fs).f.code[(v.v).u.s.info])) = (((((fs).f.code[(v.v).u.s.info])) & (~MASK1(DefineConstants.SIZE_C,((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)))) | ((((LUAI_UINT32)(1)) << ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A))))); // call statement uses no results
	  }
	  else
	  { // stat -> assignment
		v.prev = null;
		assignment(ls, v, 1);
	  }
	}


	internal static void retstat(LexState ls)
	{
	  /* stat -> RETURN explist */
	  FuncState fs = ls.fs;
	  expdesc e = new expdesc();
	  int first; // registers with returned values
	  int nret;
	  luaX_next(ls); // skip RETURN
	  if (block_follow(ls.t.token) != 0 || ls.t.token == ';')
	  {
		first = nret = 0; // return no values
	  }
	  else
	  {
		nret = explist1(ls, e); // optional return values
		if (((e.k) == expkind.VCALL || (e.k) == expkind.VVARARG))
		{
		  luaK_setreturns(fs, e, DefineConstants.LUA_MULTRET);
		  if (e.k == expkind.VCALL && nret == 1)
		  { // tail call?
			((((fs).f.code[(e).u.s.info])) = (((((fs).f.code[(e).u.s.info])) & (~MASK1(DefineConstants.SIZE_OP,DefineConstants.POS_OP))) | ((((LUAI_UINT32)(OpCode.OP_TAILCALL)) << DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << DefineConstants.POS_OP))));
			(c)(0)((((int)(((((fs).f.code[(e).u.s.info])) >> (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_A)) << 0)))) == fs.nactvar);
		  }
		  first = fs.nactvar;
		  nret = DefineConstants.LUA_MULTRET; // return all values
		}
		else
		{
		  if (nret == 1) // only one single value?
		  {
			first = luaK_exp2anyreg(fs, e);
		  }
		  else
		  {
			luaK_exp2nextreg(fs, e); // values must go to the `stack'
			first = fs.nactvar; // return all `active' values
			(c)(0)(nret == fs.freereg - first);
		  }
		}
	  }
	  luaK_ret(fs, first, nret);
	}


	internal static int statement(LexState ls)
	{
	  int line = ls.linenumber; // may be needed for error messages
	  switch (ls.t.token)
	  {
		case RESERVED.TK_IF:
		{ // stat -> ifstat
		  ifstat(ls, line);
		  return 0;
		}
		case RESERVED.TK_WHILE:
		{ // stat -> whilestat
		  whilestat(ls, line);
		  return 0;
		}
		case RESERVED.TK_DO:
		{ // stat -> DO block END
		  luaX_next(ls); // skip DO
		  block(ls);
		  check_match(ls, RESERVED.TK_END, RESERVED.TK_DO, line);
		  return 0;
		}
		case RESERVED.TK_FOR:
		{ // stat -> forstat
		  forstat(ls, line);
		  return 0;
		}
		case RESERVED.TK_REPEAT:
		{ // stat -> repeatstat
		  repeatstat(ls, line);
		  return 0;
		}
		case RESERVED.TK_FUNCTION:
		{
		  funcstat(ls, line); // stat -> funcstat
		  return 0;
		}
		case RESERVED.TK_LOCAL:
		{ // stat -> localstat
		  luaX_next(ls); // skip LOCAL
		  if (testnext(ls, RESERVED.TK_FUNCTION) != 0) // local function?
		  {
			localfunc(ls);
		  }
		  else
		  {
			localstat(ls);
		  }
		  return 0;
		}
		case RESERVED.TK_RETURN:
		{ // stat -> retstat
		  retstat(ls);
		  return 1; // must be last statement
		}
		case RESERVED.TK_BREAK:
		{ // stat -> breakstat
		  luaX_next(ls); // skip BREAK
		  breakstat(ls);
		  return 1; // must be last statement
		}
		default:
		{
		  exprstat(ls);
		  return 0; // to avoid warnings
		}
	  }
	}

	/* }====================================================================== */



	/* macros to convert a GCObject into a specific value */
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2ts(o) check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2ts(o) (&rawgco2ts(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2u(o) check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2u(o) (&rawgco2u(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2cl(o) check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2h(o) check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2p(o) check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2uv(o) check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ngcotouv(o) check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2th(o) check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))

	/* macro to convert any Lua object into a GCObject */
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define obj2gco(v) (cast(GCObject *, (v)))


	public static lua_State luaE_newthread(lua_State L)
	{
	  lua_State L1 = (((lua_State)(((byte)(luaM_realloc_(L, null, 0, ((sizeof(lua_State) + DefineConstants.LUAI_EXTRASPACE))))) + DefineConstants.LUAI_EXTRASPACE)));
	  luaC_link(L, (((union GCObject)((L1)))), DefineConstants.LUA_TTHREAD);
	  preinit_state(L1, (L.l_G));
	  stack_init(L1, L); // init stack
	  {
		  lua_TValue o2 = ((L.l_gt));
		  lua_TValue o1 = ((L1.l_gt));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
		  o1.value.CopyFrom(o2.value);
		  o1.tt = o2.tt;
		  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  }; // share table of globals
	  L1.hookmask = L.hookmask;
	  L1.basehookcount = L.basehookcount;
	  L1.hook = L.hook;
	  (L1.hookcount = L1.basehookcount);
	  (c)(0)(((((((union GCObject)((L1))))).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))))));
	  return L1;
	}
	public static void luaE_freethread(lua_State L, lua_State L1)
	{
	  luaF_close(L1, L1.stack); // close all upvalues for this thread
	  (c)(0)(L1.openupval == null);
	  (L1);
	  freestack(L, L1);
	  luaM_realloc_(L, ((((byte)((L1))) - DefineConstants.LUAI_EXTRASPACE)), ((sizeof(lua_State) + DefineConstants.LUAI_EXTRASPACE)), 0);
	}



	internal static void stack_init(lua_State L1, lua_State L)
	{
	  /* initialize CallInfo array */
	  L1.base_ci = ((CallInfo)(((cast(size_t, (DefineConstants.BASIC_CI_SIZE) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(CallInfo))) ? luaM_realloc_(L, (null), (0) * (sizeof(CallInfo)), (DefineConstants.BASIC_CI_SIZE) * (sizeof(CallInfo))) : luaM_toobig(L))));
	  L1.ci = L1.base_ci;
	  L1.size_ci = DefineConstants.BASIC_CI_SIZE;
	  L1.end_ci = L1.base_ci + L1.size_ci - 1;
	  /* initialize stack array */
	  L1.stack = ((lua_TValue)(((cast(size_t, ((2 * DefineConstants.LUA_MINSTACK) + DefineConstants.EXTRA_STACK) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(lua_TValue))) ? luaM_realloc_(L, (null), (0) * (sizeof(lua_TValue)), ((2 * DefineConstants.LUA_MINSTACK) + DefineConstants.EXTRA_STACK) * (sizeof(lua_TValue))) : luaM_toobig(L))));
	  L1.stacksize = (2 * DefineConstants.LUA_MINSTACK) + DefineConstants.EXTRA_STACK;
	  L1.top = L1.stack;
	  L1.stack_last = L1.stack + (L1.stacksize - DefineConstants.EXTRA_STACK) - 1;
	  /* initialize first ci */
	  L1.ci.func = L1.top;
	  ((L1.top++).tt = DefineConstants.LUA_TNIL); // `function' entry for this `ci'
	  L1.@base = L1.ci.@base = L1.top;
	  L1.ci.top = L1.top + DefineConstants.LUA_MINSTACK;
	}


	internal static void freestack(lua_State L, lua_State L1)
	{
	  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(CallInfo))) ? luaM_realloc_(L, ((L1.base_ci)), (L1.size_ci) * (sizeof(CallInfo)), (0) * (sizeof(CallInfo))) : luaM_toobig(L));
	  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(lua_TValue))) ? luaM_realloc_(L, ((L1.stack)), (L1.stacksize) * (sizeof(lua_TValue)), (0) * (sizeof(lua_TValue))) : luaM_toobig(L));
	}


	/*
	** open parts that may cause memory-allocation errors
	*/
	internal static void f_luaopen(lua_State L, object ud)
	{
	  global_State g = (L.l_G);
	  ((ud));
	  stack_init(L, L); // init stack
	  {
		  lua_TValue i_o = ((L.l_gt));
		  i_o.value.gc = ((union GCObject)(luaH_new(L, 0, 2)));
		  i_o.tt = DefineConstants.LUA_TTABLE;
		  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  }; // table of globals
	  {
		  lua_TValue i_o = (((L.l_G).l_registry));
		  i_o.value.gc = ((union GCObject)(luaH_new(L, 0, 2)));
		  i_o.tt = DefineConstants.LUA_TTABLE;
		  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
  }; // registry
	  luaS_resize(L, DefineConstants.MINSTRTABSIZE); // initial size of string table
	  luaT_init(L);
	  luaX_init(L);
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: ((((luaS_newlstr(L, "" DefineConstants.MEMERRMSG, (sizeof(DefineConstants.MEMERRMSG)/sizeof(sbyte))-1)))->tsv.marked) |= ((1<<(DefineConstants.FIXEDBIT))));
	  (((luaS_newlstr(L, "" DefineConstants.MEMERRMSG, (DefineConstants.MEMERRMSG.Length) - 1)).tsv.marked) |= ((1 << (DefineConstants.FIXEDBIT))));
	  g.GCthreshold = 4 * g.totalbytes;
	}


	internal static void preinit_state(lua_State L, global_State g)
	{
	  (L.l_G) = g;
	  L.stack = null;
	  L.stacksize = 0;
	  L.errorJmp = null;
	  L.hook = null;
	  L.hookmask = 0;
	  L.basehookcount = 0;
	  L.allowhook = 1;
	  (L.hookcount = L.basehookcount);
	  L.openupval = null;
	  L.size_ci = 0;
	  L.nCcalls = L.baseCcalls = 0;
	  L.status = 0;
	  L.base_ci = L.ci = null;
	  L.savedpc = null;
	  L.errfunc = 0;
	  (((L.l_gt)).tt = DefineConstants.LUA_TNIL);
	}


	internal static void close_state(lua_State L)
	{
	  global_State g = (L.l_G);
	  luaF_close(L, L.stack); // close all upvalues for this thread
	  luaC_freeall(L); // collect all objects
	  (c)(0)(g.rootgc == (((union GCObject)((L)))));
	  (c)(0)(g.strt.nuse == 0);
	  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(TString))) ? luaM_realloc_(L, (((L.l_G).strt.hash)), ((L.l_G).strt.size) * (sizeof(TString)), (0) * (sizeof(TString))) : luaM_toobig(L));
	  ((((g.buff).buffer) = ((string)(((cast(size_t, (0) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(sbyte))) ? luaM_realloc_(L, ((g.buff).buffer), ((g.buff).buffsize) * (sizeof(sbyte)), (0) * (sizeof(sbyte))) : luaM_toobig(L))))), (g.buff).buffsize = 0);
	  freestack(L, L);
	  (c)(0)(g.totalbytes == sizeof(LG));
	  g.frealloc(g.ud, (((byte)((L))) - DefineConstants.LUAI_EXTRASPACE), (sizeof(LG) + DefineConstants.LUAI_EXTRASPACE), 0);
	}


	public static lua_State lua_newstate(lua_Alloc f, object ud)
	{
	  int i;
	  lua_State L;
	  global_State g;
	  object l = f(ud, null, 0, (sizeof(LG) + DefineConstants.LUAI_EXTRASPACE));
	  if (l == null)
	  {
		  return null;
	  }
	  L = (((lua_State)(((byte)(l)) + DefineConstants.LUAI_EXTRASPACE)));
	  g = ((LG)L).g;
	  L.next = null;
	  L.tt = DefineConstants.LUA_TTHREAD;
	  g.currentwhite = ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.FIXEDBIT)));
	  L.marked = ((byte)((g).currentwhite & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))));
	  ((L.marked) |= ((((1 << (DefineConstants.FIXEDBIT)) | (1 << (DefineConstants.SFIXEDBIT))))));
	  preinit_state(L, g);
	  g.frealloc = f;
	  g.ud = ud;
	  g.mainthread = L;
	  g.uvhead.u.l.prev = g.uvhead;
	  g.uvhead.u.l.next = g.uvhead;
	  g.GCthreshold = 0; // mark it as unfinished state
	  g.strt.size = 0;
	  g.strt.nuse = 0;
	  g.strt.hash = null;
	  ((((L.l_G).l_registry)).tt = DefineConstants.LUA_TNIL);
	  ((g.buff).buffer = null, (g.buff).buffsize = 0);
	  g.panic = null;
	  g.gcstate = DefineConstants.GCSpause;
	  g.rootgc = (((union GCObject)((L))));
	  g.sweepstrgc = 0;
	  g.sweepgc = g.rootgc;
	  g.gray = null;
	  g.grayagain = null;
	  g.weak = null;
	  g.tmudata = null;
	  g.totalbytes = sizeof(LG);
	  g.gcpause = DefineConstants.LUAI_GCPAUSE;
	  g.gcstepmul = DefineConstants.LUAI_GCMUL;
	  g.gcdept = 0;
	  for (i = 0; i < (DefineConstants.LUA_TTHREAD + 1); i++)
	  {
		  g.mt[i] = null;
	  }
	  if (luaD_rawrunprotected(L, f_luaopen, null) != 0)
	  {
		/* memory allocation error: free partial state */
		close_state(L);
		L = null;
	  }
	  else
	  {
		(L);
	  }
	  return L;
	}


	internal static void callallgcTM(lua_State L, object ud)
	{
	  ((ud));
	  luaC_callGCTM(L); // call GC metamethods for all udata
	}


	public static void lua_close(lua_State L)
	{
	  L = (L.l_G).mainthread; // only the main thread can be closed
	  (L)(0)(L);
	  luaF_close(L, L.stack); // close all upvalues for this thread
	  luaC_separateudata(L, 1); // separate udata that have GC metamethods
	  L.errfunc = 0; // no error function during GC metamethods
	  do
	  { // repeat until no more errors
		L.ci = L.base_ci;
		L.@base = L.top = L.ci.@base;
		L.nCcalls = L.baseCcalls = 0;
	  } while (luaD_rawrunprotected(L, callallgcTM, null) != 0);
	  (c)(0)((L.l_G).tmudata == null);
	  (L);
	  close_state(L);
	}


	/*
	** $Id: lstring.c,v 2.8.1.1 2007/12/27 13:02:25 roberto Exp $
	** String table (keeps all strings handled by Lua)
	** See Copyright Notice in lua.h
	*/




//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DYLD
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_VARARG
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_MOD
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_LSTR
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_OPENLIB
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DLOPEN
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DLL
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_SIZET ((size_t)(~(size_t)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_LUMEM ((lu_mem)(~(lu_mem)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_INT (INT_MAX-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IntPoint(p) ((unsigned int)(lu_mem)(p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (lua_assert(c), (e))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check(l,e) lua_assert(e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(c) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check luai_apicheck
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define UNUSED(x) ((void)(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast(t, exp) ((t)(exp))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_byte(i) cast(lu_byte, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_num(i) cast(lua_Number, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_int(i) cast(int, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_lock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unlock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_threadyield(L) {lua_unlock(L); lua_lock(L);}
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) x
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocv(L,b,on,n,e) ((cast(size_t, (n)+1) <= MAX_SIZET/(e)) ? luaM_realloc_(L, (b), (on)*(e), (n)*(e)) : luaM_toobig(L))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freemem(L, b, s) luaM_realloc_(L, (b), (s), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_free(L, b) luaM_realloc_(L, (b), sizeof(*(b)), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freearray(L, b, n, t) luaM_reallocv(L, (b), n, 0, sizeof(t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_malloc(L,t) luaM_realloc_(L, NULL, 0, (t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_new(L,t) cast(t *, luaM_malloc(L, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_newvector(L,n,t) cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_growvector(L,v,nelems,size,t,limit,e) if ((nelems)+1 > (size)) ((v)=cast(t *, luaM_growaux_(L,v,&(size),sizeof(t),limit,e)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocvector(L, v,oldn,n,t) ((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LAST_TAG LUA_TTHREAD
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NUM_TAGS (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TPROTO (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TUPVAL (LAST_TAG+2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TDEADKEY (LAST_TAG+3)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define CommonHeader GCObject *next; lu_byte tt; lu_byte marked
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define TValuefields Value value; int tt
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnil(o) (ttype(o) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnumber(o) (ttype(o) == LUA_TNUMBER)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisstring(o) (ttype(o) == LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttistable(o) (ttype(o) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisfunction(o) (ttype(o) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisboolean(o) (ttype(o) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisuserdata(o) (ttype(o) == LUA_TUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisthread(o) (ttype(o) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttislightuserdata(o) (ttype(o) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttype(o) ((o)->tt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gcvalue(o) check_exp(iscollectable(o), (o)->value.gc)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pvalue(o) check_exp(ttislightuserdata(o), (o)->value.p)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define nvalue(o) check_exp(ttisnumber(o), (o)->value.n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawtsvalue(o) check_exp(ttisstring(o), &(o)->value.gc->ts)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define tsvalue(o) (&rawtsvalue(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawuvalue(o) check_exp(ttisuserdata(o), &(o)->value.gc->u)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define uvalue(o) (&rawuvalue(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define clvalue(o) check_exp(ttisfunction(o), &(o)->value.gc->cl)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define hvalue(o) check_exp(ttistable(o), &(o)->value.gc->h)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bvalue(o) check_exp(ttisboolean(o), (o)->value.b)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define thvalue(o) check_exp(ttisthread(o), &(o)->value.gc->th)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_isfalse(o) (ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkconsistency(obj) lua_assert(!iscollectable(obj) || (ttype(obj) == (obj)->value.gc->gch.tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkliveness(g,obj) lua_assert(!iscollectable(obj) || ((ttype(obj) == (obj)->value.gc->gch.tt) && !isdead(g, (obj)->value.gc)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnilvalue(obj) ((obj)->tt=LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnvalue(obj,x) { TValue *i_o=(obj); i_o->value.n=(x); i_o->tt=LUA_TNUMBER; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setpvalue(obj,x) { TValue *i_o=(obj); i_o->value.p=(x); i_o->tt=LUA_TLIGHTUSERDATA; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbvalue(obj,x) { TValue *i_o=(obj); i_o->value.b=(x); i_o->tt=LUA_TBOOLEAN; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TSTRING; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setuvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TUSERDATA; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setthvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTHREAD; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setclvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TFUNCTION; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTABLE; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TPROTO; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj(L,obj1,obj2) { const TValue *o2=(obj2); TValue *o1=(obj1); o1->value = o2->value; o1->tt=o2->tt; checkliveness(G(L),o1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjs2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2s setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue2s sethvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue2s setptvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjt2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2n setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2n setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setttype(obj, tt) (ttype(obj) = (tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscollectable(o) (ttype(o) >= LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getstr(ts) cast(const char *, (ts) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define svalue(o) getstr(rawtsvalue(o))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ClosureHeader CommonHeader; lu_byte isC; lu_byte nupvalues; GCObject *gclist; struct Table *env
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscfunction(o) (ttype(o) == LUA_TFUNCTION && clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLfunction(o) (ttype(o) == LUA_TFUNCTION && !clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lmod(s,size) (check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define twoto(x) (1<<(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizenode(t) (twoto((t)->lsizenode))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaO_nilobject (&luaO_nilobject_)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ceillog2(x) (luaO_log2((x)-1) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gfasttm(g,et,e) ((et) == NULL ? NULL : ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define fasttm(l,et,e) gfasttm(G(l), et, e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define char2int(c) cast(int, cast(unsigned char, (c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define zgetc(z) (((z)->n--)>0 ? char2int(*(z)->p++) : luaZ_fill(z))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_buffer(buff) ((buff)->buffer)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_sizebuffer(buff) ((buff)->buffsize)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_bufflen(buff) ((buff)->n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resetbuffer(buff) ((buff)->n = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resizebuffer(L, buff, size) (luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), (buff)->buffsize = size)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_freebuffer(L, buff) luaZ_resizebuffer(L, buff, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gt(L) (&L->l_gt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define registry(L) (&G(L)->l_registry)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BASIC_STACK_SIZE (2*LUA_MINSTACK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define curr_func(L) (clvalue(L->ci->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ci_func(ci) (clvalue((ci)->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define f_isLua(ci) (!ci_func(ci)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLua(ci) (ttisfunction((ci)->func) && f_isLua(ci))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define G(L) (L->l_G)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2ts(o) check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2ts(o) (&rawgco2ts(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2u(o) check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2u(o) (&rawgco2u(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2cl(o) check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2h(o) check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2p(o) check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2uv(o) check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ngcotouv(o) check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2th(o) check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define obj2gco(v) (cast(GCObject *, (v)))
	/*
	** $Id: lstring.h,v 1.43.1.1 2007/12/27 13:02:25 roberto Exp $
	** String table (keep all strings handled by Lua)
	** See Copyright Notice in lua.h
	*/



	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbits(x,m) ((x) &= cast(lu_byte, ~(m)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbits(x,m) ((x) |= (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbits(x,m) ((x) & (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bitmask(b) (1<<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bit2mask(b1,b2) (bitmask(b1) | bitmask(b2))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_setbit(x,b) setbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbit(x,b) resetbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbit(x,b) testbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define set2bits(x,b1,b2) setbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define reset2bits(x,b1,b2) resetbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define test2bits(x,b1,b2) testbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define WHITEBITS bit2mask(WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iswhite(x) test2bits((x)->gch.marked, WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isblack(x) testbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isgray(x) (!isblack(x) && !iswhite(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define otherwhite(g) (g->currentwhite ^ WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isdead(g,v) ((v)->gch.marked & otherwhite(g) & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define changewhite(x) ((x)->gch.marked ^= WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gray2black(x) l_setbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define valiswhite(x) (iscollectable(x) && iswhite(gcvalue(x)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_white(g) cast(lu_byte, (g)->currentwhite & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_checkGC(L) { condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1)); if (G(L)->totalbytes >= G(L)->GCthreshold) luaC_step(L); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),gcvalue(v)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barriert(L,t,v) { if (valiswhite(v) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarrier(L,p,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),obj2gco(o)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarriert(L,t,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(t))) luaC_barrierback(L,t); }


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizestring(s) (sizeof(union TString)+((s)->len+1)*sizeof(char))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeudata(u) (sizeof(union Udata)+(u)->len)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_new(L, s) (luaS_newlstr(L, s, strlen(s)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_newliteral(L, s) (luaS_newlstr(L, "" s, (sizeof(s)/sizeof(char))-1))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_fix(s) l_setbit((s)->tsv.marked, FIXEDBIT)

	public static void luaS_resize(lua_State L, int newsize)
	{
	  GCObject[] newhash;
	  stringtable tb;
	  int i;
	  if ((L.l_G).gcstate == DefineConstants.GCSsweepstring)
	  {
		return; // cannot resize during GC traverse
	  }
	  newhash = ((union GCObject)(((cast(size_t, (newsize) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(GCObject))) ? luaM_realloc_(L, (null), (0) * (sizeof(GCObject)), (newsize) * (sizeof(GCObject))) : luaM_toobig(L))));
	  tb = (L.l_G).strt;
	  for (i = 0; i < newsize; i++)
	  {
		  newhash[i] = null;
	  }
	  /* rehash */
	  for (i = 0; i < tb.size; i++)
	  {
		GCObject[] p = tb.hash[i];
		while (p != null)
		{ // for each node in the list
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: union GCObject *next = p->gch.next;
		  GCObject[] next = new GCObject(p.gch.next); // save next
		  uint h = (check_exp((p).gch.tt == DefineConstants.LUA_TSTRING, ((p).ts)).tsv).hash;
		  int h1 = (check_exp((newsize & (newsize-1)) == 0, (((int)((h) & ((newsize) - 1)))))); // new position
		  (c)(0)(((int)((h % newsize))) == (check_exp((newsize & (newsize-1)) == 0, (((int)((h) & ((newsize) - 1)))))));
		  p.gch.next = newhash[h1]; // chain it
		  newhash[h1] = p;
		  p = next;
		}
	  }
	  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(TString))) ? luaM_realloc_(L, ((tb.hash)), (tb.size) * (sizeof(TString)), (0) * (sizeof(TString))) : luaM_toobig(L));
	  tb.size = newsize;
	  tb.hash = newhash;
	}
	public static Udata luaS_newudata(lua_State L, size_t s, Table e)
	{
	  Udata u;
	  if (s > ((size_t)(~(size_t)0) - 2) - sizeof(Udata))
	  {
		luaM_toobig(L);
	  }
	  u = ((Udata)(luaM_realloc_(L, null, 0, (s + sizeof(Udata)))));
	  u.uv.marked = ((byte)(((L.l_G)).currentwhite & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))); // is not finalized
	  u.uv.tt = DefineConstants.LUA_TUSERDATA;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: u->uv.len = s;
	  u.uv.len.CopyFrom(s);
	  u.uv.metatable = null;
	  u.uv.env = e;
	  /* chain it on udata list (after main thread) */
	  u.uv.next = (L.l_G).mainthread.next;
	  (L.l_G).mainthread.next = (((union GCObject)((u))));
	  return u;
	}
	public static TString luaS_newlstr(lua_State L, string str, size_t l)
	{
	  GCObject o;
	  uint h = ((uint)(l)); // seed
	  size_t step = (l >> 5) + 1; // if string is too long, don't hash all its chars
	  size_t l1 = new size_t();
	  for (l1 = l; l1 >= step; l1 -= step) // compute hash
	  {
		h = h ^ ((h << 5) + (h>>2) + ((byte)(str[l1 - 1])));
	  }
	  for (o = (L.l_G).strt.hash[(check_exp(((L.l_G).strt.size & ((L.l_G).strt.size-1)) == 0, (((int)((h) & (((L.l_G).strt.size) - 1))))))]; o != null; o = o.gch.next)
	  {
		TString ts = check_exp((o).gch.tt == DefineConstants.LUA_TSTRING, ((o).ts));
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcmp' has no equivalent in C#:
		if (ts.tsv.len == l && (memcmp(str, ((string)((ts) + 1)), l) == 0))
		{
		  /* string may be dead */
		  if ((((o).gch.marked & ((L.l_G).currentwhite ^ WHITEBITS) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))) != 0)
		  {
			  ((o).gch.marked ^= ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))));
		  }
		  return ts;
		}
	  }
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: return newlstr(L, str, l, h);
	  return newlstr(L, str, new size_t(l), h); // not found
	}


	internal static TString newlstr(lua_State L, string str, size_t l, uint h)
	{
	  TString ts;
	  stringtable tb;
	  if (l + 1 > (((size_t)(~(size_t)0) - 2) - sizeof(TString)) / sizeof(sbyte) != null)
	  {
		luaM_toobig(L);
	  }
	  ts = ((TString)(luaM_realloc_(L, null, 0, ((l + 1) * sizeof(sbyte) + sizeof(TString)))));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: ts->tsv.len = l;
	  ts.tsv.len.CopyFrom(l);
	  ts.tsv.hash = h;
	  ts.tsv.marked = ((byte)(((L.l_G)).currentwhite & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))));
	  ts.tsv.tt = DefineConstants.LUA_TSTRING;
	  ts.tsv.reserved = 0;
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(ts + 1, str, l * sizeof(sbyte));
	  ((string)(ts + 1))[l] = '\0'; // ending 0
	  tb = (L.l_G).strt;
	  h = (check_exp((tb.size & (tb.size-1)) == 0, (((int)((h) & ((tb.size) - 1))))));
	  ts.tsv.next = tb.hash[h]; // chain new entry
	  tb.hash[h] = (((union GCObject)((ts))));
	  tb.nuse++;
	  if (tb.nuse > ((LUAI_UINT32)(tb.size)) && tb.size <= (INT_MAX - 2) / 2)
	  {
		luaS_resize(L, tb.size * 2); // too crowded
	  }
	  return ts;
	}


	/*
	** $Id: lstrlib.c,v 1.132.1.4 2008/07/11 17:27:21 roberto Exp $
	** Standard library for string operations and pattern-matching
	** See Copyright Notice in lua.h
	*/




//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DYLD
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_VARARG
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_MOD
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_LSTR
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_OPENLIB
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DLOPEN
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DLL
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getn(L,i) ((int)lua_objlen(L, i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_setn(L,i,j) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaI_openlib luaL_openlib
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_ERRFILE (LUA_ERRERR+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_argcheck(L, cond,numarg,extramsg) ((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkstring(L,n) (luaL_checklstring(L, (n), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optstring(L,n,d) (luaL_optlstring(L, (n), (d), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkint(L,n) ((int)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optint(L,n,d) ((int)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checklong(L,n) ((long)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optlong(L,n,d) ((long)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_typename(L,i) lua_typename(L, lua_type(L,(i)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dofile(L, fn) (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dostring(L, s) (luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getmetatable(L,n) (lua_getfield(L, LUA_REGISTRYINDEX, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_opt(L,f,n,d) (lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addchar(B,c) ((void)((B)->p < ((B)->buffer+LUAL_BUFFERSIZE) || luaL_prepbuffer(B)), (*(B)->p++ = (char)(c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_putchar(B,c) luaL_addchar(B,c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addsize(B,n) ((B)->p += (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_ref(L,lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : (lua_pushstring(L, "unlocked references are obsolete"), lua_error(L), 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unref(L,ref) luaL_unref(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getref(L,ref) lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_reg luaL_Reg
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(x) ((void)0)


	/* macro to `unsign' a character */
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define uchar(c) ((unsigned char)(c))



	internal static int str_len(lua_State L)
	{
	  size_t l = new size_t();
	  luaL_checklstring(L, 1, l);
	  lua_pushinteger(L, l);
	  return 1;
	}


	internal static ptrdiff_t posrelat(ptrdiff_t pos, size_t len)
	{
	  /* relative string position: negative means back from end */
	  if (pos < 0)
	  {
		  pos += (ptrdiff_t)len + 1;
	  }
	  return (pos >= 0) ? pos : 0;
	}


	internal static int str_sub(lua_State L)
	{
	  size_t l = new size_t();
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *s = luaL_checklstring(L, 1, &l);
	  sbyte s = luaL_checklstring(L, 1, l);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: ptrdiff_t start = posrelat(luaL_checkinteger(L, 2), l);
	  ptrdiff_t start = posrelat(luaL_checkinteger(L, 2), new size_t(l));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: ptrdiff_t end = posrelat(luaL_optinteger(L, 3, -1), l);
	  ptrdiff_t end = posrelat(luaL_optinteger(L, 3, -1), new size_t(l));
	  if (start < 1)
	  {
		  start = 1;
	  }
	  if (end > (ptrdiff_t)l)
	  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: end = (ptrdiff_t)l;
		  end.CopyFrom((ptrdiff_t)l);
	  }
	  if (start <= end)
	  {
		lua_pushlstring(L, s + start - 1, end - start + 1);
	  }
	  else
	  {
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "", (sizeof("")/sizeof(sbyte))-1);
		  lua_pushlstring(L, "" "", (("").Length) - 1);
	  }
	  return 1;
	}


	internal static int str_reverse(lua_State L)
	{
	  size_t l = new size_t();
	  luaL_Buffer b = new luaL_Buffer();
	  sbyte[] s = luaL_checklstring(L, 1, l);
	  luaL_buffinit(L, b);
	  while (l-- != null)
	  {
		  (((b).p < ((b).buffer + BUFSIZ) || luaL_prepbuffer(b)), (*(b).p ++= (sbyte)(s[l])));
	  }
	  luaL_pushresult(b);
	  return 1;
	}


	internal static int str_lower(lua_State L)
	{
	  size_t l = new size_t();
	  size_t i = new size_t();
	  luaL_Buffer b = new luaL_Buffer();
	  sbyte[] s = luaL_checklstring(L, 1, l);
	  luaL_buffinit(L, b);
	  for (i = 0; i < l; i++)
	  {
		(((b).p < ((b).buffer + BUFSIZ) || luaL_prepbuffer(b)), (*(b).p ++= (sbyte)(tolower(((byte)(s[i]))))));
	  }
	  luaL_pushresult(b);
	  return 1;
	}


	internal static int str_upper(lua_State L)
	{
	  size_t l = new size_t();
	  size_t i = new size_t();
	  luaL_Buffer b = new luaL_Buffer();
	  sbyte[] s = luaL_checklstring(L, 1, l);
	  luaL_buffinit(L, b);
	  for (i = 0; i < l; i++)
	  {
		(((b).p < ((b).buffer + BUFSIZ) || luaL_prepbuffer(b)), (*(b).p ++= (sbyte)(toupper(((byte)(s[i]))))));
	  }
	  luaL_pushresult(b);
	  return 1;
	}

	internal static int str_rep(lua_State L)
	{
	  size_t l = new size_t();
	  luaL_Buffer b = new luaL_Buffer();
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *s = luaL_checklstring(L, 1, &l);
	  sbyte s = luaL_checklstring(L, 1, l);
	  int n = ((int)luaL_checkinteger(L, (2)));
	  luaL_buffinit(L, b);
	  while (n-- > 0)
	  {
		luaL_addlstring(b, s, l);
	  }
	  luaL_pushresult(b);
	  return 1;
	}


	internal static int str_byte(lua_State L)
	{
	  size_t l = new size_t();
	  sbyte[] s = luaL_checklstring(L, 1, l);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: ptrdiff_t posi = posrelat(luaL_optinteger(L, 2, 1), l);
	  ptrdiff_t posi = posrelat(luaL_optinteger(L, 2, 1), new size_t(l));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: ptrdiff_t pose = posrelat(luaL_optinteger(L, 3, posi), l);
	  ptrdiff_t pose = posrelat(luaL_optinteger(L, 3, posi), new size_t(l));
	  int n;
	  int i;
	  if (posi <= 0)
	  {
		  posi = 1;
	  }
	  if ((size_t)pose > l)
	  {
		  pose = l;
	  }
	  if (posi > pose)
	  {
		  return 0; // empty interval; return no values
	  }
	  n = (int)(pose - posi + 1);
	  if (posi + n <= pose != null) // overflow?
	  {
		luaL_error(L, "string slice too long");
	  }
	  luaL_checkstack(L, n, "string slice too long");
	  for (i = 0; i < n; i++)
	  {
		lua_pushinteger(L, ((byte)(s[posi + i - 1])));
	  }
	  return n;
	}


	internal static int str_char(lua_State L)
	{
	  int n = lua_gettop(L); // number of arguments
	  int i;
	  luaL_Buffer b = new luaL_Buffer();
	  luaL_buffinit(L, b);
	  for (i = 1; i <= n; i++)
	  {
		int c = ((int)luaL_checkinteger(L, (i)));
		(((((byte)(c)) == c) || luaL_argerror(L, (i), ("invalid value"))));
		(((b).p < ((b).buffer + BUFSIZ) || luaL_prepbuffer(b)), (*(b).p ++= (sbyte)(((byte)(c)))));
	  }
	  luaL_pushresult(b);
	  return 1;
	}


	internal static int writer(lua_State L, object b, size_t size, object B)
	{
	  L;
	  luaL_addlstring((luaL_Buffer) B, (string)b, size);
	  return 0;
	}


	internal static int str_dump(lua_State L)
	{
	  luaL_Buffer b = new luaL_Buffer();
	  luaL_checktype(L, 1, DefineConstants.LUA_TFUNCTION);
	  lua_settop(L, 1);
	  luaL_buffinit(L, b);
	  if (lua_dump(L, writer, b) != 0)
	  {
		luaL_error(L, "unable to dump given function");
	  }
	  luaL_pushresult(b);
	  return 1;
	}




	internal static int check_capture(MatchState ms, int l)
	{
	  l -= '1';
	  if (l < 0 || l >= ms.level != 0 || ms.capture[l].len == DefineConstants.CAP_UNFINISHED)
	  {
		return luaL_error(ms.L, "invalid capture index");
	  }
	  return l;
	}


	internal static int capture_to_close(MatchState ms)
	{
	  int level = ms.level;
	  for (level--; level >= 0; level--)
	  {
		if (ms.capture[level].len == DefineConstants.CAP_UNFINISHED)
		{
			return level;
		}
	  }
	  return luaL_error(ms.L, "invalid pattern capture");
	}


//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'p', so pointers on this parameter are left unchanged:
	internal static string classend(MatchState ms, sbyte * p)
	{
	  switch (*p++)
	  {
		case DefineConstants.L_ESC:
		{
		  if (*p == (sbyte)'\0')
		  {
			luaL_error(ms.L, "malformed pattern (ends with " "'" "%%" "'" ")");
		  }
		  return p.Substring(1);
		}
		case '[':
		{
		  if (*p == (sbyte)'^')
		  {
			  p = p.Substring(1);
		  }
		  do
		  { // look for a `]'
			if (*p == (sbyte)'\0')
			{
			  luaL_error(ms.L, "malformed pattern (missing " "'" "]" "'" ")");
			}
			if (*(p++) == DefineConstants.L_ESC && *p != (sbyte)'\0')
			{
			  p = p.Substring(1); // skip escapes (e.g. `%]')
			}
		  } while (*p != (sbyte)']');
		  return p.Substring(1);
		}
		default:
		{
		  return p;
		}
	  }
	}


	internal static int match_class(int c, int cl)
	{
	  int res;
	  switch (tolower(cl))
	  {
		case 'a' :
			res = isalpha(c);
			break;
		case 'c' :
			res = iscntrl(c);
			break;
		case 'd' :
			res = isdigit(c);
			break;
		case 'l' :
			res = islower(c);
			break;
		case 'p' :
			res = ispunct(c);
			break;
		case 's' :
			res = isspace(c);
			break;
		case 'u' :
			res = isupper(c);
			break;
		case 'w' :
			res = isalnum(c);
			break;
		case 'x' :
			res = StringFunctions.IsXDigit(c);
			break;
		case 'z' :
			res = (c == 0);
			break;
		default:
			return (cl == c);
	  }
	  return (islower(cl) ? res : res == 0);
	}


//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'p', so pointers on this parameter are left unchanged:
	internal static int matchbracketclass(int c, sbyte * p, string ec)
	{
	  int sig = 1;
	  if (*(p.Substring(1)) == '^')
	  {
		sig = 0;
		p = p.Substring(1); // skip the `^'
	  }
	  while (++p < ec)
	  {
		if (*p == DefineConstants.L_ESC)
		{
		  p = p.Substring(1);
		  if (match_class(c, ((byte)(*p))) != 0)
		  {
			return sig;
		  }
		}
		else if ((*(p.Substring(1)) == '-') && (p.Substring(2) < ec))
		{
		  p += 2;
		  if (((byte)(*(p - 2))) <= c != 0 && c <= ((byte)(*p)))
		  {
			return sig;
		  }
		}
		else if (((byte)(*p)) == c)
		{
			return sig;
		}
	  }
	  return sig == 0;
	}


	internal static int singlematch(int c, string p, string ep)
	{
	  switch (p)
	  {
		case '.':
			return 1; // matches any char
		case DefineConstants.L_ESC:
			return match_class(c, ((byte)(*(p.Substring(1)))));
		case '[':
			return matchbracketclass(c, p, ep - 1);
		default:
			return (((byte)(p)) == c);
	  }
	}


//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 's', so pointers on this parameter are left unchanged:
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'p', so pointers on this parameter are left unchanged:
	internal static string match(MatchState ms, sbyte * s, sbyte * p)
	{
	  init: // using goto's to optimize tail recursion
	  switch (*p)
	  {
		case '(':
		{ // start capture
		  if (*(p.Substring(1)) == ')') // position capture?
		  {
			return start_capture(ms, s, p.Substring(2), DefineConstants.CAP_POSITION);
		  }
		  else
		  {
			return start_capture(ms, s, p.Substring(1), DefineConstants.CAP_UNFINISHED);
		  }
		}
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		case ')':
		{ // end capture
		  return end_capture(ms, s, p.Substring(1));
		}
		case DefineConstants.L_ESC:
		{
		  switch (*(p.Substring(1)))
		  {
			case 'b':
			{ // balanced string?
			  s = matchbalance(ms, s, p.Substring(2));
			  if (s == null)
			  {
				  return null;
			  }
			  p += 4;
			  goto init; // else return match(ms, s, p+4);
			}
			case 'f':
			{ // frontier?
			  string ep;
			  sbyte previous;
			  p += 2;
			  if (*p != (sbyte)'[')
			  {
				luaL_error(ms.L, "missing " "'" "[" "'" " after " "'" "%%f" "'" " in pattern");
			  }
			  ep = classend(ms, p); // points to what is next
			  previous = (s == ms.src_init) ? '\0' : *(s - 1);
			  if (matchbracketclass(((byte)(previous)), p, ep - 1) != 0 || matchbracketclass(((byte)(*s)), p, ep - 1) == 0)
			  {
				  return null;
			  }
			  p = ep;
			  goto init; // else return match(ms, s, ep);
			}
			default:
			{
			  if (isdigit(((byte)(*(p.Substring(1))))))
			  { // capture results (%0-%9)?
				s = match_capture(ms, s, ((byte)(*(p.Substring(1)))));
				if (s == null)
				{
					return null;
				}
				p += 2;
				goto init; // else return match(ms, s, p+2)
			  }
			  goto dflt; // case default
			}
		  }
		}
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		case '\0':
		{ // end of pattern
		  return s; // match succeeded
		}
		case '$':
		{
		  if (*(p.Substring(1)) == '\0') // is the `$' the last char in pattern?
		  {
			return (s == ms.src_end) ? s : null; // check end of string
		  }
		  else
		  {
			  goto dflt;
		  }
		}
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		default:
			dflt:
			{ // it is a pattern item
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *ep = classend(ms, p);
		  sbyte ep = classend(ms, p); // points to what is next
		  int m = s < ms.src_end && singlematch(((byte)(*s)), p, ep) != 0;
		  switch (ep)
		  {
			case '?':
			{ // optional
			  string res;
			  if (m != 0 && ((res = match(ms, s.Substring(1), ep + 1)) != null))
			  {
				return res;
			  }
			  p = ep + 1;
			  goto init; // else return match(ms, s, ep+1);
			}
			case '*':
			{ // 0 or more repetitions
			  return max_expand(ms, s, p, ep);
			}
			case '+':
			{ // 1 or more repetitions
			  return (m != 0 ? max_expand(ms, s.Substring(1), p, ep) : null);
			}
			case '-':
			{ // 0 or more repetitions (minimum)
			  return min_expand(ms, s, p, ep);
			}
			default:
			{
			  if (m == 0)
			  {
				  return null;
			  }
			  s = s.Substring(1);
			  p = ep;
			  goto init; // else return match(ms, s+1, ep);
			}
		  }
			}
	break;
	  }
	}


//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 's', so pointers on this parameter are left unchanged:
	internal static string matchbalance(MatchState ms, sbyte * s, string p)
	{
	  if (p == 0 || *(p.Substring(1)) == 0)
	  {
		luaL_error(ms.L, "unbalanced pattern");
	  }
	  if (*s != p)
	  {
		  return null;
	  }
	  else
	  {
		int b = p;
		int e = (p.Substring(1));
		int cont = 1;
		while (++s < ms.src_end)
		{
		  if (*s == e)
		  {
			if (--cont == 0)
			{
				return s.Substring(1);
			}
		  }
		  else if (*s == b)
		  {
			  cont++;
		  }
		}
	  }
	  return null; // string ends out of balance
	}


	internal static string max_expand(MatchState ms, string s, string p, string ep)
	{
	  ptrdiff_t i = 0; // counts maximum expand for item
	  while ((s + i) < ms.src_end && singlematch(((byte)(*(s + i))), p, ep) != 0)
	  {
		i++;
	  }
	  /* keeps trying to match with the maximum repetitions */
	  while (i >= 0)
	  {
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *res = match(ms, (s+i), ep+1);
		sbyte res = match(ms, (s + i), ep.Substring(1));
		if (res != 0)
		{
			return res;
		}
		i--; // else didn't match; reduce 1 repetition to try again
	  }
	  return null;
	}


//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 's', so pointers on this parameter are left unchanged:
	internal static string min_expand(MatchState ms, sbyte * s, string p, string ep)
	{
	  for (;;)
	  {
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *res = match(ms, s, ep+1);
		sbyte res = match(ms, s, ep.Substring(1));
		if (res != null)
		{
		  return res;
		}
		else if (s < ms.src_end && singlematch(((byte)(*s)), p, ep) != 0)
		{
		  s = s.Substring(1); // try with one more repetition
		}
		else
		{
			return null;
		}
	  }
	}


	internal static string start_capture(MatchState ms, string s, string p, int what)
	{
	  string res;
	  int level = ms.level;
	  if (level >= DefineConstants.LUA_MAXCAPTURES)
	  {
		  luaL_error(ms.L, "too many captures");
	  }
	  ms.capture[level].init = s;
	  ms.capture[level].len = what;
	  ms.level = level + 1;
	  if ((res = match(ms, s, p)) == null) // match failed?
	  {
		ms.level--; // undo capture
	  }
	  return res;
	}


	internal static string end_capture(MatchState ms, string s, string p)
	{
	  int l = capture_to_close(ms);
	  string res;
	  ms.capture[l].len = s - ms.capture[l].init; // close capture
	  if ((res = match(ms, s, p)) == null) // match failed?
	  {
		ms.capture[l].len = DefineConstants.CAP_UNFINISHED; // undo capture
	  }
	  return res;
	}


	internal static string match_capture(MatchState ms, string s, int l)
	{
	  size_t len = new size_t();
	  l = check_capture(ms, l);
	  len = ms.capture[l].len;
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcmp' has no equivalent in C#:
	  if ((size_t)(ms.src_end - s) >= len != null && memcmp(ms.capture[l].init, s, len) == 0)
	  {
		return s + len;
	  }
	  else
	  {
		  return null;
	  }
	}



	internal static string lmemfind(string s1, size_t l1, string s2, size_t l2)
	{
	  if (l2 == 0)
	  {
		  return s1; // empty strings are everywhere
	  }
	  else if (l2 > l1)
	  {
		  return null; // avoids a negative `l1'
	  }
	  else
	  {
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
		sbyte * init; // to search for a `*s2' inside `s1'
		l2--; // 1st char will be checked by `memchr'
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: l1 = l1-l2;
		l1.CopyFrom(l1 - l2); // `s2' cannot be found after that
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memchr' has no equivalent in C#:
		while (l1 > 0 && (init = (string)memchr(s1, s2, l1)) != null)
		{
		  init++; // 1st char is already checked
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcmp' has no equivalent in C#:
		  if (memcmp(init, s2.Substring(1), l2) == 0)
		  {
			return init - 1;
		  }
		  else
		  { // correct `l1' and `s1' to try again
			l1 -= init - s1;
			s1 = init;
		  }
		}
		return null; // not found
	  }
	}


	internal static void push_onecapture(MatchState ms, int i, string s, string e)
	{
	  if (i >= ms.level)
	  {
		if (i == 0) // ms->level == 0, too
		{
		  lua_pushlstring(ms.L, s, e - s); // add whole match
		}
		else
		{
		  luaL_error(ms.L, "invalid capture index");
		}
	  }
	  else
	  {
		ptrdiff_t l = ms.capture[i].len;
		if (l == DefineConstants.CAP_UNFINISHED)
		{
			luaL_error(ms.L, "unfinished capture");
		}
		if (l == DefineConstants.CAP_POSITION)
		{
		  lua_pushinteger(ms.L, ms.capture[i].init - ms.src_init.Substring(1));
		}
		else
		{
		  lua_pushlstring(ms.L, ms.capture[i].init, l);
		}
	  }
	}


	internal static int push_captures(MatchState ms, string s, string e)
	{
	  int i;
	  int nlevels = (ms.level == 0 && s != 0) ? 1 : ms.level;
	  luaL_checkstack(ms.L, nlevels, "too many captures");
	  for (i = 0; i < nlevels; i++)
	  {
		push_onecapture(ms, i, s, e);
	  }
	  return nlevels; // number of strings pushed
	}


	internal static int str_find_aux(lua_State L, int find)
	{
	  size_t l1 = new size_t();
	  size_t l2 = new size_t();
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *s = luaL_checklstring(L, 1, &l1);
	  sbyte s = luaL_checklstring(L, 1, l1);
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *p = luaL_checklstring(L, 2, &l2);
	  sbyte p = luaL_checklstring(L, 2, l2);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: ptrdiff_t init = posrelat(luaL_optinteger(L, 3, 1), l1) - 1;
	  ptrdiff_t init = posrelat(luaL_optinteger(L, 3, 1), new size_t(l1)) - 1;
	  if (init < 0)
	  {
		  init = 0;
	  }
	  else if ((size_t)(init) > l1)
	  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: init = (ptrdiff_t)l1;
		  init.CopyFrom((ptrdiff_t)l1);
	  }
	  if (find != 0 && (lua_toboolean(L, 4) || strpbrk(p, DefineConstants.SPECIALS) == null))
	  { // or no special characters? -  explicit request?
		/* do a plain search */
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *s2 = lmemfind(s+init, l1-init, p, l2);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
		sbyte s2 = lmemfind(s + init, l1 - init, p, new size_t(l2));
		if (s2 != 0)
		{
		  lua_pushinteger(L, s2 - s + 1);
		  lua_pushinteger(L, s2 - s + l2);
		  return 2;
		}
	  }
	  else
	  {
		MatchState ms = new MatchState();
		int anchor = (p == (sbyte)'^') ? (p++, 1) : 0;
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
		sbyte * s1 = s + init;
		ms.L = L;
		ms.src_init = s;
		ms.src_end = s + l1;
		do
		{
		  string res;
		  ms.level = 0;
		  if ((res = match(ms, s1, p)) != null)
		  {
			if (find != 0)
			{
			  lua_pushinteger(L, s1 - s + 1); // start
			  lua_pushinteger(L, res - s); // end
			  return push_captures(ms, null, 0) + 2;
			}
			else
			{
			  return push_captures(ms, s1, res);
			}
		  }
		} while (s1++ < ms.src_end && anchor == 0);
	  }
	  lua_pushnil(L); // not found
	  return 1;
	}


	internal static int str_find(lua_State L)
	{
	  return str_find_aux(L, 1);
	}


	internal static int str_match(lua_State L)
	{
	  return str_find_aux(L, 0);
	}


	internal static int gmatch_aux(lua_State L)
	{
	  MatchState ms = new MatchState();
	  size_t ls = new size_t();
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *s = lua_tolstring(L, (DefineConstants.LUA_GLOBALSINDEX-(1)), &ls);
	  sbyte s = lua_tolstring(L, (DefineConstants.LUA_GLOBALSINDEX - (1)), ls);
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *p = lua_tolstring(L, ((DefineConstants.LUA_GLOBALSINDEX-(2))), null);
	  sbyte p = lua_tolstring(L, ((DefineConstants.LUA_GLOBALSINDEX - (2))), null);
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  sbyte * src;
	  ms.L = L;
	  ms.src_init = s;
	  ms.src_end = s + ls;
	  for (src = s + (size_t)lua_tointeger(L, (DefineConstants.LUA_GLOBALSINDEX - (3))); src <= ms.src_end; src++)
	  {
		string e;
		ms.level = 0;
		if ((e = match(ms, src, p)) != null)
		{
		  ptrdiff_t newstart = e - s;
		  if (e == src)
		  {
			  newstart++; // empty match? go at least one position
		  }
		  lua_pushinteger(L, newstart);
		  lua_replace(L, (DefineConstants.LUA_GLOBALSINDEX - (3)));
		  return push_captures(ms, src, e);
		}
	  }
	  return 0; // not found
	}


	internal static int gmatch(lua_State L)
	{
	  (luaL_checklstring(L, (1), null));
	  (luaL_checklstring(L, (2), null));
	  lua_settop(L, 2);
	  lua_pushinteger(L, 0);
	  lua_pushcclosure(L, gmatch_aux, 3);
	  return 1;
	}


	internal static int gfind_nodef(lua_State L)
	{
	  return luaL_error(L, "'" "string.gfind" "'" " was renamed to " "'" "string.gmatch" "'");
	}


	internal static void add_s(MatchState ms, luaL_Buffer b, string s, string e)
	{
	  size_t l = new size_t();
	  size_t i = new size_t();
	  sbyte[] news = lua_tolstring(ms.L, 3, l);
	  for (i = 0; i < l; i++)
	  {
		if (news[i] != DefineConstants.L_ESC)
		{
		  (((b).p < ((b).buffer + BUFSIZ) || luaL_prepbuffer(b)), (*(b).p ++= (sbyte)(news[i])));
		}
		else
		{
		  i++; // skip ESC
		  if (!isdigit(((byte)(news[i]))))
		  {
			(((b).p < ((b).buffer + BUFSIZ) || luaL_prepbuffer(b)), (*(b).p ++= (sbyte)(news[i])));
		  }
		  else if (news[i] == (sbyte)'0')
		  {
			  luaL_addlstring(b, s, e - s);
		  }
		  else
		  {
			push_onecapture(ms, news[i] - '1', s, e);
			luaL_addvalue(b); // add capture to accumulated result
		  }
		}
	  }
	}


	internal static void add_value(MatchState ms, luaL_Buffer b, string s, string e)
	{
	  lua_State L = ms.L;
	  switch (lua_type(L, 3))
	  {
		case DefineConstants.LUA_TNUMBER:
		case DefineConstants.LUA_TSTRING:
		{
		  add_s(ms, b, s, e);
		  return;
		}
		case DefineConstants.LUA_TFUNCTION:
		{
		  int n;
		  lua_pushvalue(L, 3);
		  n = push_captures(ms, s, e);
		  lua_call(L, n, 1);
		  break;
		}
		case DefineConstants.LUA_TTABLE:
		{
		  push_onecapture(ms, 0, s, e);
		  lua_gettable(L, 3);
		  break;
		}
	  }
	  if (!lua_toboolean(L, -1))
	  { // nil or false?
		lua_settop(L, -(1) - 1);
		lua_pushlstring(L, s, e - s); // keep original text
	  }
	  else if (!lua_isstring(L, -1))
	  {
		luaL_error(L, "invalid replacement value (a %s)", lua_typename(L, lua_type(L,(-1))));
	  }
	  luaL_addvalue(b); // add result to accumulator
	}


	internal static int str_gsub(lua_State L)
	{
	  size_t srcl = new size_t();
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  sbyte * src = luaL_checklstring(L, 1, srcl);
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  sbyte * p = (luaL_checklstring(L, (2), null));
	  int tr = lua_type(L, 3);
	  int max_s = ((int)luaL_optinteger(L, (4), (srcl + 1)));
	  int anchor = (*p == (sbyte)'^') ? (p++, 1) : 0;
	  int n = 0;
	  MatchState ms = new MatchState();
	  luaL_Buffer b = new luaL_Buffer();
	  (((tr == DefineConstants.LUA_TNUMBER || tr == DefineConstants.LUA_TSTRING || tr == DefineConstants.LUA_TFUNCTION || tr == DefineConstants.LUA_TTABLE) || luaL_argerror(L, (3), ("string/function/table expected"))));
	  luaL_buffinit(L, b);
	  ms.L = L;
	  ms.src_init = src;
	  ms.src_end = src + srcl;
	  while (n < max_s)
	  {
		string e;
		ms.level = 0;
		e = match(ms, src, p);
		if (e != 0)
		{
		  n++;
		  add_value(ms, b, src, e);
		}
		if (e != 0 && e > src) // non empty match?
		{
		  src = e; // skip it
		}
		else if (src < ms.src_end)
		{
		  (((b).p < ((b).buffer + BUFSIZ) || luaL_prepbuffer(b)), (*(b).p ++= (sbyte)(*src++)));
		}
		else
		{
			break;
		}
		if (anchor != 0)
		{
			break;
		}
	  }
	  luaL_addlstring(b, src, ms.src_end - src);
	  luaL_pushresult(b);
	  lua_pushinteger(L, n); // number of substitutions
	  return 2;
	}

	/* }====================================================== */


	/* maximum size of each formatted item (> len(format('%99.99f', -1e308))) */
	/* valid flags in a format specification */
	/*
	** maximum size of each format specification (such as '%-099.99d')
	** (+10 accounts for %99.99x plus margin of error)
	*/
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_FORMAT (sizeof(FLAGS) + sizeof(LUA_INTFRMLEN) + 10)


	internal static void addquoted(lua_State L, luaL_Buffer b, int arg)
	{
	  size_t l = new size_t();
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  sbyte * s = luaL_checklstring(L, arg, l);
	  (((b).p < ((b).buffer + BUFSIZ) || luaL_prepbuffer(b)), (*(b).p ++= (sbyte)('"')));
	  while (l-- != null)
	  {
		switch (*s)
		{
		  case '"':
	  case '\\':
	case '\n':
	{
			(((b).p < ((b).buffer + BUFSIZ) || luaL_prepbuffer(b)), (*(b).p ++= (sbyte)('\\')));
			(((b).p < ((b).buffer + BUFSIZ) || luaL_prepbuffer(b)), (*(b).p ++= (sbyte)(*s)));
			break;
	}
		  case '\r':
		  {
			luaL_addlstring(b, "\\r", 2);
			break;
		  }
		  case '\0':
		  {
			luaL_addlstring(b, "\\x0000", 4);
			break;
		  }
		  default:
		  {
			(((b).p < ((b).buffer + BUFSIZ) || luaL_prepbuffer(b)), (*(b).p ++= (sbyte)(*s)));
			break;
		  }
		}
		s++;
	  }
	  (((b).p < ((b).buffer + BUFSIZ) || luaL_prepbuffer(b)), (*(b).p ++= (sbyte)('"')));
	}

//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'form', so pointers on this parameter are left unchanged:
	internal static string scanformat(lua_State L, string strfrmt, sbyte * form)
	{
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  sbyte * p = strfrmt;
	  while (*p != (sbyte)'\0' && StringFunctions.StrChr(DefineConstants.FLAGS, *p) != null)
	  {
		  p++; // skip flags
	  }
	  if ((size_t)(p - strfrmt) >= sizeof(DefineConstants.FLAGS))
	  {
		luaL_error(L, "invalid format (repeated flags)");
	  }
	  if (isdigit(((byte)(*p))))
	  {
		  p++; // skip width
	  }
	  if (isdigit(((byte)(*p))))
	  {
		  p++; // (2 digits at most)
	  }
	  if (*p == (sbyte)'.')
	  {
		p++;
		if (isdigit(((byte)(*p))))
		{
			p++; // skip precision
		}
		if (isdigit(((byte)(*p))))
		{
			p++; // (2 digits at most)
		}
	  }
	  if (isdigit(((byte)(*p))))
	  {
		luaL_error(L, "invalid format (width or precision too long)");
	  }
	  *(form++) = '%';
	  form = strfrmt.Substring(0, p - strfrmt.Substring(1));
	  form += p - strfrmt.Substring(1);
	  *form = (sbyte)'\0';
	  return p;
	}


	internal static void addintlen(ref string form)
	{
	  size_t l = form.Length;
	  sbyte spec = form[l - 1];
	  form + l - 1 = DefineConstants.LUA_INTFRMLEN;
	  form[l + sizeof(DefineConstants.LUA_INTFRMLEN) - 2] = spec;
	  form[l + sizeof(DefineConstants.LUA_INTFRMLEN) - 1] = '\0';
	}


	internal static int str_format(lua_State L)
	{
	  int arg = 1;
	  size_t sfl = new size_t();
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  sbyte * strfrmt = luaL_checklstring(L, arg, sfl);
	  string strfrmt_end = strfrmt + sfl;
	  luaL_Buffer b = new luaL_Buffer();
	  luaL_buffinit(L, b);
	  while (strfrmt < strfrmt_end)
	  {
		if (*strfrmt != DefineConstants.L_ESC)
		{
		  (((b).p < ((b).buffer + BUFSIZ) || luaL_prepbuffer(b)), (*(b).p ++= (sbyte)(*strfrmt++)));
		}
		else if (*++strfrmt == DefineConstants.L_ESC)
		{
		  (((b).p < ((b).buffer + BUFSIZ) || luaL_prepbuffer(b)), (*(b).p ++= (sbyte)(*strfrmt++))); // %%
		}
		else
		{ // format item
		  string form = new string(new char[(sizeof(DefineConstants.FLAGS) + sizeof(DefineConstants.LUA_INTFRMLEN) + 10)]); // to store the format (`%...')
		  string buff = new string(new char[DefineConstants.MAX_ITEM]); // to store the formatted item
		  arg++;
		  strfrmt = scanformat(L, strfrmt, form);
		  switch (*strfrmt++)
		  {
			case 'c':
			{
			  sprintf(buff, form, (int)luaL_checknumber(L, arg));
			  break;
			}
			case 'd':
		case 'i':
		{
			  addintlen(ref form);
			  sprintf(buff, form, (LUA_INTFRM_T)luaL_checknumber(L, arg));
			  break;
		}
			case 'o':
		case 'u':
	case 'x':
	case 'X':
	{
			  addintlen(ref form);
			  sprintf(buff, form, (uint LUA_INTFRM_T)luaL_checknumber(L, arg));
			  break;
	}
			case 'e':
		case 'E':
	case 'f':
			case 'g':
		case 'G':
		{
			  sprintf(buff, form, (double)luaL_checknumber(L, arg));
			  break;
		}
			case 'q':
			{
			  addquoted(L, b, arg);
			  continue; // skip the 'addsize' at the end
			}
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
			case 's':
			{
			  size_t l = new size_t();
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *s = luaL_checklstring(L, arg, &l);
			  sbyte s = luaL_checklstring(L, arg, l);
			  if (!StringFunctions.StrChr(form, '.') && l >= 100)
			  {
				/* no precision and string is too long to be formatted;
				   keep original string */
				lua_pushvalue(L, arg);
				luaL_addvalue(b);
				continue; // skip the `addsize' at the end
			  }
			  else
			  {
				sprintf(buff, form, s);
				break;
			  }
			}
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
			default:
			{ // also treat cases `pnLlh'
			  return luaL_error(L, "invalid option " "'" "%%%c" "'" " to " "'" "format" "'", *(strfrmt - 1));
			}
		  }
		  luaL_addlstring(b, buff, buff.Length);
		}
	  }
	  luaL_pushresult(b);
	  return 1;
	}


	internal luaL_Reg[] strlib =
	{
		new luaL_Reg("byte", str_byte),
		new luaL_Reg("char", str_char),
		new luaL_Reg("dump", str_dump),
		new luaL_Reg("find", str_find),
		new luaL_Reg("format", str_format),
		new luaL_Reg("gfind", gfind_nodef),
		new luaL_Reg("gmatch", gmatch),
		new luaL_Reg("gsub", str_gsub),
		new luaL_Reg("len", str_len),
		new luaL_Reg("lower", str_lower),
		new luaL_Reg("match", str_match),
		new luaL_Reg("rep", str_rep),
		new luaL_Reg("reverse", str_reverse),
		new luaL_Reg("sub", str_sub),
		new luaL_Reg("upper", str_upper),
		new luaL_Reg(null, null)
	};


	internal static void createmetatable(lua_State L)
	{
	  lua_createtable(L, 0, 1); // create metatable for strings
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "", (sizeof("")/sizeof(sbyte))-1);
	  lua_pushlstring(L, "" "", (("").Length) - 1); // dummy string
	  lua_pushvalue(L, -2);
	  lua_setmetatable(L, -2); // set string metatable
	  lua_settop(L, -(1) - 1); // pop dummy string
	  lua_pushvalue(L, -2); // string library...
	  lua_setfield(L, -2, "__index"); // ...is the __index metamethod
	  lua_settop(L, -(1) - 1); // pop metatable
	}


	/*
	** Open string library
	*/
	public static int luaopen_string(lua_State L)
	{
	  luaL_register(L, DefineConstants.LUA_STRLIBNAME, strlib);
	#if LUA_COMPAT_GFIND
	  lua_getfield(L, -1, "gmatch");
	  lua_setfield(L, -2, "gfind");
	#endif
	  createmetatable(L);
	  return 1;
	}



/*
** search function for integers
*/
	/*
	** $Id: ltable.c,v 2.32.1.2 2007/12/28 15:32:23 roberto Exp $
	** Lua tables (hash)
	** See Copyright Notice in lua.h
	*/


	/*
	** Implementation of tables (aka arrays, objects, or hash tables).
	** Tables keep its elements in two parts: an array part and a hash part.
	** Non-negative integer keys are all candidates to be kept in the array
	** part. The actual size of the array is the largest `n' such that at
	** least half the slots between 0 and n are in use.
	** Hash uses a mix of chained scatter table with Brent's variation.
	** A main invariant of these tables is that, if an element is not
	** in its main position (i.e. the `original' position that its hash gives
	** to it), then the colliding element is in its own main position.
	** Hence even when the load factor reaches 100%, performance remains good.
	*/



//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DYLD
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_VARARG
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_MOD
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_LSTR
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_GFIND
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_OPENLIB
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DLOPEN
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DLL
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_SIZET ((size_t)(~(size_t)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_LUMEM ((lu_mem)(~(lu_mem)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_INT (INT_MAX-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IntPoint(p) ((unsigned int)(lu_mem)(p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (lua_assert(c), (e))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check(l,e) lua_assert(e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(c) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check luai_apicheck
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define UNUSED(x) ((void)(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast(t, exp) ((t)(exp))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_byte(i) cast(lu_byte, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_num(i) cast(lua_Number, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_int(i) cast(int, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_lock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unlock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_threadyield(L) {lua_unlock(L); lua_lock(L);}
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) x
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LAST_TAG LUA_TTHREAD
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NUM_TAGS (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TPROTO (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TUPVAL (LAST_TAG+2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TDEADKEY (LAST_TAG+3)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define CommonHeader GCObject *next; lu_byte tt; lu_byte marked
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define TValuefields Value value; int tt
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnil(o) (ttype(o) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnumber(o) (ttype(o) == LUA_TNUMBER)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisstring(o) (ttype(o) == LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttistable(o) (ttype(o) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisfunction(o) (ttype(o) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisboolean(o) (ttype(o) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisuserdata(o) (ttype(o) == LUA_TUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisthread(o) (ttype(o) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttislightuserdata(o) (ttype(o) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttype(o) ((o)->tt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gcvalue(o) check_exp(iscollectable(o), (o)->value.gc)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pvalue(o) check_exp(ttislightuserdata(o), (o)->value.p)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define nvalue(o) check_exp(ttisnumber(o), (o)->value.n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawtsvalue(o) check_exp(ttisstring(o), &(o)->value.gc->ts)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define tsvalue(o) (&rawtsvalue(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawuvalue(o) check_exp(ttisuserdata(o), &(o)->value.gc->u)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define uvalue(o) (&rawuvalue(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define clvalue(o) check_exp(ttisfunction(o), &(o)->value.gc->cl)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define hvalue(o) check_exp(ttistable(o), &(o)->value.gc->h)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bvalue(o) check_exp(ttisboolean(o), (o)->value.b)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define thvalue(o) check_exp(ttisthread(o), &(o)->value.gc->th)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_isfalse(o) (ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkconsistency(obj) lua_assert(!iscollectable(obj) || (ttype(obj) == (obj)->value.gc->gch.tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkliveness(g,obj) lua_assert(!iscollectable(obj) || ((ttype(obj) == (obj)->value.gc->gch.tt) && !isdead(g, (obj)->value.gc)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnilvalue(obj) ((obj)->tt=LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnvalue(obj,x) { TValue *i_o=(obj); i_o->value.n=(x); i_o->tt=LUA_TNUMBER; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setpvalue(obj,x) { TValue *i_o=(obj); i_o->value.p=(x); i_o->tt=LUA_TLIGHTUSERDATA; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbvalue(obj,x) { TValue *i_o=(obj); i_o->value.b=(x); i_o->tt=LUA_TBOOLEAN; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TSTRING; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setuvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TUSERDATA; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setthvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTHREAD; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setclvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TFUNCTION; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTABLE; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TPROTO; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj(L,obj1,obj2) { const TValue *o2=(obj2); TValue *o1=(obj1); o1->value = o2->value; o1->tt=o2->tt; checkliveness(G(L),o1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjs2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2s setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue2s sethvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue2s setptvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjt2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2n setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2n setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setttype(obj, tt) (ttype(obj) = (tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscollectable(o) (ttype(o) >= LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getstr(ts) cast(const char *, (ts) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define svalue(o) getstr(rawtsvalue(o))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ClosureHeader CommonHeader; lu_byte isC; lu_byte nupvalues; GCObject *gclist; struct Table *env
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscfunction(o) (ttype(o) == LUA_TFUNCTION && clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLfunction(o) (ttype(o) == LUA_TFUNCTION && !clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lmod(s,size) (check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define twoto(x) (1<<(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizenode(t) (twoto((t)->lsizenode))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaO_nilobject (&luaO_nilobject_)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ceillog2(x) (luaO_log2((x)-1) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gfasttm(g,et,e) ((et) == NULL ? NULL : ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define fasttm(l,et,e) gfasttm(G(l), et, e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocv(L,b,on,n,e) ((cast(size_t, (n)+1) <= MAX_SIZET/(e)) ? luaM_realloc_(L, (b), (on)*(e), (n)*(e)) : luaM_toobig(L))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freemem(L, b, s) luaM_realloc_(L, (b), (s), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_free(L, b) luaM_realloc_(L, (b), sizeof(*(b)), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freearray(L, b, n, t) luaM_reallocv(L, (b), n, 0, sizeof(t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_malloc(L,t) luaM_realloc_(L, NULL, 0, (t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_new(L,t) cast(t *, luaM_malloc(L, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_newvector(L,n,t) cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_growvector(L,v,nelems,size,t,limit,e) if ((nelems)+1 > (size)) ((v)=cast(t *, luaM_growaux_(L,v,&(size),sizeof(t),limit,e)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocvector(L, v,oldn,n,t) ((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define char2int(c) cast(int, cast(unsigned char, (c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define zgetc(z) (((z)->n--)>0 ? char2int(*(z)->p++) : luaZ_fill(z))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_buffer(buff) ((buff)->buffer)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_sizebuffer(buff) ((buff)->buffsize)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_bufflen(buff) ((buff)->n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resetbuffer(buff) ((buff)->n = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resizebuffer(L, buff, size) (luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), (buff)->buffsize = size)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_freebuffer(L, buff) luaZ_resizebuffer(L, buff, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gt(L) (&L->l_gt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define registry(L) (&G(L)->l_registry)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BASIC_STACK_SIZE (2*LUA_MINSTACK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define curr_func(L) (clvalue(L->ci->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ci_func(ci) (clvalue((ci)->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define f_isLua(ci) (!ci_func(ci)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLua(ci) (ttisfunction((ci)->func) && f_isLua(ci))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define G(L) (L->l_G)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2ts(o) check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2ts(o) (&rawgco2ts(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2u(o) check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2u(o) (&rawgco2u(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2cl(o) check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2h(o) check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2p(o) check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2uv(o) check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ngcotouv(o) check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2th(o) check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define obj2gco(v) (cast(GCObject *, (v)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pcRel(pc, p) (cast(int, (pc) - (p)->code) - 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getline(f,pc) (((f)->lineinfo) ? (f)->lineinfo[pc] : 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resethookcount(L) (L->hookcount = L->basehookcount)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaD_checkstack(L,n) if ((char *)L->stack_last - (char *)L->top <= (n)*(int)sizeof(TValue)) luaD_growstack(L, n); else condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define incr_top(L) {luaD_checkstack(L,1); L->top++;}
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define savestack(L,p) ((char *)(p) - (char *)L->stack)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define restorestack(L,n) ((TValue *)((char *)L->stack + (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define saveci(L,p) ((char *)(p) - (char *)L->base_ci)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define restoreci(L,n) ((CallInfo *)((char *)L->base_ci + (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbits(x,m) ((x) &= cast(lu_byte, ~(m)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbits(x,m) ((x) |= (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbits(x,m) ((x) & (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bitmask(b) (1<<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bit2mask(b1,b2) (bitmask(b1) | bitmask(b2))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_setbit(x,b) setbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbit(x,b) resetbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbit(x,b) testbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define set2bits(x,b1,b2) setbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define reset2bits(x,b1,b2) resetbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define test2bits(x,b1,b2) testbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define WHITEBITS bit2mask(WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iswhite(x) test2bits((x)->gch.marked, WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isblack(x) testbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isgray(x) (!isblack(x) && !iswhite(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define otherwhite(g) (g->currentwhite ^ WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isdead(g,v) ((v)->gch.marked & otherwhite(g) & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define changewhite(x) ((x)->gch.marked ^= WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gray2black(x) l_setbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define valiswhite(x) (iscollectable(x) && iswhite(gcvalue(x)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_white(g) cast(lu_byte, (g)->currentwhite & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_checkGC(L) { condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1)); if (G(L)->totalbytes >= G(L)->GCthreshold) luaC_step(L); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),gcvalue(v)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barriert(L,t,v) { if (valiswhite(v) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarrier(L,p,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),obj2gco(o)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarriert(L,t,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	/*
	** $Id: ltable.h,v 2.10.1.1 2007/12/27 13:02:25 roberto Exp $
	** Lua tables (hash)
	** See Copyright Notice in lua.h
	*/




	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gnode(t,i) (&(t)->node[i])
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gkey(n) (&(n)->i_key.nk)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gval(n) (&(n)->i_val)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gnext(n) ((n)->i_key.nk.next)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define key2tval(n) (&(n)->i_key.tvk)


	public static lua_TValue luaH_getnum(Table t, int key)
	{
	  /* (1 <= key && key <= t->sizearray) */
	  if (((uint)(key - 1)) < ((uint)(t.sizearray)))
	  {
		return t.array[key - 1];
	  }
	  else
	  {
		double nk = ((double)((key)));
		Node n = hashnum(t, nk);
		do
		{ // check whether `key' is somewhere in the chain
		  if ((((((n).i_key.nk)).tt) == DefineConstants.LUA_TNUMBER) && ((check_exp(ttisnumber(((n).i_key.nk)), (((n).i_key.nk)).value.n)) == (nk)))
		  {
			return ((n).i_val); // that's it
		  }
		  else
		  {
			  n = ((n).i_key.nk.next);
		  }
		} while (n != null);
		return (luaO_nilobject_);
	  }
	}
	public static lua_TValue luaH_setnum(lua_State L, Table t, int key)
	{
	  lua_TValue p = luaH_getnum(t, key);
	  if (p != (luaO_nilobject_))
	  {
		return ((lua_TValue)(p));
	  }
	  else
	  {
		lua_TValue k = new lua_TValue();
		{
			lua_TValue i_o = (k);
			i_o.value.n = (((double)((key))));
			i_o.tt = DefineConstants.LUA_TNUMBER;
		};
		return newkey(L, t, k);
	  }
	}

/*
** search function for strings
*/
	public static lua_TValue luaH_getstr(Table t, TString key)
	{
	  Node n = (((t).node[(check_exp((((1 << ((t).lsizenode))) & (((1 << ((t).lsizenode))) - 1)) == 0, (((int)((((key).tsv.hash)) & ((((1 << ((t).lsizenode)))) - 1))))))]));
	  do
	  { // check whether `key' is somewhere in the chain
		if ((((((n).i_key.nk)).tt) == DefineConstants.LUA_TSTRING) && check_exp(ttisstring(((n).i_key.nk)), (((n).i_key.nk)).value.gc.ts) == key)
		{
		  return ((n).i_val); // that's it
		}
		else
		{
			n = ((n).i_key.nk.next);
		}
	  } while (n != null);
	  return (luaO_nilobject_);
	}
	public static lua_TValue luaH_setstr(lua_State L, Table t, TString key)
	{
	  lua_TValue p = luaH_getstr(t, key);
	  if (p != (luaO_nilobject_))
	  {
		return ((lua_TValue)(p));
	  }
	  else
	  {
		lua_TValue k = new lua_TValue();
		{
			lua_TValue i_o = (k);
			i_o.value.gc = ((union GCObject)((key)));
			i_o.tt = DefineConstants.LUA_TSTRING;
			(c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		};
		return newkey(L, t, k);
	  }
	}

/*
** main search function
*/
	public static lua_TValue luaH_get(Table t, lua_TValue key)
	{
	  switch (((key).tt))
	  {
		case DefineConstants.LUA_TNIL:
			return (luaO_nilobject_);
		case DefineConstants.LUA_TSTRING:
			return luaH_getstr(t, check_exp((((key).tt) == DefineConstants.LUA_TSTRING), (key).value.gc.ts));
		case DefineConstants.LUA_TNUMBER:
		{
		  int k;
		  double n = check_exp((((key).tt) == DefineConstants.LUA_TNUMBER), (key).value.n);
		  ((k) = (int)(n));
		  if (((((double)((k)))) == (check_exp((((key).tt) == DefineConstants.LUA_TNUMBER), (key).value.n)))) // index is int?
		  {
			return luaH_getnum(t, k); // use specialized version
		  }
		  /* else go through */
		}
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		default:
		{
		  Node n = mainposition(t, key);
		  do
		  { // check whether `key' is somewhere in the chain
			if (luaO_rawequalObj(((n).i_key.tvk), key) != 0)
			{
			  return ((n).i_val); // that's it
			}
			else
			{
				n = ((n).i_key.nk.next);
			}
		  } while (n != null);
		  return (luaO_nilobject_);
		}
	  }
	}
	public static lua_TValue luaH_set(lua_State L, Table t, lua_TValue key)
	{
	  lua_TValue p = luaH_get(t, key);
	  t.flags = 0;
	  if (p != (luaO_nilobject_))
	  {
		return ((lua_TValue)(p));
	  }
	  else
	  {
		if ((((key).tt) == DefineConstants.LUA_TNIL))
		{
			luaG_runerror(L, "table index is nil");
		}
		else if ((((key).tt) == DefineConstants.LUA_TNUMBER) && (!(((check_exp(ttisnumber(key), (key).value.n))) == ((check_exp(ttisnumber(key), (key).value.n))))))
		{
		  luaG_runerror(L, "table index is NaN");
		}
		return newkey(L, t, key);
	  }
	}

/*
** }=============================================================
*/


	public static Table luaH_new(lua_State L, int narray, int nhash)
	{
	  Table t = ((Table)(luaM_realloc_(L, null, 0, (sizeof(Table)))));
	  luaC_link(L, (((union GCObject)((t)))), DefineConstants.LUA_TTABLE);
	  t.metatable = null;
	  t.flags = ((byte)((~0)));
	  /* temporary values (kept only if some malloc fails) */
	  t.array = null;
	  t.sizearray = 0;
	  t.lsizenode = 0;
	  t.node = ((Node)((dummynode_)));
	  setarrayvector(L, t, narray);
	  setnodevector(L, t, nhash);
	  return t;
	}
	public static void luaH_resizearray(lua_State L, Table t, int nasize)
	{
	  int nsize = (t.node == (dummynode_)) ? 0 : ((1 << ((t).lsizenode)));
	  resize(L, t, nasize, nsize);
	}
	public static void luaH_free(lua_State L, Table t)
	{
	  if (t.node != (dummynode_))
	  {
		((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(Node))) ? luaM_realloc_(L, ((Node.node)), (((1 << ((Node).lsizenode)))) * (sizeof(Node)), (0) * (sizeof(Node))) : luaM_toobig(L));
	  }
	  ((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(lua_TValue))) ? luaM_realloc_(L, ((lua_TValue.array)), (lua_TValue.sizearray) * (sizeof(lua_TValue)), (0) * (sizeof(lua_TValue))) : luaM_toobig(L));
	  luaM_realloc_(L, (t), sizeof(Table), 0);
	}
	public static int luaH_next(lua_State L, Table t, lua_TValue key)
	{
	  int i = findindex(L, t, key); // find original element
	  for (i++; i < t.sizearray; i++)
	  { // try first array part
		if (!(((t.array[i]).tt) == DefineConstants.LUA_TNIL))
		{ // a non-nil value?
		{
			  lua_TValue i_o = (key);
			  i_o.value.n = (((double)((i + 1))));
			  i_o.tt = DefineConstants.LUA_TNUMBER;
	  };
	  {
			  lua_TValue o2 = (t.array[i]);
			  lua_TValue o1 = (key + 1);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
			  o1.value.CopyFrom(o2.value);
			  o1.tt = o2.tt;
			  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
		  return 1;
		}
	  }
	  for (i - = t.sizearray; i < ((1 << ((t).lsizenode))); i++)
	  { // then hash part
		if (!(((((((t).node[i])).i_val)).tt) == DefineConstants.LUA_TNIL))
		{ // a non-nil value?
		{
			  lua_TValue o2 = (((((t).node[i])).i_key.tvk));
			  lua_TValue o1 = (key);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
			  o1.value.CopyFrom(o2.value);
			  o1.tt = o2.tt;
			  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  {
			  lua_TValue o2 = (((((t).node[i])).i_val));
			  lua_TValue o1 = (key + 1);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
			  o1.value.CopyFrom(o2.value);
			  o1.tt = o2.tt;
			  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
		  return 1;
		}
	  }
	  return 0; // no more elements
	}

/*
** Try to find a boundary in table `t'. A `boundary' is an integer index
** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).
*/
	public static int luaH_getn(Table t)
	{
	  uint j = t.sizearray;
	  if (j > 0 && (((t.array[j - 1]).tt) == DefineConstants.LUA_TNIL))
	  {
		/* there is a boundary in the array part: (binary) search for it */
		uint i = 0;
		while (j - i > 1)
		{
		  uint m = (i + j) / 2;
		  if ((((t.array[m - 1]).tt) == DefineConstants.LUA_TNIL))
		  {
			  j = m;
		  }
		  else
		  {
			  i = m;
		  }
		}
		return i;
	  }
	  /* else must find a boundary in hash part */
	  else if (t.node == (dummynode_)) // hash part is empty?
	  {
		return j; // that is easy...
	  }
	  else
	  {
		  return unbound_search(t, j);
	  }
	}


	#if LUA_DEBUG
	#if LUA_DEBUG
	public static Node luaH_mainposition(Table t, lua_TValue key)
	{
	  return mainposition(t, key);
	}
	public static int luaH_isdummy(Node n)
	{
		return n == (dummynode_);
	}
	#endif





	/*
	** max size of array part is 2^MAXBITS
	*/
	//C++ TO C# CONVERTER TODO TASK: C# does not allow setting or comparing #define constants:
	#if LUAI_BITSINT > 26
	#define MAXBITS
	#else
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXBITS (LUAI_BITSINT-2)
	#define MAXBITS
	#endif

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXASIZE (1 << MAXBITS)
	#define MAXASIZE


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define hashpow2(t,n) (gnode(t, lmod((n), sizenode(t))))
	#define hashpow2

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define hashstr(t,str) hashpow2(t, (str)->tsv.hash)
	#define hashstr
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define hashboolean(t,p) hashpow2(t, p)
	#define hashboolean


	/*
	** for some types, it is better to avoid modulus by power of 2, as
	** they tend to have many 2 factors.
	*/
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define hashmod(t,n) (gnode(t, ((n) % ((sizenode(t)-1)|1))))
	#define hashmod


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define hashpointer(t,p) hashmod(t, IntPoint(p))
	#define hashpointer


	/*
	** number of ints inside a lua_Number
	*/
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define numints cast_int(sizeof(lua_Number)/sizeof(int))
	#define numints



	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define dummynode (&dummynode_)
	#define dummynode

	internal Node dummynode_ = new Node(
	{
		{null},
		DefineConstants.LUA_TNIL
	},
	{
		{
			{null},
			DefineConstants.LUA_TNIL, null
		}
	});


	/*
	** hash for lua_Numbers
	*/
	internal static Node hashnum(Table t, double n)
	{
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: uint a[((int)((sizeof(double)/sizeof(int))))];
	  uint[] a = new uint[((int)((double.Length)))];
	  int i;
	  if (((n) == (0))) // avoid problems with -0
	  {
		return ((t).node[0]);
	  }
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	  memcpy(a, n, sizeof(uint));
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: for (i = 1; i < ((int)((sizeof(double)/sizeof(int)))); i++)
	  for (i = 1; i < ((int)((double.Length))); i++)
	  {
		  a[0] += a[i];
	  }
	  return (((t).node[((a[0]) % ((((1 << ((t).lsizenode))) - 1) | 1))]));
	}



	/*
	** returns the `main' position of an element in a table (that is, the index
	** of its hash value)
	*/
	internal static Node mainposition(Table t, lua_TValue key)
	{
	  switch (((key).tt))
	  {
		case DefineConstants.LUA_TNUMBER:
		  return hashnum(t, check_exp((((key).tt) == DefineConstants.LUA_TNUMBER), (key).value.n));
		case DefineConstants.LUA_TSTRING:
		  return (((t).node[(check_exp((((1 << ((t).lsizenode))) & (((1 << ((t).lsizenode))) - 1)) == 0, (((int)((((check_exp((((key).tt) == DefineConstants.LUA_TSTRING), (key).value.gc.ts)).tsv.hash)) & ((((1 << ((t).lsizenode)))) - 1))))))]));
		case DefineConstants.LUA_TBOOLEAN:
		  return (((t).node[(check_exp((((1 << ((t).lsizenode))) & (((1 << ((t).lsizenode))) - 1)) == 0, (((int)(((check_exp((((key).tt) == DefineConstants.LUA_TBOOLEAN), (key).value.b))) & ((((1 << ((t).lsizenode)))) - 1))))))]));
		case DefineConstants.LUA_TLIGHTUSERDATA:
		  return (((t).node[((((uint)(LUAI_UMEM)(check_exp((((key).tt) == DefineConstants.LUA_TLIGHTUSERDATA), (key).value.p)))) % ((((1 << ((t).lsizenode))) - 1) | 1))]));
		default:
		  return (((t).node[((((uint)(LUAI_UMEM)(check_exp((((key).tt) >= DefineConstants.LUA_TSTRING), (key).value.gc)))) % ((((1 << ((t).lsizenode))) - 1) | 1))]));
	  }
	}


	/*
	** returns the index for `key' if `key' is an appropriate key to live in
	** the array part of the table, -1 otherwise.
	*/
	internal static int arrayindex(lua_TValue key)
	{
	  if ((((key).tt) == DefineConstants.LUA_TNUMBER))
	  {
		double n = check_exp((((key).tt) == DefineConstants.LUA_TNUMBER), (key).value.n);
		int k;
		((k) = (int)(n));
		if (((((double)((k)))) == (n)))
		{
		  return k;
		}
	  }
	  return -1; // `key' did not match some condition
	}


	/*
	** returns the index of a `key' for table traversals. First goes all
	** elements in the array part, then elements in the hash part. The
	** beginning of a traversal is signalled by -1.
	*/
	internal static int findindex(lua_State L, Table t, lua_TValue key)
	{
	  int i;
	  if ((((key).tt) == DefineConstants.LUA_TNIL))
	  {
		  return -1; // first iteration
	  }
	  i = arrayindex(key);
	  if (0 < i && i <= t.sizearray) // is `key' inside array part?
	  {
		return i - 1; // yes; that's the index (corrected to C)
	  }
	  else
	  {
		Node n = mainposition(t, key);
		do
		{ // check whether `key' is somewhere in the chain
		  /* key may be dead already, but it is ok to use it in `next' */
		  if (luaO_rawequalObj(((n).i_key.tvk), key) != 0 || (((((n).i_key.nk)).tt) == (DefineConstants.LUA_TTHREAD + 3) && (((key).tt) >= DefineConstants.LUA_TSTRING) && check_exp((ttype(((n).i_key.nk)) >= DefineConstants.LUA_TSTRING), (((n).i_key.nk)).value.gc) == check_exp((ttype(key) >= DefineConstants.LUA_TSTRING), (key).value.gc)))
		  {
			i = ((int)((n - ((t).node[0])))); // key index in hash table
			/* hash elements are numbered after array ones */
			return i + t.sizearray;
		  }
		  else
		  {
			  n = ((n).i_key.nk.next);
		  }
		} while (n != null);
		luaG_runerror(L, "invalid key to " "'" "next" "'"); // key not found
		return 0; // to avoid warnings
	  }
	}


	/*
	** {=============================================================
	** Rehash
	** ==============================================================
	*/


	internal static int computesizes(int[] nums, ref int narray)
	{
	  int i;
	  int twotoi; // 2^i
	  int a = 0; // number of elements smaller than 2^i
	  int na = 0; // number of elements to go to array part
	  int n = 0; // optimal size for array part
	  for (i = 0, twotoi = 1; twotoi / 2 < narray; i++, twotoi *= 2)
	  {
		if (nums[i] > 0)
		{
		  a += nums[i];
		  if (a > twotoi / 2)
		  { // more than half elements present?
			n = twotoi; // optimal size (till now)
			na = a; // all elements smaller than n will go to array part
		  }
		}
		if (a == narray)
		{
			break; // all elements already counted
		}
	  }
	  narray = n;
	  (c)(0)(narray / 2 <= na != 0 && na <= narray);
	  return na;
	}


	internal static int countint(lua_TValue key, int[] nums)
	{
	  int k = arrayindex(key);
	  if (0 < k && k <= (1 << (DefineConstants.LUAI_BITSINT - 2)))
	  { // is `key' an appropriate array index?
		nums[(luaO_log2((k) - 1) + 1)]++; // count as such
		return 1;
	  }
	  else
	  {
		return 0;
	  }
	}


	internal static int numusearray(Table t, int[] nums)
	{
	  int lg;
	  int ttlg; // 2^lg
	  int ause = 0; // summation of `nums'
	  int i = 1; // count to traverse all array keys
	  for (lg = 0, ttlg = 1; lg <= (DefineConstants.LUAI_BITSINT - 2); lg++, ttlg *= 2)
	  { // for each slice
		int lc = 0; // counter
		int lim = ttlg;
		if (lim > t.sizearray)
		{
		  lim = t.sizearray; // adjust upper limit
		  if (i > lim)
		  {
			break; // no more elements to count
		  }
		}
		/* count elements in range (2^(lg-1), 2^lg] */
		for (; i <= lim; i++)
		{
		  if (!(((t.array[i - 1]).tt) == DefineConstants.LUA_TNIL))
		  {
			lc++;
		  }
		}
		nums[lg] += lc;
		ause += lc;
	  }
	  return ause;
	}


//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'pnasize', so pointers on this parameter are left unchanged:
	internal static int numusehash(Table t, ref int nums, int * pnasize)
	{
	  int totaluse = 0; // total number of elements
	  int ause = 0; // summation of `nums'
	  int i = ((1 << ((t).lsizenode)));
	  while (i-- != 0)
	  {
		Node n = t.node[i];
		if (!(((((n).i_val)).tt) == DefineConstants.LUA_TNIL))
		{
		  ause += countint(((n).i_key.tvk), nums);
		  totaluse++;
		}
	  }
	  *pnasize += ause;
	  return totaluse;
	}


	internal static void setarrayvector(lua_State L, Table t, int size)
	{
	  int i;
	  ((lua_TValue.array) = ((lua_TValue)(((cast(size_t, (size) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(lua_TValue))) ? luaM_realloc_(L, (lua_TValue.array), (lua_TValue.sizearray) * (sizeof(lua_TValue)), (size) * (sizeof(lua_TValue))) : luaM_toobig(L)))));
	  for (i = t.sizearray; i < size; i++)
	  {
		 ((t.array[i]).tt = DefineConstants.LUA_TNIL);
	  }
	  t.sizearray = size;
	}


	internal static void setnodevector(lua_State L, Table t, int size)
	{
	  int lsize;
	  if (size == 0)
	  { // no elements to hash part?
		t.node = ((Node)((dummynode_))); // use common `dummynode'
		lsize = 0;
	  }
	  else
	  {
		int i;
		lsize = (luaO_log2((size) - 1) + 1);
		if (lsize > (DefineConstants.LUAI_BITSINT - 2))
		{
		  luaG_runerror(L, "table overflow");
		}
		size = (1 << (lsize));
		t.node = ((Node)(((cast(size_t, (size) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(Node))) ? luaM_realloc_(L, (null), (0) * (sizeof(Node)), (size) * (sizeof(Node))) : luaM_toobig(L))));
		for (i = 0; i < size; i++)
		{
		  Node n = ((t).node[i]);
		  ((n).i_key.nk.next) = null;
		  ((((n).i_key.nk)).tt = DefineConstants.LUA_TNIL);
		  ((((n).i_val)).tt = DefineConstants.LUA_TNIL);
		}
	  }
	  t.lsizenode = ((byte)((lsize)));
	  t.lastfree = ((t).node[size]); // all positions are free
	}


	internal static void resize(lua_State L, Table t, int nasize, int nhsize)
	{
	  int i;
	  int oldasize = t.sizearray;
	  int oldhsize = t.lsizenode;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: Node *nold = t->node;
	  Node[] nold = new Node(t.node); // save old hash ...
	  if (nasize > oldasize) // array part must grow?
	  {
		setarrayvector(L, t, nasize);
	  }
	  /* create new hash part with appropriate size */
	  setnodevector(L, t, nhsize);
	  if (nasize < oldasize)
	  { // array part must shrink?
		t.sizearray = nasize;
		/* re-insert elements from vanishing slice */
		for (i = nasize; i < oldasize; i++)
		{
		  if (!(((t.array[i]).tt) == DefineConstants.LUA_TNIL))
		  {
				lua_TValue o2 = (t.array[i]);
				lua_TValue o1 = (luaH_setnum(L, t, i + 1));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
				o1.value.CopyFrom(o2.value);
				o1.tt = o2.tt;
				(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		  };
		}
		/* shrink array */
		((lua_TValue.array) = ((lua_TValue)(((cast(size_t, (nasize) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(lua_TValue))) ? luaM_realloc_(L, (lua_TValue.array), (oldasize) * (sizeof(lua_TValue)), (nasize) * (sizeof(lua_TValue))) : luaM_toobig(L)))));
	  }
	  /* re-insert elements from hash part */
	  for (i = (1 << (oldhsize)) - 1; i >= 0; i--)
	  {
		Node old = nold + i;
		if (!(((((old).i_val)).tt) == DefineConstants.LUA_TNIL))
		{
			  lua_TValue o2 = (((old).i_val));
			  lua_TValue o1 = (luaH_set(L, t, ((old).i_key.tvk)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
			  o1.value.CopyFrom(o2.value);
			  o1.tt = o2.tt;
			  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		};
	  }
	  if (nold != (dummynode_))
	  {
		((((size_t)((0) + 1)) <= ((size_t)(~(size_t)0) - 2) / (sizeof(Node))) ? luaM_realloc_(L, ((nold)), ((1 << (oldhsize))) * (sizeof(Node)), (0) * (sizeof(Node))) : luaM_toobig(L)); // free old array
	  }
	}


	internal static void rehash(lua_State L, Table t, lua_TValue ek)
	{
	  int nasize;
	  int na;
	  int[] nums = new int[(DefineConstants.LUAI_BITSINT - 2) + 1]; // nums[i] = number of keys between 2^(i-1) and 2^i
	  int i;
	  int totaluse;
	  for (i = 0; i <= (DefineConstants.LUAI_BITSINT - 2); i++)
	  {
		  nums[i] = 0; // reset counts
	  }
	  nasize = numusearray(t, nums); // count keys in array part
	  totaluse = nasize; // all those keys are integer keys
	  totaluse += numusehash(t, ref nums, nasize); // count keys in hash part
	  /* count extra key */
	  nasize += countint(ek, nums);
	  totaluse++;
	  /* compute new size for array part */
	  na = computesizes(nums, ref nasize);
	  /* resize the table to new computed sizes */
	  resize(L, t, nasize, totaluse - na);
	}


	internal static Node getfreepos(Table t)
	{
	  while (t.lastfree-- > t.node)
	  {
		if ((((((t.lastfree).i_key.nk)).tt) == DefineConstants.LUA_TNIL))
		{
		  return t.lastfree;
		}
	  }
	  return null; // could not find a free place
	}



	/*
	** inserts a new key into a hash table; first, check whether key's main 
	** position is free. If not, check whether colliding node is in its main 
	** position or not: if it is not, move colliding node to an empty place and 
	** put new key in its main position; otherwise (colliding node is in its main 
	** position), new key goes to an empty position. 
	*/
	internal static lua_TValue newkey(lua_State L, Table t, lua_TValue key)
	{
	  Node mp = mainposition(t, key);
	  if (!(((((mp).i_val)).tt) == DefineConstants.LUA_TNIL) || mp == (dummynode_))
	  {
		Node othern;
		Node n = getfreepos(t); // get a free place
		if (n == null)
		{ // cannot find a free place?
		  rehash(L, t, key); // grow table
		  return luaH_set(L, t, key); // re-insert key into grown table
		}
		(c)(0)(n != (dummynode_));
		othern = mainposition(t, ((mp).i_key.tvk));
		if (othern != mp)
		{ // is colliding node out of its main position?
		  /* yes; move colliding node into free position */
		  while (((othern).i_key.nk.next) != mp)
		  {
			  othern = ((othern).i_key.nk.next); // find previous
		  }
		  ((othern).i_key.nk.next) = n; // redo the chain with `n' in place of `mp'
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: *n = *mp;
		  n.CopyFrom(mp); // copy colliding node into free pos. (mp->next also goes)
		  ((mp).i_key.nk.next) = null; // now `mp' is free
		  ((((mp).i_val)).tt = DefineConstants.LUA_TNIL);
		}
		else
		{ // colliding node is in its own main position
		  /* new node will go into free position */
		  ((n).i_key.nk.next) = ((mp).i_key.nk.next); // chain new position
		  ((mp).i_key.nk.next) = n;
		  mp = n;
		}
	  }
	  ((mp).i_key.nk).value = key.value;
	  ((mp).i_key.nk).tt = key.tt;
	  {
		  if (((((key).tt) >= DefineConstants.LUA_TSTRING) && (((check_exp((((key).tt) >= DefineConstants.LUA_TSTRING), (key).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))) && ((((((union GCObject)((t))))).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))))
		  {
			  luaC_barrierback(L, t);
		  }
	  };
	  (c)(0)((((((mp).i_val)).tt) == DefineConstants.LUA_TNIL));
	  return ((mp).i_val);
	}


	internal static int unbound_search(Table t, uint j)
	{
	  uint i = j; // i is zero or a present index
	  j++;
	  /* find `i' and `j' such that i is present and j is not */
	  while (!(((luaH_getnum(t, j)).tt) == DefineConstants.LUA_TNIL))
	  {
		i = j;
		j *= 2;
		if (j > ((uint)((INT_MAX - 2))))
		{ // overflow?
		  /* table was built with bad purposes: resort to linear search */
		  i = 1;
		  while (!(((luaH_getnum(t, i)).tt) == DefineConstants.LUA_TNIL))
		  {
			  i++;
		  }
		  return i - 1;
		}
	  }
	  /* now do a binary search between them */
	  while (j - i > 1)
	  {
		uint m = (i + j) / 2;
		if ((((luaH_getnum(t, m)).tt) == DefineConstants.LUA_TNIL))
		{
			j = m;
		}
		else
		{
			i = m;
		}
	  }
	  return i;
	}




	#endif

	/*
	** $Id: ltablib.c,v 1.38.1.3 2008/02/14 16:46:58 roberto Exp $
	** Library for Table Manipulation
	** See Copyright Notice in lua.h
	*/




//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DYLD
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_VARARG
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_MOD
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_LSTR
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_GFIND
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_OPENLIB
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUAI_BITSINT
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUAI_BITSINT
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DLOPEN
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DLL
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getn(L,i) ((int)lua_objlen(L, i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_setn(L,i,j) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaI_openlib luaL_openlib
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_ERRFILE (LUA_ERRERR+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_argcheck(L, cond,numarg,extramsg) ((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkstring(L,n) (luaL_checklstring(L, (n), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optstring(L,n,d) (luaL_optlstring(L, (n), (d), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkint(L,n) ((int)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optint(L,n,d) ((int)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checklong(L,n) ((long)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optlong(L,n,d) ((long)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_typename(L,i) lua_typename(L, lua_type(L,(i)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dofile(L, fn) (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dostring(L, s) (luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getmetatable(L,n) (lua_getfield(L, LUA_REGISTRYINDEX, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_opt(L,f,n,d) (lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addchar(B,c) ((void)((B)->p < ((B)->buffer+LUAL_BUFFERSIZE) || luaL_prepbuffer(B)), (*(B)->p++ = (char)(c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_putchar(B,c) luaL_addchar(B,c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addsize(B,n) ((B)->p += (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_ref(L,lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : (lua_pushstring(L, "unlocked references are obsolete"), lua_error(L), 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unref(L,ref) luaL_unref(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getref(L,ref) lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_reg luaL_Reg
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(x) ((void)0)


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define aux_getn(L,n) (luaL_checktype(L, n, LUA_TTABLE), luaL_getn(L, n))


	internal static int foreachi(lua_State L)
	{
	  int i;
	  luaL_checktype(L, 1, DefineConstants.LUA_TTABLE);
	  int = ((int)lua_objlen(L, 1));
	  luaL_checktype(L, 2, DefineConstants.LUA_TFUNCTION);
	  for (i = 1; i <= n; i++)
	  {
		lua_pushvalue(L, 2); // function
		lua_pushinteger(L, i); // 1st argument
		lua_rawgeti(L, 1, i); // 2nd argument
		lua_call(L, 2, 1);
		if (!(lua_type(L, (-1)) == DefineConstants.LUA_TNIL))
		{
		  return 1;
		}
		lua_settop(L, -(1) - 1); // remove nil result
	  }
	  return 0;
	}


	internal static int @foreach(lua_State L)
	{
	  luaL_checktype(L, 1, DefineConstants.LUA_TTABLE);
	  luaL_checktype(L, 2, DefineConstants.LUA_TFUNCTION);
	  lua_pushnil(L); // first key
	  while (lua_next(L, 1))
	  {
		lua_pushvalue(L, 2); // function
		lua_pushvalue(L, -3); // key
		lua_pushvalue(L, -3); // value
		lua_call(L, 2, 1);
		if (!(lua_type(L, (-1)) == DefineConstants.LUA_TNIL))
		{
		  return 1;
		}
		lua_settop(L, -(2) - 1); // remove value and result
	  }
	  return 0;
	}


	internal static int maxn(lua_State L)
	{
	  double max = 0;
	  luaL_checktype(L, 1, DefineConstants.LUA_TTABLE);
	  lua_pushnil(L); // first key
	  while (lua_next(L, 1))
	  {
		lua_settop(L, -(1) - 1); // remove value
		if (lua_type(L, -1) == DefineConstants.LUA_TNUMBER)
		{
		  double v = lua_tonumber(L, -1);
		  if (v > max)
		  {
			  max = v;
		  }
		}
	  }
	  lua_pushnumber(L, max);
	  return 1;
	}


	internal static int getn(lua_State L)
	{
	  lua_pushinteger(L, (luaL_checktype(L, 1, DefineConstants.LUA_TTABLE), ((int)lua_objlen(L, 1))));
	  return 1;
	}


	internal static int setn(lua_State L)
	{
	  luaL_checktype(L, 1, DefineConstants.LUA_TTABLE);
	#if ! luaL_setn
	  (0);
	#else
	  luaL_error(L, "'" "setn" "'" " is obsolete");
	#endif
	  lua_pushvalue(L, 1);
	  return 1;
	}


	internal static int tinsert(lua_State L)
	{
	  int e = (luaL_checktype(L, 1, DefineConstants.LUA_TTABLE), ((int)lua_objlen(L, 1))) + 1; // first empty element
	  int pos; // where to insert new element
	  switch (lua_gettop(L))
	  {
		case 2:
		{ // called with only 2 arguments
		  pos = e; // insert new element at the end
		  break;
		}
		case 3:
		{
		  int i;
		  pos = ((int)luaL_checkinteger(L, (2))); // 2nd argument is the position
		  if (pos > e)
		  {
			  e = pos; // `grow' array if necessary
		  }
		  for (i = e; i > pos; i--)
		  { // move up elements
			lua_rawgeti(L, 1, i - 1);
			lua_rawseti(L, 1, i); // t[i] = t[i-1]
		  }
		  break;
		}
		default:
		{
		  return luaL_error(L, "wrong number of arguments to " "'" "insert" "'");
		}
	  }
	  (0); // new size
	  lua_rawseti(L, 1, pos); // t[pos] = v
	  return 0;
	}


	internal static int tremove(lua_State L)
	{
	  luaL_checktype(L, 1, DefineConstants.LUA_TTABLE);
	  int = ((int)lua_objlen(L, 1));
	  int pos = ((int)luaL_optinteger(L, (2), (e)));
	  if (!(1 <= pos != 0 && pos <= e)) // position is outside bounds?
	  {
	   return 0; // nothing to remove
	  }
	  (0); // t.n = n-1
	  lua_rawgeti(L, 1, pos); // result = t[pos]
	  for (;pos < e; pos++)
	  {
		lua_rawgeti(L, 1, pos + 1);
		lua_rawseti(L, 1, pos); // t[pos] = t[pos+1]
	  }
	  lua_pushnil(L);
	  lua_rawseti(L, 1, e); // t[e] = nil
	  return 1;
	}


	internal static void addfield(lua_State L, luaL_Buffer b, int i)
	{
	  lua_rawgeti(L, 1, i);
	  if (!lua_isstring(L, -1))
	  {
		luaL_error(L, "invalid value (%s) at index %d in table for " "'" "concat" "'", lua_typename(L, lua_type(L,(-1))), i);
	  }
		luaL_addvalue(b);
	}


	internal static int tconcat(lua_State L)
	{
	  luaL_Buffer b = new luaL_Buffer();
	  size_t lsep = new size_t();
	  int i;
	  int last;
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *sep = luaL_optlstring(L, 2, "", &lsep);
	  sbyte sep = luaL_optlstring(L, 2, "", lsep);
	  luaL_checktype(L, 1, DefineConstants.LUA_TTABLE);
	  i = ((int)luaL_optinteger(L, (3), (1)));
	  last = ((lua_type(L, ((4))) <= 0) ? (((int)lua_objlen(L, 1))) : ((int)luaL_checkinteger(L, ((4)))));
	  luaL_buffinit(L, b);
	  for (; i < last; i++)
	  {
		addfield(L, b, i);
		luaL_addlstring(b, sep, lsep);
	  }
	  if (i == last) // add last value (if interval was not empty)
	  {
		addfield(L, b, i);
	  }
	  luaL_pushresult(b);
	  return 1;
	}



	/*
	** {======================================================
	** Quicksort
	** (based on `Algorithms in MODULA-3', Robert Sedgewick;
	**  Addison-Wesley, 1993.)
	*/


	internal static void set2(lua_State L, int i, int j)
	{
	  lua_rawseti(L, 1, i);
	  lua_rawseti(L, 1, j);
	}

	internal static int sort_comp(lua_State L, int a, int b)
	{
	  if (!(lua_type(L, (2)) == DefineConstants.LUA_TNIL))
	  { // function?
		int res;
		lua_pushvalue(L, 2);
		lua_pushvalue(L, a - 1); // -1 to compensate function
		lua_pushvalue(L, b - 2); // -2 to compensate function and `a'
		lua_call(L, 2, 1);
		res = lua_toboolean(L, -1);
		lua_settop(L, -(1) - 1);
		return res;
	  }
	  else // a < b?
	  {
		return lua_lessthan(L, a, b);
	  }
	}

	internal static void auxsort(lua_State L, int l, int u)
	{
	  while (l < u)
	  { // for tail recursion
		int i;
		int j;
		/* sort elements a[l], a[(l+u)/2] and a[u] */
		lua_rawgeti(L, 1, l);
		lua_rawgeti(L, 1, u);
		if (sort_comp(L, -1, -2) != 0) // a[u] < a[l]?
		{
		  set2(L, l, u); // swap a[l] - a[u]
		}
		else
		{
		  lua_settop(L, -(2) - 1);
		}
		if (u - l == 1)
		{
			break; // only 2 elements
		}
		i = (l + u) / 2;
		lua_rawgeti(L, 1, i);
		lua_rawgeti(L, 1, l);
		if (sort_comp(L, -2, -1) != 0) // a[i]<a[l]?
		{
		  set2(L, i, l);
		}
		else
		{
		  lua_settop(L, -(1) - 1); // remove a[l]
		  lua_rawgeti(L, 1, u);
		  if (sort_comp(L, -1, -2) != 0) // a[u]<a[i]?
		  {
			set2(L, i, u);
		  }
		  else
		  {
			lua_settop(L, -(2) - 1);
		  }
		}
		if (u - l == 2)
		{
			break; // only 3 elements
		}
		lua_rawgeti(L, 1, i); // Pivot
		lua_pushvalue(L, -1);
		lua_rawgeti(L, 1, u - 1);
		set2(L, i, u - 1);
		/* a[l] <= P == a[u-1] <= a[u], only need to sort from l+1 to u-2 */
		i = l;
		j = u - 1;
		for (;;)
		{ // invariant: a[l..i] <= P <= a[j..u]
		  /* repeat ++i until a[i] >= P */
		  while (lua_rawgeti(L, 1, ++i), sort_comp(L, -1, -2))
		  {
			if (i > u)
			{
				luaL_error(L, "invalid order function for sorting");
			}
			lua_settop(L, -(1) - 1); // remove a[i]
		  }
		  /* repeat --j until a[j] <= P */
		  while (lua_rawgeti(L, 1, --j), sort_comp(L, -3, -1))
		  {
			if (j < l)
			{
				luaL_error(L, "invalid order function for sorting");
			}
			lua_settop(L, -(1) - 1); // remove a[j]
		  }
		  if (j < i)
		  {
			lua_settop(L, -(3) - 1); // pop pivot, a[i], a[j]
			break;
		  }
		  set2(L, i, j);
		}
		lua_rawgeti(L, 1, u - 1);
		lua_rawgeti(L, 1, i);
		set2(L, u - 1, i); // swap pivot (a[u-1]) with a[i]
		/* a[l..i-1] <= a[i] == P <= a[i+1..u] */
		/* adjust so that smaller half is in [j..i] and larger one in [l..u] */
		if (i - l < u - i)
		{
		  j = l;
		  i = i - 1;
		  l = i + 2;
		}
		else
		{
		  j = i + 1;
		  i = u;
		  u = j - 2;
		}
		auxsort(L, j, i); // call recursively the smaller one
	  } // repeat the routine for the larger one
	}

	internal static int sort(lua_State L)
	{
	  luaL_checktype(L, 1, DefineConstants.LUA_TTABLE);
	  int = ((int)lua_objlen(L, 1));
	  luaL_checkstack(L, 40, ""); // assume array is smaller than 2^40
	  if (!(lua_type(L, (2)) <= 0)) // is there a 2nd argument?
	  {
		luaL_checktype(L, 2, DefineConstants.LUA_TFUNCTION);
	  }
	  lua_settop(L, 2); // make sure there is two arguments
	  auxsort(L, 1, n);
	  return 0;
	}

	/* }====================================================== */


	internal luaL_Reg[] tab_funcs =
	{
		new luaL_Reg("concat", tconcat),
		new luaL_Reg("foreach", @foreach),
		new luaL_Reg("foreachi", foreachi),
		new luaL_Reg("getn", getn),
		new luaL_Reg("maxn", maxn),
		new luaL_Reg("insert", tinsert),
		new luaL_Reg("remove", tremove),
		new luaL_Reg("setn", setn),
		new luaL_Reg("sort", sort),
		new luaL_Reg(null, null)
	};


	public static int luaopen_table(lua_State L)
	{
	  luaL_register(L, DefineConstants.LUA_TABLIBNAME, tab_funcs);
	  return 1;
	}





	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gfasttm(g,et,e) ((et) == NULL ? NULL : ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define fasttm(l,et,e) gfasttm(G(l), et, e)

//C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
	//extern const sbyte *const luaT_typenames[];


	private extern const lua_TValue * luaT_gettm(Table * events, TMS event, TString * ename);
	private extern const lua_TValue * luaT_gettmbyobj(struct lua_State * L, const lua_TValue * o, TMS event);
	public static void luaT_init(lua_State L)
	{
	  string[] luaT_eventname = {"__index", "__newindex", "__gc", "__mode", "__eq", "__add", "__sub", "__mul", "__div", "__mod", "__pow", "__unm", "__len", "__lt", "__le", "__concat", "__call"}; // ORDER TM
	  int i;
	  for (i = 0; i < TMS.TM_N; i++)
	  {
		(L.l_G).tmname[i] = (luaS_newlstr(L, luaT_eventname[i], Convert.ToString(luaT_eventname[i]).Length));
		((((L.l_G).tmname[i]).tsv.marked) |= ((1 << (DefineConstants.FIXEDBIT)))); // never collect these names
	  }
	}


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocv(L,b,on,n,e) ((cast(size_t, (n)+1) <= MAX_SIZET/(e)) ? luaM_realloc_(L, (b), (on)*(e), (n)*(e)) : luaM_toobig(L))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freemem(L, b, s) luaM_realloc_(L, (b), (s), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_free(L, b) luaM_realloc_(L, (b), sizeof(*(b)), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freearray(L, b, n, t) luaM_reallocv(L, (b), n, 0, sizeof(t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_malloc(L,t) luaM_realloc_(L, NULL, 0, (t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_new(L,t) cast(t *, luaM_malloc(L, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_newvector(L,n,t) cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_growvector(L,v,nelems,size,t,limit,e) if ((nelems)+1 > (size)) ((v)=cast(t *, luaM_growaux_(L,v,&(size),sizeof(t),limit,e)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocvector(L, v,oldn,n,t) ((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define char2int(c) cast(int, cast(unsigned char, (c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define zgetc(z) (((z)->n--)>0 ? char2int(*(z)->p++) : luaZ_fill(z))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_buffer(buff) ((buff)->buffer)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_sizebuffer(buff) ((buff)->buffsize)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_bufflen(buff) ((buff)->n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resetbuffer(buff) ((buff)->n = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resizebuffer(L, buff, size) (luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), (buff)->buffsize = size)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_freebuffer(L, buff) luaZ_resizebuffer(L, buff, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gt(L) (&L->l_gt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define registry(L) (&G(L)->l_registry)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BASIC_STACK_SIZE (2*LUA_MINSTACK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define curr_func(L) (clvalue(L->ci->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ci_func(ci) (clvalue((ci)->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define f_isLua(ci) (!ci_func(ci)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLua(ci) (ttisfunction((ci)->func) && f_isLua(ci))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define G(L) (L->l_G)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2ts(o) check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2ts(o) (&rawgco2ts(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2u(o) check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2u(o) (&rawgco2u(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2cl(o) check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2h(o) check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2p(o) check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2uv(o) check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ngcotouv(o) check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2th(o) check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define obj2gco(v) (cast(GCObject *, (v)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbits(x,m) ((x) &= cast(lu_byte, ~(m)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbits(x,m) ((x) |= (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbits(x,m) ((x) & (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bitmask(b) (1<<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bit2mask(b1,b2) (bitmask(b1) | bitmask(b2))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_setbit(x,b) setbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbit(x,b) resetbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbit(x,b) testbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define set2bits(x,b1,b2) setbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define reset2bits(x,b1,b2) resetbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define test2bits(x,b1,b2) testbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define WHITEBITS bit2mask(WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iswhite(x) test2bits((x)->gch.marked, WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isblack(x) testbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isgray(x) (!isblack(x) && !iswhite(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define otherwhite(g) (g->currentwhite ^ WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isdead(g,v) ((v)->gch.marked & otherwhite(g) & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define changewhite(x) ((x)->gch.marked ^= WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gray2black(x) l_setbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define valiswhite(x) (iscollectable(x) && iswhite(gcvalue(x)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_white(g) cast(lu_byte, (g)->currentwhite & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_checkGC(L) { condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1)); if (G(L)->totalbytes >= G(L)->GCthreshold) luaC_step(L); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),gcvalue(v)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barriert(L,t,v) { if (valiswhite(v) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarrier(L,p,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),obj2gco(o)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarriert(L,t,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizestring(s) (sizeof(union TString)+((s)->len+1)*sizeof(char))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeudata(u) (sizeof(union Udata)+(u)->len)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_new(L, s) (luaS_newlstr(L, s, strlen(s)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_newliteral(L, s) (luaS_newlstr(L, "" s, (sizeof(s)/sizeof(char))-1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_fix(s) l_setbit((s)->tsv.marked, FIXEDBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gnode(t,i) (&(t)->node[i])
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gkey(n) (&(n)->i_key.nk)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gval(n) (&(n)->i_val)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gnext(n) ((n)->i_key.nk.next)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define key2tval(n) (&(n)->i_key.tvk)



	public static readonly string[] luaT_typenames = {"nil", "boolean", "userdata", "number", "string", "table", "function", "userdata", "thread", "proto", "upval"};


	/*
	** function to be used with macro "fasttm": optimized for absence of
	** tag methods
	*/
	private const lua_TValue * luaT_gettm(Table * events, TMS event, TString * ename)
	{
	  lua_TValue tm = luaH_getstr(events, ename);
	  (c)(0)(event <= TMS.TM_EQ);
	  if ((((tm).tt) == DefineConstants.LUA_TNIL))
	  { // no tag method?
		events.flags |= ((byte)((1u << event))); // cache this fact
		return null;
	  }
	  else
	  {
		  return tm;
	  }
	}


	private const lua_TValue * luaT_gettmbyobj(struct lua_State * L, const lua_TValue * o, TMS event)
	{
	  Table[] mt;
	  switch (((o).tt))
	  {
		case DefineConstants.LUA_TTABLE:
		  mt = check_exp((((o).tt) == DefineConstants.LUA_TTABLE), (o).value.gc.h).metatable;
		  break;
		case DefineConstants.LUA_TUSERDATA:
		  mt = (check_exp((((o).tt) == DefineConstants.LUA_TUSERDATA), (o).value.gc.u).uv).metatable;
		  break;
		default:
		  mt = (L.l_G).mt[((o).tt)];
	  break;
	  }
	  return (mt ? luaH_getstr(mt, (L.l_G).tmname[event]) : (luaO_nilobject_));
	}




	/* type of numbers in Lua */


	/* type for integer functions */



	/*
	** state manipulation
	*/
	extern struct lua_State * (lua_newstate)(lua_Alloc f, object * ud);
	extern void(lua_close)(struct lua_State * L);
	extern struct lua_State * (lua_newthread)(struct lua_State * L);

	extern lua_CFunction(lua_atpanic)(struct lua_State * L, lua_CFunction panicf);


	/*
	** basic stack manipulation
	*/
	extern int(lua_gettop)(struct lua_State * L);
	extern void(lua_settop)(struct lua_State * L, int idx);
	extern void(lua_pushvalue)(struct lua_State * L, int idx);
	extern void(lua_remove)(struct lua_State * L, int idx);
	extern void(lua_insert)(struct lua_State * L, int idx);
	extern void(lua_replace)(struct lua_State * L, int idx);
	extern int(lua_checkstack)(struct lua_State * L, int sz);

	extern void(lua_xmove)(struct lua_State * from, struct lua_State * to, int n);


	/*
	** access functions (stack -> C)
	*/

	extern int(lua_isnumber)(struct lua_State * L, int idx);
	extern int(lua_isstring)(struct lua_State * L, int idx);
	extern int(lua_iscfunction)(struct lua_State * L, int idx);
	extern int(lua_isuserdata)(struct lua_State * L, int idx);
	extern int(lua_type)(struct lua_State * L, int idx);
	extern const sbyte * (lua_typename)(struct lua_State * L, int tp);

	extern int(lua_equal)(struct lua_State * L, int idx1, int idx2);
	extern int(lua_rawequal)(struct lua_State * L, int idx1, int idx2);
	extern int(lua_lessthan)(struct lua_State * L, int idx1, int idx2);

	extern double(lua_tonumber)(struct lua_State * L, int idx);
	extern ptrdiff_t(lua_tointeger)(struct lua_State * L, int idx);
	extern int(lua_toboolean)(struct lua_State * L, int idx);
	extern const sbyte * (lua_tolstring)(struct lua_State * L, int idx, size_t * len);
	extern size_t(lua_objlen)(struct lua_State * L, int idx);
	extern lua_CFunction(lua_tocfunction)(struct lua_State * L, int idx);
	extern object * (lua_touserdata)(struct lua_State * L, int idx);
	extern struct lua_State * (lua_tothread)(struct lua_State * L, int idx);
	extern const object * (lua_topointer)(struct lua_State * L, int idx);


	/*
	** push functions (C -> stack)
	*/
	extern void(lua_pushnil)(struct lua_State * L);
	extern void(lua_pushnumber)(struct lua_State * L, double n);
	extern void(lua_pushinteger)(struct lua_State * L, ptrdiff_t n);
	extern void(lua_pushlstring)(struct lua_State * L, const sbyte * s, size_t l);
	extern void(lua_pushstring)(struct lua_State * L, const sbyte * s);
	extern const sbyte * (lua_pushvfstring)(struct lua_State * L, const sbyte * fmt, va_list argp);
	extern const sbyte * (lua_pushfstring)(struct lua_State * L, const sbyte * fmt, ...);
	extern void(lua_pushcclosure)(struct lua_State * L, lua_CFunction fn, int n);
	extern void(lua_pushboolean)(struct lua_State * L, int b);
	extern void(lua_pushlightuserdata)(struct lua_State * L, object * p);
	extern int(lua_pushthread)(struct lua_State * L);


	/*
	** get functions (Lua -> stack)
	*/
	extern void(lua_gettable)(struct lua_State * L, int idx);
	extern void(lua_getfield)(struct lua_State * L, int idx, const sbyte * k);
	extern void(lua_rawget)(struct lua_State * L, int idx);
	extern void(lua_rawgeti)(struct lua_State * L, int idx, int n);
	extern void(lua_createtable)(struct lua_State * L, int narr, int nrec);
	extern object * (lua_newuserdata)(struct lua_State * L, size_t sz);
	extern int(lua_getmetatable)(struct lua_State * L, int objindex);
	extern void(lua_getfenv)(struct lua_State * L, int idx);


	/*
	** set functions (stack -> Lua)
	*/
	extern void(lua_settable)(struct lua_State * L, int idx);
	extern void(lua_setfield)(struct lua_State * L, int idx, const sbyte * k);
	extern void(lua_rawset)(struct lua_State * L, int idx);
	extern void(lua_rawseti)(struct lua_State * L, int idx, int n);
	extern int(lua_setmetatable)(struct lua_State * L, int objindex);
	extern int(lua_setfenv)(struct lua_State * L, int idx);


	/*
	** `load' and `call' functions (load and run Lua code)
	*/
	extern void(lua_call)(struct lua_State * L, int nargs, int nresults);
	extern int(lua_pcall)(struct lua_State * L, int nargs, int nresults, int errfunc);
	extern int(lua_cpcall)(struct lua_State * L, lua_CFunction func, object * ud);
	extern int(lua_load)(struct lua_State * L, lua_Reader reader, object * dt, const sbyte * chunkname);

	extern int(lua_dump)(struct lua_State * L, lua_Writer writer, object * data);


	/*
	** coroutine functions
	*/
	extern int(lua_yield)(struct lua_State * L, int nresults);
	extern int(lua_resume)(struct lua_State * L, int narg);
	extern int(lua_status)(struct lua_State * L);

	/*
	** garbage-collection function and options
	*/


	extern int(lua_gc)(struct lua_State * L, int what, int data);


	/*
	** miscellaneous functions
	*/

	extern int(lua_error)(struct lua_State * L);

	extern int(lua_next)(struct lua_State * L, int idx);

	extern void(lua_concat)(struct lua_State * L, int n);

	extern lua_Alloc(lua_getallocf)(struct lua_State * L, object * *ud);
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void lua_setallocf(lua_State L, lua_Alloc f, object ud);



	/* 
	** ===============================================================
	** some useful macros
	** ===============================================================
	*/

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)



	/*
	** compatibility macros and functions
	*/

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer


	/* hack */
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void lua_setlevel(lua_State from, lua_State to);


	/*
	** {======================================================================
	** Debug API
	** =======================================================================
	*/


	/*
	** Event codes
	*/


	/*
	** Event masks
	*/
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)



	/* Functions to be called by the debuger in specific events */
	public delegate void lua_Hook(lua_State L, lua_Debug ar);


//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//int lua_getstack(lua_State L, int level, lua_Debug ar);
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//int lua_getinfo(lua_State L, string what, lua_Debug ar);
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string lua_getlocal(lua_State L, lua_Debug ar, int n);
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string lua_setlocal(lua_State L, lua_Debug ar, int n);
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string lua_getupvalue(lua_State L, int funcindex, int n);
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//string lua_setupvalue(lua_State L, int funcindex, int n);

//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//int lua_sethook(lua_State L, lua_Hook func, int mask, int count);
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//lua_Hook lua_gethook(lua_State L);
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//int lua_gethookmask(lua_State L);
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//int lua_gethookcount(lua_State L);

	/* }====================================================================== */


	/******************************************************************************
	* Copyright (C) 1994-2008 Lua.org, PUC-Rio.  All rights reserved.
	*
	* Permission is hereby granted, free of charge, to any person obtaining
	* a copy of this software and associated documentation files (the
	* "Software"), to deal in the Software without restriction, including
	* without limitation the rights to use, copy, modify, merge, publish,
	* distribute, sublicense, and/or sell copies of the Software, and to
	* permit persons to whom the Software is furnished to do so, subject to
	* the following conditions:
	*
	* The above copyright notice and this permission notice shall be
	* included in all copies or substantial portions of the Software.
	*
	* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	******************************************************************************/




	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getn(L,i) ((int)lua_objlen(L, i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_setn(L,i,j) ((void)0)
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define luaL_setn
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaI_openlib luaL_openlib
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_ERRFILE (LUA_ERRERR+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_argcheck(L, cond,numarg,extramsg) ((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkstring(L,n) (luaL_checklstring(L, (n), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optstring(L,n,d) (luaL_optlstring(L, (n), (d), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkint(L,n) ((int)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optint(L,n,d) ((int)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checklong(L,n) ((long)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optlong(L,n,d) ((long)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_typename(L,i) lua_typename(L, lua_type(L,(i)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dofile(L, fn) (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dostring(L, s) (luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getmetatable(L,n) (lua_getfield(L, LUA_REGISTRYINDEX, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_opt(L,f,n,d) (lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addchar(B,c) ((void)((B)->p < ((B)->buffer+LUAL_BUFFERSIZE) || luaL_prepbuffer(B)), (*(B)->p++ = (char)(c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_putchar(B,c) luaL_addchar(B,c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addsize(B,n) ((B)->p += (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_ref(L,lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : (lua_pushstring(L, "unlocked references are obsolete"), lua_error(L), 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unref(L,ref) luaL_unref(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getref(L,ref) lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_reg luaL_Reg
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(x) ((void)0)



	internal static lua_State globalL = null;

	internal string progname = DefineConstants.LUA_PROGNAME;



	internal static void lstop(lua_State L, lua_Debug ar)
	{
	  ar; // unused arg.
	  lua_sethook(L, null, 0, 0);
	  luaL_error(L, "interrupted!");
	}


	internal static void laction(int i)
	{
	  signal(i, SIG_DFL); /* if another SIGINT happens before lstop,
	                              terminate process (default action) */
	  lua_sethook(globalL, lstop, (1 << DefineConstants.LUA_HOOKCALL) | (1 << DefineConstants.LUA_HOOKRET) | (1 << DefineConstants.LUA_HOOKCOUNT), 1);
	}


	internal static void print_usage()
	{
	  Console.Error.Write("usage: {0} [options] [script [args]].\n" + "Available options are:\n" + "  -e stat  execute string " "'" "stat" "'" "\n" + "  -l name  require library " "'" "name" "'" "\n" + "  -i       enter interactive mode after executing " "'" "script" "'" "\n" + "  -v       show version information\n" + "  --       stop handling options\n" + "  -        execute stdin and stop handling options\n", progname);
	  fflush(stderr);
	}


	internal static void l_message(string pname, string msg)
	{
	  if (pname != 0)
	  {
		  Console.Error.Write("{0}: ", pname);
	  }
	  Console.Error.Write("{0}\n", msg);
	  fflush(stderr);
	}


	internal static int report(lua_State L, int status)
	{
	  if (status != 0 && !(lua_type(L, (-1)) == DefineConstants.LUA_TNIL))
	  {
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *msg = lua_tolstring(L, (-1), null);
		sbyte msg = lua_tolstring(L, (-1), null);
		if (msg == null)
		{
			msg = "(error object is not a string)";
		}
		l_message(progname, msg);
		lua_settop(L, -(1) - 1);
	  }
	  return status;
	}


	internal static int traceback(lua_State L)
	{
	  if (!lua_isstring(L, 1)) // 'message' not a string?
	  {
		return 1; // keep it intact
	  }
	  lua_getfield(L, DefineConstants.LUA_GLOBALSINDEX, "debug");
	  if (!(lua_type(L, (-1)) == DefineConstants.LUA_TTABLE))
	  {
		lua_settop(L, -(1) - 1);
		return 1;
	  }
	  lua_getfield(L, -1, "traceback");
	  if (!(lua_type(L, (-1)) == DefineConstants.LUA_TFUNCTION))
	  {
		lua_settop(L, -(2) - 1);
		return 1;
	  }
	  lua_pushvalue(L, 1); // pass error message
	  lua_pushinteger(L, 2); // skip this function and traceback
	  lua_call(L, 2, 1); // call debug.traceback
	  return 1;
	}


	internal static int docall(lua_State L, int narg, int clear)
	{
	  int status;
	  int @base = lua_gettop(L) - narg; // function index
	  lua_pushcclosure(L, (traceback), 0); // push traceback function
	  lua_insert(L, @base); // put it under chunk and args
	  signal(SIGINT, laction);
	  status = lua_pcall(L, narg, (clear != 0 ? 0 : DefineConstants.LUA_MULTRET), @base);
	  signal(SIGINT, SIG_DFL);
	  lua_remove(L, @base); // remove traceback function
	  /* force a complete garbage collection in case of errors */
	  if (status != 0)
	  {
		  lua_gc(L, DefineConstants.LUA_GCCOLLECT, 0);
	  }
	  return status;
	}


	internal static void print_version()
	{
	  l_message(null, DefineConstants.LUA_RELEASE "  " DefineConstants.LUA_COPYRIGHT);
	}


	internal static int getargs(lua_State L, string[] argv, int n)
	{
	  int narg;
	  int i;
	  int argc = 0;
	  while (argv[argc] != null)
	  {
		  argc++; // count total number of arguments
	  }
	  narg = argc - (n + 1); // number of arguments to the script
	  luaL_checkstack(L, narg + 3, "too many arguments to script");
	  for (i = n + 1; i < argc; i++)
	  {
		lua_pushstring(L, argv[i]);
	  }
	  lua_createtable(L, narg, n + 1);
	  for (i = 0; i < argc; i++)
	  {
		lua_pushstring(L, argv[i]);
		lua_rawseti(L, -2, i - n);
	  }
	  return narg;
	}


	internal static int dofile(lua_State L, string name)
	{
	  int status = luaL_loadfile(L, name) || docall(L, 0, 1) != 0;
	  return report(L, status);
	}


	internal static int dostring(lua_State L, string s, string name)
	{
	  int status = luaL_loadbuffer(L, s, s.Length, name) || docall(L, 0, 1) != 0;
	  return report(L, status);
	}


	internal static int dolibrary(lua_State L, string name)
	{
	  lua_getfield(L, DefineConstants.LUA_GLOBALSINDEX, ("require"));
	  lua_pushstring(L, name);
	  return report(L, docall(L, 1, 1));
	}


	internal static string get_prompt(lua_State L, int firstline)
	{
	  string p;
	  lua_getfield(L, DefineConstants.LUA_GLOBALSINDEX, firstline != 0 ? "_PROMPT" : "_PROMPT2");
	  p = lua_tolstring(L, (-1), null);
	  if (p == null)
	  {
		  p = (firstline != 0 ? DefineConstants.LUA_PROMPT : DefineConstants.LUA_PROMPT2);
	  }
	  lua_settop(L, -(1) - 1); // remove global
	  return p;
	}


	internal static int incomplete(lua_State L, int status)
	{
	  if (status == DefineConstants.LUA_ERRSYNTAX)
	  {
		size_t lmsg = new size_t();
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *msg = lua_tolstring(L, -1, &lmsg);
		sbyte msg = lua_tolstring(L, -1, lmsg);
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *tp = msg + lmsg - (sizeof("'" "<eof>" "'") - 1);
		sbyte tp = msg + lmsg - (sizeof("'" "<eof>" "'") - 1);
		if (StringFunctions.StrStr(msg, "'" "<eof>" "'") == tp)
		{
		  lua_settop(L, -(1) - 1);
		  return 1;
		}
	  }
	  return 0; // else...
	}


	internal static int pushline(lua_State L, int firstline)
	{
	  string buffer = new string(new char[DefineConstants.LUA_MAXINPUT]);
	  string b = buffer;
	  size_t l = new size_t();
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: const sbyte *prmt = get_prompt(L, firstline);
	  sbyte prmt = get_prompt(L, firstline);
	  if (lua_readline(L, b, prmt) == 0)
	  {
		return 0; // no input
	  }
	  l = b.Length;
	  if (l > 0 && b[l - 1] == '\n') // line ends with newline?
	  {
		b = StringFunctions.ChangeCharacter(b, l - 1, '\0'); // remove it
	  }
	  if (firstline != 0 && b[0] == '=') // first line starts with `=' ?
	  {
		lua_pushfstring(L, "return %s", b.Substring(1)); // change it to `return'
	  }
	  else
	  {
		lua_pushstring(L, b);
	  }
	  lua_freeline(L, b);
	  return 1;
	}


	internal static int loadline(lua_State L)
	{
	  int status;
	  lua_settop(L, 0);
	  if (pushline(L, 1) == 0)
	  {
		return -1; // no input
	  }
	  for (;;)
	  { // repeat until gets a complete line
		status = luaL_loadbuffer(L, lua_tolstring(L, (1), null), lua_objlen(L, (1)), "=stdin");
		if (incomplete(L, status) == 0)
		{
			break; // cannot try to add lines?
		}
		if (pushline(L, 0) == 0) // no more input?
		{
		  return -1;
		}
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: lua_pushlstring(L, "" "\n", (sizeof("\n")/sizeof(sbyte))-1);
		lua_pushlstring(L, "" "\n", (("\n").Length) - 1); // add a new line...
		lua_insert(L, -2); // ...between the two lines
		lua_concat(L, 3); // join them
	  }
	  lua_saveline(L, 1);
	  lua_remove(L, 1); // remove line
	  return status;
	}


	internal static void dotty(lua_State L)
	{
	  int status;
	  string oldprogname = progname;
	  progname = null;
	  while ((status = loadline(L)) != -1)
	  {
		if (status == 0)
		{
			status = docall(L, 0, 0);
		}
		report(L, status);
		if (status == 0 && lua_gettop(L) > 0)
		{ // any result to print?
		  lua_getfield(L, DefineConstants.LUA_GLOBALSINDEX, ("print"));
		  lua_insert(L, 1);
		  if (lua_pcall(L, lua_gettop(L) - 1, 0, 0) != 0)
		  {
			l_message(progname, lua_pushfstring(L, "error calling " "'" "print" "'" " (%s)", lua_tolstring(L, (-1), null)));
		  }
		}
	  }
	  lua_settop(L, 0); // clear stack
	  fputs("\n", stdout);
	  fflush(stdout);
	  progname = oldprogname;
	}


	internal static int handle_script(lua_State L, string[] argv, int n)
	{
	  int status;
	  string fname;
	  int narg = getargs(L, argv, n); // collect arguments
	  lua_setfield(L, DefineConstants.LUA_GLOBALSINDEX, ("arg"));
	  fname = argv[n];
	  if (string.Compare(fname, "-") == 0 && string.Compare(argv[n - 1], "--") != 0)
	  {
		fname = null; // stdin
	  }
	  status = luaL_loadfile(L, fname);
	  lua_insert(L, -(narg + 1));
	  if (status == 0)
	  {
		status = docall(L, narg, 0);
	  }
	  else
	  {
		lua_settop(L, -(narg) - 1);
	  }
	  return report(L, status);
	}


	/* check that argument has no extra characters at the end */
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define notail(x) {if ((x)[2] != '\0') return -1;}


	internal static int collectargs(string[] argv, ref int pi, ref int pv, ref int pe)
	{
	  int i;
	  for (i = 1; argv[i] != null; i++)
	  {
		if (argv[i][0] != '-') // not an option?
		{
			return i;
		}
		switch (argv[i][1])
		{ // option
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		  case '-':
		  {
				if ((argv[i])[2] != '\0')
				{
					return -1;
				}
		  };
			return (argv[i + 1] != null ? i + 1 : 0);
		  case '\0':
			return i;
		  case 'i':
		  {
				if ((argv[i])[2] != '\0')
				{
					return -1;
				}
		  };
			pi = 1; // go through
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		  case 'v':
		  {
				if ((argv[i])[2] != '\0')
				{
					return -1;
				}
		  };
			pv = 1;
			break;
		  case 'e':
			pe = 1; // go through
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		  case 'l':
			if (argv[i][2] == '\0')
			{
			  i++;
			  if (argv[i] == null)
			  {
				  return -1;
			  }
			}
			break;
		  default:
			  return -1; // invalid option
		}
	  }
	  return 0;
	}


	internal static int runargs(lua_State L, string[] argv, int n)
	{
	  int i;
	  for (i = 1; i < n; i++)
	  {
		if (argv[i] == null)
		{
			continue;
		}
		(x)(0)(argv[i][0] == '-');
		switch (argv[i][1])
		{ // option
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		  case 'e':
		  {
			string chunk = argv[i] + 2;
			if (chunk == (sbyte)'\0')
			{
				chunk = argv[++i];
			}
			(x)(0)(chunk != null);
			if (dostring(L, chunk, "=(command line)") != 0)
			{
			  return 1;
			}
			break;
		  }
		  case 'l':
		  {
			string filename = argv[i] + 2;
			if (filename == (sbyte)'\0')
			{
				filename = argv[++i];
			}
			(x)(0)(filename != null);
			if (dolibrary(L, filename) != 0)
			{
			  return 1; // stop if file fails
			}
			break;
		  }
		  default:
			  break;
		}
	  }
	  return 0;
	}


	internal static int handle_luainit(lua_State L)
	{
	  sbyte[] init = getenv(DefineConstants.LUA_INIT);
	  if (init == null)
	  {
		  return 0; // status OK
	  }
	  else if (init[0] == (sbyte)'@')
	  {
		return dofile(L, init + 1);
	  }
	  else
	  {
		return dostring(L, init, "=" DefineConstants.LUA_INIT);
	  }
	}


	internal static int pmain(lua_State L)
	{
	  Smain s = (Smain)lua_touserdata(L, 1);
	  string[] argv = s.argv;
	  int script;
	  int has_i = 0;
	  int has_v = 0;
	  int has_e = 0;
	  globalL = L;
	  if (argv[0] != 0 && argv[0][0])
	  {
		  progname = argv[0];
	  }
	  lua_gc(L, DefineConstants.LUA_GCSTOP, 0); // stop collector during initialization
	  luaL_openlibs(L); // open libraries
	  lua_gc(L, DefineConstants.LUA_GCRESTART, 0);
	  s.status = handle_luainit(L);
	  if (s.status != 0)
	  {
		  return 0;
	  }
	  script = collectargs(argv, ref has_i, ref has_v, ref has_e);
	  if (script < 0)
	  { // invalid args?
		print_usage();
		s.status = 1;
		return 0;
	  }
	  if (has_v != 0)
	  {
		  print_version();
	  }
	  s.status = runargs(L, argv, (script > 0) ? script : s.argc);
	  if (s.status != 0)
	  {
		  return 0;
	  }
	  if (script != 0)
	  {
		s.status = handle_script(L, argv, script);
	  }
	  if (s.status != 0)
	  {
		  return 0;
	  }
	  if (has_i != 0)
	  {
		dotty(L);
	  }
	  else if (script == 0 && has_e == 0 && has_v == 0)
	  {
		if (true)
		{
		  print_version();
		  dotty(L);
		}
		else
		{
			dofile(L, null); // executes stdin as a file
		}
	  }
	  return 0;
	}


	static int Main(int argc, string[] args)
	{
	  int status;
	  Smain s = new Smain();
	  lua_State L = luaL_newstate(); // create state
	  if (L == null)
	  {
		l_message(args[0], "cannot create state: not enough memory");
		return EXIT_FAILURE;
	  }
	  s.argc = argc;
	  s.argv = args;
	  status = lua_cpcall(L, pmain, s);
	  report(L, status);
	  lua_close(L);
	  return (status != 0 || s.status != 0) ? EXIT_FAILURE : EXIT_SUCCESS;
	}


	/*
	** $Id: luac.c,v 1.54 2006/06/02 17:37:11 lhf Exp $
	** Lua compiler (saves bytecodes to files; also list bytecodes)
	** See Copyright Notice in lua.h
	*/



//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DYLD
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_VARARG
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_MOD
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_LSTR
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_GFIND
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_OPENLIB
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUAI_BITSINT
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUAI_BITSINT
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DLOPEN
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DLL
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getn(L,i) ((int)lua_objlen(L, i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_setn(L,i,j) ((void)0)
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define luaL_setn
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaI_openlib luaL_openlib
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_ERRFILE (LUA_ERRERR+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_argcheck(L, cond,numarg,extramsg) ((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkstring(L,n) (luaL_checklstring(L, (n), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optstring(L,n,d) (luaL_optlstring(L, (n), (d), NULL))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checkint(L,n) ((int)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optint(L,n,d) ((int)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_checklong(L,n) ((long)luaL_checkinteger(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_optlong(L,n,d) ((long)luaL_optinteger(L, (n), (d)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_typename(L,i) lua_typename(L, lua_type(L,(i)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dofile(L, fn) (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_dostring(L, s) (luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_getmetatable(L,n) (lua_getfield(L, LUA_REGISTRYINDEX, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_opt(L,f,n,d) (lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addchar(B,c) ((void)((B)->p < ((B)->buffer+LUAL_BUFFERSIZE) || luaL_prepbuffer(B)), (*(B)->p++ = (char)(c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_putchar(B,c) luaL_addchar(B,c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_addsize(B,n) ((B)->p += (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_ref(L,lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : (lua_pushstring(L, "unlocked references are obsolete"), lua_error(L), 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unref(L,ref) luaL_unref(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getref(L,ref) lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaL_reg luaL_Reg

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_SIZET ((size_t)(~(size_t)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_LUMEM ((lu_mem)(~(lu_mem)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_INT (INT_MAX-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IntPoint(p) ((unsigned int)(lu_mem)(p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (lua_assert(c), (e))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check(l,e) lua_assert(e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(c) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check luai_apicheck
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define UNUSED(x) ((void)(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast(t, exp) ((t)(exp))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_byte(i) cast(lu_byte, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_num(i) cast(lua_Number, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_int(i) cast(int, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_lock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unlock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_threadyield(L) {lua_unlock(L); lua_lock(L);}
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) x
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LAST_TAG LUA_TTHREAD
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NUM_TAGS (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TPROTO (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TUPVAL (LAST_TAG+2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TDEADKEY (LAST_TAG+3)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define CommonHeader GCObject *next; lu_byte tt; lu_byte marked
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define TValuefields Value value; int tt
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnil(o) (ttype(o) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnumber(o) (ttype(o) == LUA_TNUMBER)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisstring(o) (ttype(o) == LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttistable(o) (ttype(o) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisfunction(o) (ttype(o) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisboolean(o) (ttype(o) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisuserdata(o) (ttype(o) == LUA_TUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisthread(o) (ttype(o) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttislightuserdata(o) (ttype(o) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttype(o) ((o)->tt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gcvalue(o) check_exp(iscollectable(o), (o)->value.gc)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pvalue(o) check_exp(ttislightuserdata(o), (o)->value.p)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define nvalue(o) check_exp(ttisnumber(o), (o)->value.n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawtsvalue(o) check_exp(ttisstring(o), &(o)->value.gc->ts)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define tsvalue(o) (&rawtsvalue(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawuvalue(o) check_exp(ttisuserdata(o), &(o)->value.gc->u)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define uvalue(o) (&rawuvalue(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define clvalue(o) check_exp(ttisfunction(o), &(o)->value.gc->cl)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define hvalue(o) check_exp(ttistable(o), &(o)->value.gc->h)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bvalue(o) check_exp(ttisboolean(o), (o)->value.b)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define thvalue(o) check_exp(ttisthread(o), &(o)->value.gc->th)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_isfalse(o) (ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkconsistency(obj) lua_assert(!iscollectable(obj) || (ttype(obj) == (obj)->value.gc->gch.tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkliveness(g,obj) lua_assert(!iscollectable(obj) || ((ttype(obj) == (obj)->value.gc->gch.tt) && !isdead(g, (obj)->value.gc)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnilvalue(obj) ((obj)->tt=LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnvalue(obj,x) { TValue *i_o=(obj); i_o->value.n=(x); i_o->tt=LUA_TNUMBER; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setpvalue(obj,x) { TValue *i_o=(obj); i_o->value.p=(x); i_o->tt=LUA_TLIGHTUSERDATA; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbvalue(obj,x) { TValue *i_o=(obj); i_o->value.b=(x); i_o->tt=LUA_TBOOLEAN; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TSTRING; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setuvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TUSERDATA; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setthvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTHREAD; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setclvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TFUNCTION; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTABLE; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TPROTO; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj(L,obj1,obj2) { const TValue *o2=(obj2); TValue *o1=(obj1); o1->value = o2->value; o1->tt=o2->tt; checkliveness(G(L),o1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjs2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2s setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue2s sethvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue2s setptvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjt2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2n setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2n setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setttype(obj, tt) (ttype(obj) = (tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscollectable(o) (ttype(o) >= LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getstr(ts) cast(const char *, (ts) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define svalue(o) getstr(rawtsvalue(o))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ClosureHeader CommonHeader; lu_byte isC; lu_byte nupvalues; GCObject *gclist; struct Table *env
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscfunction(o) (ttype(o) == LUA_TFUNCTION && clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLfunction(o) (ttype(o) == LUA_TFUNCTION && !clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lmod(s,size) (check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define twoto(x) (1<<(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizenode(t) (twoto((t)->lsizenode))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaO_nilobject (&luaO_nilobject_)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ceillog2(x) (luaO_log2((x)-1) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gfasttm(g,et,e) ((et) == NULL ? NULL : ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define fasttm(l,et,e) gfasttm(G(l), et, e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocv(L,b,on,n,e) ((cast(size_t, (n)+1) <= MAX_SIZET/(e)) ? luaM_realloc_(L, (b), (on)*(e), (n)*(e)) : luaM_toobig(L))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freemem(L, b, s) luaM_realloc_(L, (b), (s), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_free(L, b) luaM_realloc_(L, (b), sizeof(*(b)), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freearray(L, b, n, t) luaM_reallocv(L, (b), n, 0, sizeof(t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_malloc(L,t) luaM_realloc_(L, NULL, 0, (t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_new(L,t) cast(t *, luaM_malloc(L, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_newvector(L,n,t) cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_growvector(L,v,nelems,size,t,limit,e) if ((nelems)+1 > (size)) ((v)=cast(t *, luaM_growaux_(L,v,&(size),sizeof(t),limit,e)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocvector(L, v,oldn,n,t) ((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define char2int(c) cast(int, cast(unsigned char, (c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define zgetc(z) (((z)->n--)>0 ? char2int(*(z)->p++) : luaZ_fill(z))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_buffer(buff) ((buff)->buffer)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_sizebuffer(buff) ((buff)->buffsize)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_bufflen(buff) ((buff)->n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resetbuffer(buff) ((buff)->n = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resizebuffer(L, buff, size) (luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), (buff)->buffsize = size)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_freebuffer(L, buff) luaZ_resizebuffer(L, buff, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gt(L) (&L->l_gt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define registry(L) (&G(L)->l_registry)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BASIC_STACK_SIZE (2*LUA_MINSTACK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define curr_func(L) (clvalue(L->ci->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ci_func(ci) (clvalue((ci)->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define f_isLua(ci) (!ci_func(ci)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLua(ci) (ttisfunction((ci)->func) && f_isLua(ci))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define G(L) (L->l_G)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2ts(o) check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2ts(o) (&rawgco2ts(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2u(o) check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2u(o) (&rawgco2u(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2cl(o) check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2h(o) check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2p(o) check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2uv(o) check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ngcotouv(o) check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2th(o) check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define obj2gco(v) (cast(GCObject *, (v)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaD_checkstack(L,n) if ((char *)L->stack_last - (char *)L->top <= (n)*(int)sizeof(TValue)) luaD_growstack(L, n); else condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define incr_top(L) {luaD_checkstack(L,1); L->top++;}
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define savestack(L,p) ((char *)(p) - (char *)L->stack)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define restorestack(L,n) ((TValue *)((char *)L->stack + (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define saveci(L,p) ((char *)(p) - (char *)L->base_ci)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define restoreci(L,n) ((CallInfo *)((char *)L->base_ci + (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeCclosure(n) (cast(int, sizeof(CClosure)) + cast(int, sizeof(TValue)*((n)-1)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeLclosure(n) (cast(int, sizeof(LClosure)) + cast(int, sizeof(TValue *)*((n)-1)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SIZE_Bx (SIZE_C + SIZE_B)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define POS_A (POS_OP + SIZE_OP)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define POS_C (POS_A + SIZE_A)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define POS_B (POS_C + SIZE_C)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define POS_Bx POS_C
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_Bx ((1<<SIZE_Bx)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_sBx (MAXARG_Bx>>1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_Bx MAX_INT
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_sBx MAX_INT
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_A ((1<<SIZE_A)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_B ((1<<SIZE_B)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_C ((1<<SIZE_C)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MASK1(n,p) ((~((~(Instruction)0)<<n))<<p)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MASK0(n,p) (~MASK1(n,p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GET_OPCODE(i) (cast(OpCode, ((i)>>POS_OP) & MASK1(SIZE_OP,0)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SET_OPCODE(i,o) ((i) = (((i)&MASK0(SIZE_OP,POS_OP)) | ((cast(Instruction, o)<<POS_OP)&MASK1(SIZE_OP,POS_OP))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GETARG_A(i) (cast(int, ((i)>>POS_A) & MASK1(SIZE_A,0)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SETARG_A(i,u) ((i) = (((i)&MASK0(SIZE_A,POS_A)) | ((cast(Instruction, u)<<POS_A)&MASK1(SIZE_A,POS_A))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GETARG_B(i) (cast(int, ((i)>>POS_B) & MASK1(SIZE_B,0)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SETARG_B(i,b) ((i) = (((i)&MASK0(SIZE_B,POS_B)) | ((cast(Instruction, b)<<POS_B)&MASK1(SIZE_B,POS_B))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GETARG_C(i) (cast(int, ((i)>>POS_C) & MASK1(SIZE_C,0)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SETARG_C(i,b) ((i) = (((i)&MASK0(SIZE_C,POS_C)) | ((cast(Instruction, b)<<POS_C)&MASK1(SIZE_C,POS_C))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GETARG_Bx(i) (cast(int, ((i)>>POS_Bx) & MASK1(SIZE_Bx,0)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SETARG_Bx(i,b) ((i) = (((i)&MASK0(SIZE_Bx,POS_Bx)) | ((cast(Instruction, b)<<POS_Bx)&MASK1(SIZE_Bx,POS_Bx))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GETARG_sBx(i) (GETARG_Bx(i)-MAXARG_sBx)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SETARG_sBx(i,b) SETARG_Bx((i),cast(unsigned int, (b)+MAXARG_sBx))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define CREATE_ABC(o,a,b,c) ((cast(Instruction, o)<<POS_OP) | (cast(Instruction, a)<<POS_A) | (cast(Instruction, b)<<POS_B) | (cast(Instruction, c)<<POS_C))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define CREATE_ABx(o,a,bc) ((cast(Instruction, o)<<POS_OP) | (cast(Instruction, a)<<POS_A) | (cast(Instruction, bc)<<POS_Bx))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BITRK (1 << (SIZE_B - 1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ISK(x) ((x) & BITRK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define INDEXK(r) ((int)(r) & ~BITRK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXINDEXRK (BITRK - 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define RKASK(x) ((x) | BITRK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NO_REG MAXARG_A
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NUM_OPCODES (cast(int, OP_VARARG) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getOpMode(m) (cast(enum OpMode, luaP_opmodes[m] & 3))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getBMode(m) (cast(enum OpArgMask, (luaP_opmodes[m] >> 4) & 3))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getCMode(m) (cast(enum OpArgMask, (luaP_opmodes[m] >> 2) & 3))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testAMode(m) (luaP_opmodes[m] & (1 << 6))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testTMode(m) (luaP_opmodes[m] & (1 << 7))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbits(x,m) ((x) &= cast(lu_byte, ~(m)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbits(x,m) ((x) |= (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbits(x,m) ((x) & (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bitmask(b) (1<<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bit2mask(b1,b2) (bitmask(b1) | bitmask(b2))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_setbit(x,b) setbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbit(x,b) resetbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbit(x,b) testbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define set2bits(x,b1,b2) setbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define reset2bits(x,b1,b2) resetbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define test2bits(x,b1,b2) testbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define WHITEBITS bit2mask(WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iswhite(x) test2bits((x)->gch.marked, WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isblack(x) testbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isgray(x) (!isblack(x) && !iswhite(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define otherwhite(g) (g->currentwhite ^ WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isdead(g,v) ((v)->gch.marked & otherwhite(g) & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define changewhite(x) ((x)->gch.marked ^= WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gray2black(x) l_setbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define valiswhite(x) (iscollectable(x) && iswhite(gcvalue(x)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_white(g) cast(lu_byte, (g)->currentwhite & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_checkGC(L) { condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1)); if (G(L)->totalbytes >= G(L)->GCthreshold) luaC_step(L); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),gcvalue(v)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barriert(L,t,v) { if (valiswhite(v) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarrier(L,p,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),obj2gco(o)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarriert(L,t,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizestring(s) (sizeof(union TString)+((s)->len+1)*sizeof(char))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeudata(u) (sizeof(union Udata)+(u)->len)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_new(L, s) (luaS_newlstr(L, s, strlen(s)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_newliteral(L, s) (luaS_newlstr(L, "" s, (sizeof(s)/sizeof(char))-1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_fix(s) l_setbit((s)->tsv.marked, FIXEDBIT)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define OUTPUT PROGNAME ".out"

	internal static int listing = 0; // list bytecodes?
	internal static int dumping = 1; // dump bytecodes?
	internal static int stripping = 0; // strip debug information?
	internal static sbyte[] Output = {DefineConstants.PROGNAME ".out"}; // default output file name
	internal string output = Output; // actual output file name
	internal string progname = DefineConstants.PROGNAME; // actual program name

	internal static void fatal(string message)
	{
	 Console.Error.Write("{0}: {1}\n",progname,message);
	 Environment.Exit(1);
	}

	internal static void cannot(string what)
	{
	 Console.Error.Write("{0}: cannot {1} {2}: {3}\n",progname,what,output,strerror(errno));
	 Environment.Exit(1);
	}

	internal static void usage(string message)
	{
	 if (message == (sbyte)'-')
	 {
	  Console.Error.Write("{0}: unrecognized option " "'" "{1}" "'" "\n",progname,message);
	 }
	 else
	 {
	  Console.Error.Write("{0}: {1}\n",progname,message);
	 }
	 Console.Error.Write("usage: {0} [options] [filenames].\n" + "Available options are:\n" + "  -        process stdin\n" + "  -l       list\n" + "  -o name  output to file " "'" "name" "'" " (default is \"{1}\")\n" + "  -p       parse only\n" + "  -s       strip debug information\n" + "  -v       show version information\n" + "  --       stop handling options\n", progname,Output);
	 Environment.Exit(1);
	}

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IS(s) (strcmp(argv[i],s)==0)

	internal static int doargs(int argc, string[] argv)
	{
	 int i;
	 int version = 0;
	 if (argv[0] != null && argv[0] != 0)
	 {
		 progname = argv[0];
	 }
	 for (i = 1; i < argc; i++)
	 {
	  if (argv[i] != '-') // end of options; keep it
	  {
	   break;
	  }
	  else if ((string.Compare(argv[i],"--") == 0)) // end of options; skip it
	  {
	   ++i;
	   if (version != 0)
	   {
		   ++version;
	   }
	   break;
	  }
	  else if ((string.Compare(argv[i],"-") == 0)) // end of options; use stdin
	  {
	   break;
	  }
	  else if ((string.Compare(argv[i],"-l") == 0)) // list
	  {
	   ++listing;
	  }
	  else if ((string.Compare(argv[i],"-o") == 0)) // output file
	  {
	   output = argv[++i];
	   if (output == null || *output == 0)
	   {
		   usage("'" "-o" "'" " needs argument");
	   }
	   if ((string.Compare(argv[i],"-") == 0))
	   {
		   output = null;
	   }
	  }
	  else if ((string.Compare(argv[i],"-p") == 0)) // parse only
	  {
	   dumping = 0;
	  }
	  else if ((string.Compare(argv[i],"-s") == 0)) // strip debug information
	  {
	   stripping = 1;
	  }
	  else if ((string.Compare(argv[i],"-v") == 0)) // show version
	  {
	   ++version;
	  }
	  else // unknown option
	  {
	   usage(argv[i]);
	  }
	 }
	 if (i == argc && (listing != 0 || dumping == 0))
	 {
	  dumping = 0;
	  argv[--i] = Output;
	 }
	 if (version != 0)
	 {
	  Console.Write("{0}  {1}\n",DefineConstants.LUA_RELEASE,DefineConstants.LUA_COPYRIGHT);
	  if (version == argc - 1)
	  {
		  Environment.Exit(0);
	  }
	 }
	 return i;
	}

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define toproto(L,i) (clvalue(L->top+(i))->l.p)

	internal static Proto combine(lua_State L, int n)
	{
	 if (n == 1)
	 {
	  return (check_exp((((L.top + (-1)).tt) == DefineConstants.LUA_TFUNCTION), (L.top + (-1)).value.gc.cl).l.p);
	 }
	 else
	 {
	  int i;
	  int pc;
	  Proto f = luaF_newproto(L);
	  {
		  lua_TValue i_o = (L.top);
		  i_o.value.gc = ((union GCObject)((f)));
		  i_o.tt = (DefineConstants.LUA_TTHREAD + 1);
		  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	  {
		  if ((string)L.stack_last - (string)L.top <= (1) * (int)sizeof(lua_TValue) != null)
		  {
			  luaD_growstack(L, 1);
		  }
		  else
		  {
			  (x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
		  }
		  ;
		  L.top++;
  };
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: f->source=(luaS_newlstr(L, "" "=(" DefineConstants.PROGNAME ")", (sizeof("=(" DefineConstants.PROGNAME ")")/sizeof(sbyte))-1));
	  f.source = (luaS_newlstr(L, "" "=(" DefineConstants.PROGNAME ")", (("=(" DefineConstants.PROGNAME ")").Length) - 1));
	  f.maxstacksize = 1;
	  pc = 2 * n + 1;
	  f.code = ((LUAI_UINT32)(((cast(size_t, (pc) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(LUAI_UINT32))) ? luaM_realloc_(L, (null), (0) * (sizeof(LUAI_UINT32)), (pc) * (sizeof(LUAI_UINT32))) : luaM_toobig(L))));
	  f.sizecode = pc;
	  f.p = ((Proto)(((cast(size_t, (n) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(Proto))) ? luaM_realloc_(L, (null), (0) * (sizeof(Proto)), (n) * (sizeof(Proto))) : luaM_toobig(L))));
	  f.sizep = n;
	  pc = 0;
	  for (i = 0; i < n; i++)
	  {
	   f.p[i] = (check_exp((((L.top + (i - n - 1)).tt) == DefineConstants.LUA_TFUNCTION), (L.top + (i - n - 1)).value.gc.cl).l.p);
	   f.code[pc++] = ((((LUAI_UINT32)(OpCode.OP_CLOSURE)) << DefineConstants.POS_OP) | (((LUAI_UINT32)(0)) << (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) | (((LUAI_UINT32)(i)) << (POS_A + DefineConstants.SIZE_A)));
	   f.code[pc++] = ((((LUAI_UINT32)(OpCode.OP_CALL)) << DefineConstants.POS_OP) | (((LUAI_UINT32)(0)) << (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) | (((LUAI_UINT32)(1)) << (POS_C + DefineConstants.SIZE_C)) | (((LUAI_UINT32)(1)) << (POS_A + DefineConstants.SIZE_A)));
	  }
	  f.code[pc++] = ((((LUAI_UINT32)(OpCode.OP_RETURN)) << DefineConstants.POS_OP) | (((LUAI_UINT32)(0)) << (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) | (((LUAI_UINT32)(1)) << (POS_C + DefineConstants.SIZE_C)) | (((LUAI_UINT32)(0)) << (POS_A + DefineConstants.SIZE_A)));
	  return f;
	 }
	}

	internal static int writer(lua_State L, object p, size_t size, object u)
	{
	 ((L));
	 return (fwrite(p,size,1,(FILE)u) != 1) && (size != 0);
	}

	internal static int pmain(lua_State L)
	{
	 Smain s = (Smain)lua_touserdata(L, 1);
	 int argc = s.argc;
	 string[] argv = s.argv;
	 Proto f;
	 int i;
	 if (!lua_checkstack(L,argc))
	 {
		 fatal("too many input files");
	 }
	 for (i = 0; i < argc; i++)
	 {
	  string filename = (string.Compare(argv[i],"-") == 0) ? null : argv[i];
	  if (luaL_loadfile(L,filename) != 0)
	  {
		  fatal(lua_tolstring(L, (-1), null));
	  }
	 }
	 f = combine(L, argc);
	 if (listing != 0)
	 {
		 luaU_print(f, listing > 1);
	 }
	 if (dumping != 0)
	 {
	  FILE D = (output == null) ? stdout : fopen(output,"wb");
	  if (D == null)
	  {
		  cannot("open");
	  }
	  (L)(0)(L);
	  luaU_dump(L, f, writer, D, stripping);
	  (L)(0)(L);
	  if (ferror(D))
	  {
		  cannot("write");
	  }
	  if (fclose(D))
	  {
		  cannot("close");
	  }
	 }
	 return 0;
	}

//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'args', so pointers on this parameter are left unchanged:
	static int Main(int argc, string[] * args)
	{
	 lua_State L;
	 Smain s = new Smain();
	 int i = doargs(argc, args);
	 argc -= i;
	 args += i;
	 if (argc <= 0)
	 {
		 usage("no input files given");
	 }
	 L = luaL_newstate();
	 if (L == null)
	 {
		 fatal("not enough memory for state");
	 }
	 s.argc = argc;
	 s.argv = args;
	 if (lua_cpcall(L, pmain, s) != 0)
	 {
		 fatal(lua_tolstring(L, (-1), null));
	 }
	 lua_close(L);
	 return EXIT_SUCCESS;
	}


/*
** load precompiled chunk
*/
	/*
	** $Id: lundump.c,v 2.7.1.4 2008/04/04 19:51:41 roberto Exp $
	** load precompiled Lua chunks
	** See Copyright Notice in lua.h
	*/



//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DYLD
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_VARARG
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_MOD
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_LSTR
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_GFIND
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_OPENLIB
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUAI_BITSINT
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUAI_BITSINT
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DLOPEN
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DLL
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_SIZET ((size_t)(~(size_t)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_LUMEM ((lu_mem)(~(lu_mem)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_INT (INT_MAX-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IntPoint(p) ((unsigned int)(lu_mem)(p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (lua_assert(c), (e))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check(l,e) lua_assert(e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(c) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check luai_apicheck
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define UNUSED(x) ((void)(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast(t, exp) ((t)(exp))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_byte(i) cast(lu_byte, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_num(i) cast(lua_Number, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_int(i) cast(int, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_lock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unlock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_threadyield(L) {lua_unlock(L); lua_lock(L);}
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) x
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LAST_TAG LUA_TTHREAD
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NUM_TAGS (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TPROTO (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TUPVAL (LAST_TAG+2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TDEADKEY (LAST_TAG+3)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define CommonHeader GCObject *next; lu_byte tt; lu_byte marked
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define TValuefields Value value; int tt
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnil(o) (ttype(o) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnumber(o) (ttype(o) == LUA_TNUMBER)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisstring(o) (ttype(o) == LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttistable(o) (ttype(o) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisfunction(o) (ttype(o) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisboolean(o) (ttype(o) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisuserdata(o) (ttype(o) == LUA_TUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisthread(o) (ttype(o) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttislightuserdata(o) (ttype(o) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttype(o) ((o)->tt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gcvalue(o) check_exp(iscollectable(o), (o)->value.gc)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pvalue(o) check_exp(ttislightuserdata(o), (o)->value.p)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define nvalue(o) check_exp(ttisnumber(o), (o)->value.n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawtsvalue(o) check_exp(ttisstring(o), &(o)->value.gc->ts)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define tsvalue(o) (&rawtsvalue(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawuvalue(o) check_exp(ttisuserdata(o), &(o)->value.gc->u)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define uvalue(o) (&rawuvalue(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define clvalue(o) check_exp(ttisfunction(o), &(o)->value.gc->cl)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define hvalue(o) check_exp(ttistable(o), &(o)->value.gc->h)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bvalue(o) check_exp(ttisboolean(o), (o)->value.b)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define thvalue(o) check_exp(ttisthread(o), &(o)->value.gc->th)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_isfalse(o) (ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkconsistency(obj) lua_assert(!iscollectable(obj) || (ttype(obj) == (obj)->value.gc->gch.tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkliveness(g,obj) lua_assert(!iscollectable(obj) || ((ttype(obj) == (obj)->value.gc->gch.tt) && !isdead(g, (obj)->value.gc)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnilvalue(obj) ((obj)->tt=LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnvalue(obj,x) { TValue *i_o=(obj); i_o->value.n=(x); i_o->tt=LUA_TNUMBER; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setpvalue(obj,x) { TValue *i_o=(obj); i_o->value.p=(x); i_o->tt=LUA_TLIGHTUSERDATA; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbvalue(obj,x) { TValue *i_o=(obj); i_o->value.b=(x); i_o->tt=LUA_TBOOLEAN; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TSTRING; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setuvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TUSERDATA; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setthvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTHREAD; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setclvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TFUNCTION; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTABLE; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TPROTO; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj(L,obj1,obj2) { const TValue *o2=(obj2); TValue *o1=(obj1); o1->value = o2->value; o1->tt=o2->tt; checkliveness(G(L),o1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjs2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2s setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue2s sethvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue2s setptvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjt2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2n setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2n setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setttype(obj, tt) (ttype(obj) = (tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscollectable(o) (ttype(o) >= LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getstr(ts) cast(const char *, (ts) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define svalue(o) getstr(rawtsvalue(o))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ClosureHeader CommonHeader; lu_byte isC; lu_byte nupvalues; GCObject *gclist; struct Table *env
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscfunction(o) (ttype(o) == LUA_TFUNCTION && clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLfunction(o) (ttype(o) == LUA_TFUNCTION && !clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lmod(s,size) (check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define twoto(x) (1<<(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizenode(t) (twoto((t)->lsizenode))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaO_nilobject (&luaO_nilobject_)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ceillog2(x) (luaO_log2((x)-1) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gfasttm(g,et,e) ((et) == NULL ? NULL : ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define fasttm(l,et,e) gfasttm(G(l), et, e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocv(L,b,on,n,e) ((cast(size_t, (n)+1) <= MAX_SIZET/(e)) ? luaM_realloc_(L, (b), (on)*(e), (n)*(e)) : luaM_toobig(L))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freemem(L, b, s) luaM_realloc_(L, (b), (s), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_free(L, b) luaM_realloc_(L, (b), sizeof(*(b)), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freearray(L, b, n, t) luaM_reallocv(L, (b), n, 0, sizeof(t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_malloc(L,t) luaM_realloc_(L, NULL, 0, (t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_new(L,t) cast(t *, luaM_malloc(L, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_newvector(L,n,t) cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_growvector(L,v,nelems,size,t,limit,e) if ((nelems)+1 > (size)) ((v)=cast(t *, luaM_growaux_(L,v,&(size),sizeof(t),limit,e)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocvector(L, v,oldn,n,t) ((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define char2int(c) cast(int, cast(unsigned char, (c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define zgetc(z) (((z)->n--)>0 ? char2int(*(z)->p++) : luaZ_fill(z))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_buffer(buff) ((buff)->buffer)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_sizebuffer(buff) ((buff)->buffsize)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_bufflen(buff) ((buff)->n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resetbuffer(buff) ((buff)->n = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resizebuffer(L, buff, size) (luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), (buff)->buffsize = size)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_freebuffer(L, buff) luaZ_resizebuffer(L, buff, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gt(L) (&L->l_gt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define registry(L) (&G(L)->l_registry)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BASIC_STACK_SIZE (2*LUA_MINSTACK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define curr_func(L) (clvalue(L->ci->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ci_func(ci) (clvalue((ci)->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define f_isLua(ci) (!ci_func(ci)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLua(ci) (ttisfunction((ci)->func) && f_isLua(ci))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define G(L) (L->l_G)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2ts(o) check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2ts(o) (&rawgco2ts(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2u(o) check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2u(o) (&rawgco2u(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2cl(o) check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2h(o) check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2p(o) check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2uv(o) check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ngcotouv(o) check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2th(o) check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define obj2gco(v) (cast(GCObject *, (v)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pcRel(pc, p) (cast(int, (pc) - (p)->code) - 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getline(f,pc) (((f)->lineinfo) ? (f)->lineinfo[pc] : 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resethookcount(L) (L->hookcount = L->basehookcount)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaD_checkstack(L,n) if ((char *)L->stack_last - (char *)L->top <= (n)*(int)sizeof(TValue)) luaD_growstack(L, n); else condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define incr_top(L) {luaD_checkstack(L,1); L->top++;}
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define savestack(L,p) ((char *)(p) - (char *)L->stack)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define restorestack(L,n) ((TValue *)((char *)L->stack + (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define saveci(L,p) ((char *)(p) - (char *)L->base_ci)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define restoreci(L,n) ((CallInfo *)((char *)L->base_ci + (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeCclosure(n) (cast(int, sizeof(CClosure)) + cast(int, sizeof(TValue)*((n)-1)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeLclosure(n) (cast(int, sizeof(LClosure)) + cast(int, sizeof(TValue *)*((n)-1)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbits(x,m) ((x) &= cast(lu_byte, ~(m)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbits(x,m) ((x) |= (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbits(x,m) ((x) & (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bitmask(b) (1<<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bit2mask(b1,b2) (bitmask(b1) | bitmask(b2))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_setbit(x,b) setbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbit(x,b) resetbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbit(x,b) testbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define set2bits(x,b1,b2) setbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define reset2bits(x,b1,b2) resetbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define test2bits(x,b1,b2) testbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define WHITEBITS bit2mask(WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iswhite(x) test2bits((x)->gch.marked, WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isblack(x) testbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isgray(x) (!isblack(x) && !iswhite(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define otherwhite(g) (g->currentwhite ^ WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isdead(g,v) ((v)->gch.marked & otherwhite(g) & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define changewhite(x) ((x)->gch.marked ^= WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gray2black(x) l_setbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define valiswhite(x) (iscollectable(x) && iswhite(gcvalue(x)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_white(g) cast(lu_byte, (g)->currentwhite & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_checkGC(L) { condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1)); if (G(L)->totalbytes >= G(L)->GCthreshold) luaC_step(L); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),gcvalue(v)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barriert(L,t,v) { if (valiswhite(v) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarrier(L,p,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),obj2gco(o)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarriert(L,t,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizestring(s) (sizeof(union TString)+((s)->len+1)*sizeof(char))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeudata(u) (sizeof(union Udata)+(u)->len)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_new(L, s) (luaS_newlstr(L, s, strlen(s)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_newliteral(L, s) (luaS_newlstr(L, "" s, (sizeof(s)/sizeof(char))-1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_fix(s) l_setbit((s)->tsv.marked, FIXEDBIT)
	/*
	** $Id: lundump.h,v 1.37.1.1 2007/12/27 13:02:25 roberto Exp $
	** load precompiled Lua chunks
	** See Copyright Notice in lua.h
	*/



	/* load one chunk; from lundump.c */
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'name', so pointers on this parameter are left unchanged:
	public static Proto luaU_undump(lua_State L, Zio Z, Mbuffer buff, sbyte * name)
	{
	 LoadState S = new LoadState();
	 if (*name == (sbyte)'@' || *name == (sbyte)'=')
	 {
	  S.name = name.Substring(1);
	 }
	 else if (*name == DefineConstants.LUA_SIGNATURE[0])
	 {
	  S.name = "binary string";
	 }
	 else
	 {
	  S.name = name;
	 }
	 S.L = L;
	 S.Z = Z;
	 S.b = buff;
	 LoadHeader(S);
//C++ TO C# CONVERTER WARNING: This 'sizeof' ratio was replaced with a direct reference to the array length:
//ORIGINAL LINE: return LoadFunction(&S,(luaS_newlstr(L, "" "=?", (sizeof("=?")/sizeof(sbyte))-1)));
	 return LoadFunction(S, (luaS_newlstr(L, "" "=?", (("=?").Length) - 1)));
	}

/*
* make header
*/

	/* make header; from lundump.c */
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'h', so pointers on this parameter are left unchanged:
	public static void luaU_header(sbyte * h)
	{
	 int x = 1;
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
	 memcpy(h,DefineConstants.LUA_SIGNATURE,sizeof(DefineConstants.LUA_SIGNATURE) - 1);
	 h += sizeof(DefineConstants.LUA_SIGNATURE) - 1;
	 *h ++=(sbyte)DefineConstants.LUAC_VERSION;
	 *h ++=(sbyte)DefineConstants.LUAC_FORMAT;
	 *h ++=(sbyte) * (string) & x; // endianness
	 *h ++=(sbyte)sizeof(int);
	 *h ++=(sbyte)sizeof(size_t);
	 *h ++=(sbyte)sizeof(LUAI_UINT32);
	 *h ++=(sbyte)sizeof(double);
	 *h ++=(sbyte)(((double)0.5) == 0); // is lua_Number integral?
	}

	/* dump one chunk; from ldump.c */
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//int luaU_dump(lua_State L, Proto f, lua_Writer w, object data, int strip);

	#if luac_c
	/* print one chunk; from print.c */
//C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
	//void luaU_print(Proto f, int full);
	#endif

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LoadMem(S,b,n,size) LoadBlock(S,b,(n)*(size))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LoadByte(S) (lu_byte)LoadChar(S)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LoadVar(S,x) LoadMem(S,&x,1,sizeof(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LoadVector(S,b,n,size) LoadMem(S,b,n,size)

	internal static void LoadBlock(LoadState S, object b, size_t size)
	{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: size_t r=luaZ_read(S->Z,b,size);
	 size_t r = luaZ_read(S.Z, b, new size_t(size));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'IF' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	 IF(r != 0, "unexpected end");
	}

	internal static int LoadChar(LoadState S)
	{
	 sbyte x;
	 LoadBlock(S, x, (1) * (sizeof(sbyte)));
	 return x;
	}

	internal static int LoadInt(LoadState S)
	{
	 int x;
	 LoadBlock(S, x, (1) * (sizeof(int)));
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'IF' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	 IF(x < 0, "bad integer");
	 return x;
	}

	internal static double LoadNumber(LoadState S)
	{
	 double x;
	 LoadBlock(S, x, (1) * (sizeof(double)));
	 return x;
	}

	internal static TString LoadString(LoadState S)
	{
	 size_t size = new size_t();
	 LoadBlock(S, sizeof(size_t), (1) * (sizeof(size_t)));
	 if (size == 0)
	 {
	  return null;
	 }
	 else
	 {
//C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent to pointers to value types:
//ORIGINAL LINE: sbyte* s=luaZ_openspace(S->L,S->b,size);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
	  sbyte s = luaZ_openspace(S.L, S.b, new size_t(size));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: LoadBlock(S,s,size);
	  LoadBlock(S, s, new size_t(size));
	  return luaS_newlstr(S.L, s, size-1); // remove trailing '\0'
	 }
	}

	internal static void LoadCode(LoadState S, Proto f)
	{
	 int n = LoadInt(S);
	 f.code = ((LUAI_UINT32)(((cast(size_t, (n) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(LUAI_UINT32))) ? luaM_realloc_(S.L, (null), (0) * (sizeof(LUAI_UINT32)), (n) * (sizeof(LUAI_UINT32))) : luaM_toobig(S.L))));
	 f.sizecode = n;
	 LoadBlock(S, f.code, (n) * (sizeof(LUAI_UINT32)));
	}

//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'S', so pointers on this parameter are left unchanged:
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'p', so pointers on this parameter are left unchanged:
	internal static Proto LoadFunction(LoadState * S, TString * p)
	{
	 Proto f;
	 if (++S.L.nCcalls > DefineConstants.LUAI_MAXCCALLS)
	 {
		 ;
	 }
	 f = luaF_newproto(S.L);
	 {
		 lua_TValue i_o = (S.L.top);
		 i_o.value.gc = ((union GCObject)((f)));
		 i_o.tt = (DefineConstants.LUA_TTHREAD + 1);
		 (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((S.L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	 };
	 {
		 if ((string)S.L.stack_last - (string)S.L.top <= (1) * (int)sizeof(lua_TValue) != null)
		 {
			 luaD_growstack(S.L, 1);
		 }
		 else
		 {
			 (x)(0)(luaD_reallocstack(S.L, S.L.stacksize - DefineConstants.EXTRA_STACK - 1));
		 }
		 ;
		 S.L.top++;
 };
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: f->source=LoadString(S);
	 f.source = LoadString(new LoadState(S));
	 if (f.source == null)
	 {
		 f.source = p;
	 }
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: f->linedefined=LoadInt(S);
	 f.linedefined = LoadInt(new LoadState(S));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: f->lastlinedefined=LoadInt(S);
	 f.lastlinedefined = LoadInt(new LoadState(S));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: f->nups=(byte)LoadChar(S);
	 f.nups = (byte)LoadChar(new LoadState(S));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: f->numparams=(byte)LoadChar(S);
	 f.numparams = (byte)LoadChar(new LoadState(S));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: f->is_vararg=(byte)LoadChar(S);
	 f.is_vararg = (byte)LoadChar(new LoadState(S));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: f->maxstacksize=(byte)LoadChar(S);
	 f.maxstacksize = (byte)LoadChar(new LoadState(S));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: LoadCode(S,f);
	 LoadCode(new LoadState(S), f);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: LoadConstants(S,f);
	 LoadConstants(new LoadState(S), f);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: LoadDebug(S,f);
	 LoadDebug(new LoadState(S), f);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'IF' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
	 IF(luaG_checkcode(f) == 0, "bad code");
	 S.L.top--;
	 S.L.nCcalls--;
	 return f;
	}

	internal static void LoadConstants(LoadState S, Proto f)
	{
	 int i;
	 int n;
	 n = LoadInt(S);
	 f.k = ((lua_TValue)(((cast(size_t, (n) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(lua_TValue))) ? luaM_realloc_(S.L, (null), (0) * (sizeof(lua_TValue)), (n) * (sizeof(lua_TValue))) : luaM_toobig(S.L))));
	 f.sizek = n;
	 for (i = 0; i < n; i++)
	 {
		 ((f.k[i]).tt = DefineConstants.LUA_TNIL);
	 }
	 for (i = 0; i < n; i++)
	 {
	  lua_TValue o = f.k[i];
	  int t = LoadChar(S);
	  switch (t)
	  {
	   case DefineConstants.LUA_TNIL:
		   ((o).tt = DefineConstants.LUA_TNIL);
		break;
	   case DefineConstants.LUA_TBOOLEAN:
	   {
			   lua_TValue i_o = (o);
			   i_o.value.b = (LoadChar(S) != 0);
			   i_o.tt = DefineConstants.LUA_TBOOLEAN;
	   };
		break;
	   case DefineConstants.LUA_TNUMBER:
	   {
			lua_TValue i_o = (o);
			i_o.value.n = (LoadNumber(S));
			i_o.tt = DefineConstants.LUA_TNUMBER;
	   };
		break;
	   case DefineConstants.LUA_TSTRING:
	   {
			lua_TValue i_o = (o);
			i_o.value.gc = ((union GCObject)(LoadString(S)));
			i_o.tt = DefineConstants.LUA_TSTRING;
			(c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((S.L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	   };
		break;
	   default:
		;
		break;
	  }
	 }
	 n = LoadInt(S);
	 f.p = ((Proto)(((cast(size_t, (n) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(Proto))) ? luaM_realloc_(S.L, (null), (0) * (sizeof(Proto)), (n) * (sizeof(Proto))) : luaM_toobig(S.L))));
	 f.sizep = n;
	 for (i = 0; i < n; i++)
	 {
		 f.p[i] = null;
	 }
	 for (i = 0; i < n; i++)
	 {
		 f.p[i] = LoadFunction(S, f.source);
	 }
	}

	internal static void LoadDebug(LoadState S, Proto f)
	{
	 int i;
	 int n;
	 n = LoadInt(S);
	 f.lineinfo = ((int)(((cast(size_t, (n) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(int))) ? luaM_realloc_(S.L, (null), (0) * (sizeof(int)), (n) * (sizeof(int))) : luaM_toobig(S.L))));
	 f.sizelineinfo = n;
	 LoadBlock(S, f.lineinfo, (n) * (sizeof(int)));
	 n = LoadInt(S);
	 f.locvars = ((LocVar)(((cast(size_t, (n) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(LocVar))) ? luaM_realloc_(S.L, (null), (0) * (sizeof(LocVar)), (n) * (sizeof(LocVar))) : luaM_toobig(S.L))));
	 f.sizelocvars = n;
	 for (i = 0; i < n; i++)
	 {
		 f.locvars[i].varname = null;
	 }
	 for (i = 0; i < n; i++)
	 {
	  f.locvars[i].varname = LoadString(S);
	  f.locvars[i].startpc = LoadInt(S);
	  f.locvars[i].endpc = LoadInt(S);
	 }
	 n = LoadInt(S);
	 f.upvalues = ((TString)(((cast(size_t, (n) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(TString))) ? luaM_realloc_(S.L, (null), (0) * (sizeof(TString)), (n) * (sizeof(TString))) : luaM_toobig(S.L))));
	 f.sizeupvalues = n;
	 for (i = 0; i < n; i++)
	 {
		 f.upvalues[i] = null;
	 }
	 for (i = 0; i < n; i++)
	 {
		 f.upvalues[i] = LoadString(S);
	 }
	}

	internal static void LoadHeader(LoadState S)
	{
	 string h = new string(new char[DefineConstants.LUAC_HEADERSIZE]);
	 string s = new string(new char[DefineConstants.LUAC_HEADERSIZE]);
	 luaU_header(h);
	 LoadBlock(S, s, DefineConstants.LUAC_HEADERSIZE);
	//C++ TO C# CONVERTER TODO TASK: The #define macro 'IF' was defined in multiple preprocessor conditionals and cannot be replaced in-line:
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcmp' has no equivalent in C#:
	 IF(memcmp(h,s,DefineConstants.LUAC_HEADERSIZE) != 0, "bad header");
	}

	/*
	** $Id: lvm.c,v 2.63.1.3 2007/12/28 15:32:23 roberto Exp $
	** Lua virtual machine
	** See Copyright Notice in lua.h
	*/




//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DYLD
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_VARARG
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_MOD
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_LSTR
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_GFIND
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_OPENLIB
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUAI_BITSINT
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUAI_BITSINT
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DLOPEN
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DLL
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_SIZET ((size_t)(~(size_t)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_LUMEM ((lu_mem)(~(lu_mem)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_INT (INT_MAX-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IntPoint(p) ((unsigned int)(lu_mem)(p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (lua_assert(c), (e))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check(l,e) lua_assert(e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(c) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check luai_apicheck
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define UNUSED(x) ((void)(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast(t, exp) ((t)(exp))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_byte(i) cast(lu_byte, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_num(i) cast(lua_Number, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_int(i) cast(int, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_lock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unlock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_threadyield(L) {lua_unlock(L); lua_lock(L);}
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) x
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LAST_TAG LUA_TTHREAD
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NUM_TAGS (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TPROTO (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TUPVAL (LAST_TAG+2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TDEADKEY (LAST_TAG+3)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define CommonHeader GCObject *next; lu_byte tt; lu_byte marked
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define TValuefields Value value; int tt
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnil(o) (ttype(o) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnumber(o) (ttype(o) == LUA_TNUMBER)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisstring(o) (ttype(o) == LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttistable(o) (ttype(o) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisfunction(o) (ttype(o) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisboolean(o) (ttype(o) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisuserdata(o) (ttype(o) == LUA_TUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisthread(o) (ttype(o) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttislightuserdata(o) (ttype(o) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttype(o) ((o)->tt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gcvalue(o) check_exp(iscollectable(o), (o)->value.gc)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pvalue(o) check_exp(ttislightuserdata(o), (o)->value.p)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define nvalue(o) check_exp(ttisnumber(o), (o)->value.n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawtsvalue(o) check_exp(ttisstring(o), &(o)->value.gc->ts)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define tsvalue(o) (&rawtsvalue(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawuvalue(o) check_exp(ttisuserdata(o), &(o)->value.gc->u)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define uvalue(o) (&rawuvalue(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define clvalue(o) check_exp(ttisfunction(o), &(o)->value.gc->cl)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define hvalue(o) check_exp(ttistable(o), &(o)->value.gc->h)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bvalue(o) check_exp(ttisboolean(o), (o)->value.b)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define thvalue(o) check_exp(ttisthread(o), &(o)->value.gc->th)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_isfalse(o) (ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkconsistency(obj) lua_assert(!iscollectable(obj) || (ttype(obj) == (obj)->value.gc->gch.tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkliveness(g,obj) lua_assert(!iscollectable(obj) || ((ttype(obj) == (obj)->value.gc->gch.tt) && !isdead(g, (obj)->value.gc)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnilvalue(obj) ((obj)->tt=LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnvalue(obj,x) { TValue *i_o=(obj); i_o->value.n=(x); i_o->tt=LUA_TNUMBER; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setpvalue(obj,x) { TValue *i_o=(obj); i_o->value.p=(x); i_o->tt=LUA_TLIGHTUSERDATA; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbvalue(obj,x) { TValue *i_o=(obj); i_o->value.b=(x); i_o->tt=LUA_TBOOLEAN; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TSTRING; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setuvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TUSERDATA; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setthvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTHREAD; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setclvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TFUNCTION; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTABLE; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TPROTO; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj(L,obj1,obj2) { const TValue *o2=(obj2); TValue *o1=(obj1); o1->value = o2->value; o1->tt=o2->tt; checkliveness(G(L),o1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjs2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2s setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue2s sethvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue2s setptvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjt2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2n setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2n setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setttype(obj, tt) (ttype(obj) = (tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscollectable(o) (ttype(o) >= LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getstr(ts) cast(const char *, (ts) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define svalue(o) getstr(rawtsvalue(o))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ClosureHeader CommonHeader; lu_byte isC; lu_byte nupvalues; GCObject *gclist; struct Table *env
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscfunction(o) (ttype(o) == LUA_TFUNCTION && clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLfunction(o) (ttype(o) == LUA_TFUNCTION && !clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lmod(s,size) (check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define twoto(x) (1<<(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizenode(t) (twoto((t)->lsizenode))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaO_nilobject (&luaO_nilobject_)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ceillog2(x) (luaO_log2((x)-1) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gfasttm(g,et,e) ((et) == NULL ? NULL : ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define fasttm(l,et,e) gfasttm(G(l), et, e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocv(L,b,on,n,e) ((cast(size_t, (n)+1) <= MAX_SIZET/(e)) ? luaM_realloc_(L, (b), (on)*(e), (n)*(e)) : luaM_toobig(L))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freemem(L, b, s) luaM_realloc_(L, (b), (s), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_free(L, b) luaM_realloc_(L, (b), sizeof(*(b)), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freearray(L, b, n, t) luaM_reallocv(L, (b), n, 0, sizeof(t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_malloc(L,t) luaM_realloc_(L, NULL, 0, (t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_new(L,t) cast(t *, luaM_malloc(L, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_newvector(L,n,t) cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_growvector(L,v,nelems,size,t,limit,e) if ((nelems)+1 > (size)) ((v)=cast(t *, luaM_growaux_(L,v,&(size),sizeof(t),limit,e)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocvector(L, v,oldn,n,t) ((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define char2int(c) cast(int, cast(unsigned char, (c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define zgetc(z) (((z)->n--)>0 ? char2int(*(z)->p++) : luaZ_fill(z))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_buffer(buff) ((buff)->buffer)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_sizebuffer(buff) ((buff)->buffsize)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_bufflen(buff) ((buff)->n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resetbuffer(buff) ((buff)->n = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resizebuffer(L, buff, size) (luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), (buff)->buffsize = size)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_freebuffer(L, buff) luaZ_resizebuffer(L, buff, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gt(L) (&L->l_gt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define registry(L) (&G(L)->l_registry)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BASIC_STACK_SIZE (2*LUA_MINSTACK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define curr_func(L) (clvalue(L->ci->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ci_func(ci) (clvalue((ci)->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define f_isLua(ci) (!ci_func(ci)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLua(ci) (ttisfunction((ci)->func) && f_isLua(ci))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define G(L) (L->l_G)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2ts(o) check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2ts(o) (&rawgco2ts(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2u(o) check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2u(o) (&rawgco2u(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2cl(o) check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2h(o) check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2p(o) check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2uv(o) check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ngcotouv(o) check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2th(o) check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define obj2gco(v) (cast(GCObject *, (v)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pcRel(pc, p) (cast(int, (pc) - (p)->code) - 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getline(f,pc) (((f)->lineinfo) ? (f)->lineinfo[pc] : 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resethookcount(L) (L->hookcount = L->basehookcount)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaD_checkstack(L,n) if ((char *)L->stack_last - (char *)L->top <= (n)*(int)sizeof(TValue)) luaD_growstack(L, n); else condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define incr_top(L) {luaD_checkstack(L,1); L->top++;}
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define savestack(L,p) ((char *)(p) - (char *)L->stack)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define restorestack(L,n) ((TValue *)((char *)L->stack + (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define saveci(L,p) ((char *)(p) - (char *)L->base_ci)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define restoreci(L,n) ((CallInfo *)((char *)L->base_ci + (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeCclosure(n) (cast(int, sizeof(CClosure)) + cast(int, sizeof(TValue)*((n)-1)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeLclosure(n) (cast(int, sizeof(LClosure)) + cast(int, sizeof(TValue *)*((n)-1)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbits(x,m) ((x) &= cast(lu_byte, ~(m)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbits(x,m) ((x) |= (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbits(x,m) ((x) & (m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bitmask(b) (1<<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bit2mask(b1,b2) (bitmask(b1) | bitmask(b2))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_setbit(x,b) setbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resetbit(x,b) resetbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testbit(x,b) testbits(x, bitmask(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define set2bits(x,b1,b2) setbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define reset2bits(x,b1,b2) resetbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define test2bits(x,b1,b2) testbits(x, (bit2mask(b1, b2)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define WHITEBITS bit2mask(WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iswhite(x) test2bits((x)->gch.marked, WHITE0BIT, WHITE1BIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isblack(x) testbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isgray(x) (!isblack(x) && !iswhite(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define otherwhite(g) (g->currentwhite ^ WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isdead(g,v) ((v)->gch.marked & otherwhite(g) & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define changewhite(x) ((x)->gch.marked ^= WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gray2black(x) l_setbit((x)->gch.marked, BLACKBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define valiswhite(x) (iscollectable(x) && iswhite(gcvalue(x)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_white(g) cast(lu_byte, (g)->currentwhite & WHITEBITS)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_checkGC(L) { condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1)); if (G(L)->totalbytes >= G(L)->GCthreshold) luaC_step(L); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),gcvalue(v)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_barriert(L,t,v) { if (valiswhite(v) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarrier(L,p,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) luaC_barrierf(L,obj2gco(p),obj2gco(o)); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaC_objbarriert(L,t,o) { if (iswhite(obj2gco(o)) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SIZE_Bx (SIZE_C + SIZE_B)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define POS_A (POS_OP + SIZE_OP)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define POS_C (POS_A + SIZE_A)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define POS_B (POS_C + SIZE_C)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define POS_Bx POS_C
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_Bx ((1<<SIZE_Bx)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_sBx (MAXARG_Bx>>1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_Bx MAX_INT
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_sBx MAX_INT
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_A ((1<<SIZE_A)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_B ((1<<SIZE_B)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_C ((1<<SIZE_C)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MASK1(n,p) ((~((~(Instruction)0)<<n))<<p)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MASK0(n,p) (~MASK1(n,p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GET_OPCODE(i) (cast(OpCode, ((i)>>POS_OP) & MASK1(SIZE_OP,0)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SET_OPCODE(i,o) ((i) = (((i)&MASK0(SIZE_OP,POS_OP)) | ((cast(Instruction, o)<<POS_OP)&MASK1(SIZE_OP,POS_OP))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GETARG_A(i) (cast(int, ((i)>>POS_A) & MASK1(SIZE_A,0)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SETARG_A(i,u) ((i) = (((i)&MASK0(SIZE_A,POS_A)) | ((cast(Instruction, u)<<POS_A)&MASK1(SIZE_A,POS_A))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GETARG_B(i) (cast(int, ((i)>>POS_B) & MASK1(SIZE_B,0)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SETARG_B(i,b) ((i) = (((i)&MASK0(SIZE_B,POS_B)) | ((cast(Instruction, b)<<POS_B)&MASK1(SIZE_B,POS_B))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GETARG_C(i) (cast(int, ((i)>>POS_C) & MASK1(SIZE_C,0)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SETARG_C(i,b) ((i) = (((i)&MASK0(SIZE_C,POS_C)) | ((cast(Instruction, b)<<POS_C)&MASK1(SIZE_C,POS_C))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GETARG_Bx(i) (cast(int, ((i)>>POS_Bx) & MASK1(SIZE_Bx,0)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SETARG_Bx(i,b) ((i) = (((i)&MASK0(SIZE_Bx,POS_Bx)) | ((cast(Instruction, b)<<POS_Bx)&MASK1(SIZE_Bx,POS_Bx))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GETARG_sBx(i) (GETARG_Bx(i)-MAXARG_sBx)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SETARG_sBx(i,b) SETARG_Bx((i),cast(unsigned int, (b)+MAXARG_sBx))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define CREATE_ABC(o,a,b,c) ((cast(Instruction, o)<<POS_OP) | (cast(Instruction, a)<<POS_A) | (cast(Instruction, b)<<POS_B) | (cast(Instruction, c)<<POS_C))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define CREATE_ABx(o,a,bc) ((cast(Instruction, o)<<POS_OP) | (cast(Instruction, a)<<POS_A) | (cast(Instruction, bc)<<POS_Bx))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BITRK (1 << (SIZE_B - 1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ISK(x) ((x) & BITRK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define INDEXK(r) ((int)(r) & ~BITRK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXINDEXRK (BITRK - 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define RKASK(x) ((x) | BITRK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NO_REG MAXARG_A
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NUM_OPCODES (cast(int, OP_VARARG) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getOpMode(m) (cast(enum OpMode, luaP_opmodes[m] & 3))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getBMode(m) (cast(enum OpArgMask, (luaP_opmodes[m] >> 4) & 3))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getCMode(m) (cast(enum OpArgMask, (luaP_opmodes[m] >> 2) & 3))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testAMode(m) (luaP_opmodes[m] & (1 << 6))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testTMode(m) (luaP_opmodes[m] & (1 << 7))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizestring(s) (sizeof(union TString)+((s)->len+1)*sizeof(char))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizeudata(u) (sizeof(union Udata)+(u)->len)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_new(L, s) (luaS_newlstr(L, s, strlen(s)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_newliteral(L, s) (luaS_newlstr(L, "" s, (sizeof(s)/sizeof(char))-1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaS_fix(s) l_setbit((s)->tsv.marked, FIXEDBIT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gnode(t,i) (&(t)->node[i])
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gkey(n) (&(n)->i_key.nk)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gval(n) (&(n)->i_val)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gnext(n) ((n)->i_key.nk.next)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define key2tval(n) (&(n)->i_key.tvk)
	/*
	** $Id: lvm.h,v 2.5.1.1 2007/12/27 13:02:25 roberto Exp $
	** Lua virtual machine
	** See Copyright Notice in lua.h
	*/





	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define tostring(L,o) ((ttype(o) == LUA_TSTRING) || (luaV_tostring(L, o)))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define tonumber(o,n) (ttype(o) == LUA_TNUMBER || (((o) = luaV_tonumber(o,n)) != NULL))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define equalobj(L,o1,o2) (ttype(o1) == ttype(o2) && luaV_equalval(L, o1, o2))


	public static int luaV_lessthan(lua_State L, lua_TValue l, lua_TValue r)
	{
	  int res;
	  if (((l).tt) != ((r).tt))
	  {
		return luaG_ordererror(L, l, r);
	  }
	  else if ((((l).tt) == DefineConstants.LUA_TNUMBER))
	  {
		return ((check_exp((((l).tt) == DefineConstants.LUA_TNUMBER), (l).value.n)) < (check_exp((((r).tt) == DefineConstants.LUA_TNUMBER), (r).value.n)));
	  }
	  else if ((((l).tt) == DefineConstants.LUA_TSTRING))
	  {
		return l_strcmp(check_exp((((l).tt) == DefineConstants.LUA_TSTRING), (l).value.gc.ts), check_exp((((r).tt) == DefineConstants.LUA_TSTRING), (r).value.gc.ts)) < 0;
	  }
	  else if ((res = call_orderTM(L, l, r, TMS.TM_LT)) != -1)
	  {
		return res;
	  }
	  return luaG_ordererror(L, l, r);
	}
	public static int luaV_equalval(lua_State L, lua_TValue t1, lua_TValue t2)
	{
	  lua_TValue tm;
	  (c)(0)(((t1).tt) == ((t2).tt));
	  switch (((t1).tt))
	  {
		case DefineConstants.LUA_TNIL:
			return 1;
		case DefineConstants.LUA_TNUMBER:
			return ((check_exp((((t1).tt) == DefineConstants.LUA_TNUMBER), (t1).value.n)) == (check_exp((((t2).tt) == DefineConstants.LUA_TNUMBER), (t2).value.n)));
		case DefineConstants.LUA_TBOOLEAN:
			return check_exp((((t1).tt) == DefineConstants.LUA_TBOOLEAN), (t1).value.b) == check_exp((((t2).tt) == DefineConstants.LUA_TBOOLEAN), (t2).value.b); // true must be 1 !!
		case DefineConstants.LUA_TLIGHTUSERDATA:
			return check_exp((((t1).tt) == DefineConstants.LUA_TLIGHTUSERDATA), (t1).value.p) == check_exp((((t2).tt) == DefineConstants.LUA_TLIGHTUSERDATA), (t2).value.p);
		case DefineConstants.LUA_TUSERDATA:
		{
		  if ((check_exp((((t1).tt) == DefineConstants.LUA_TUSERDATA), (t1).value.gc.u).uv) == (check_exp((((t2).tt) == DefineConstants.LUA_TUSERDATA), (t2).value.gc.u).uv))
		  {
			  return 1;
		  }
		  tm = get_compTM(L, (check_exp((((t1).tt) == DefineConstants.LUA_TUSERDATA), (t1).value.gc.u).uv).metatable, (check_exp((((t2).tt) == DefineConstants.LUA_TUSERDATA), (t2).value.gc.u).uv).metatable, TMS.TM_EQ);
		  break; // will try TM
		}
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		case DefineConstants.LUA_TTABLE:
		{
		  if (check_exp((((t1).tt) == DefineConstants.LUA_TTABLE), (t1).value.gc.h) == check_exp((((t2).tt) == DefineConstants.LUA_TTABLE), (t2).value.gc.h))
		  {
			  return 1;
		  }
		  tm = get_compTM(L, check_exp((((t1).tt) == DefineConstants.LUA_TTABLE), (t1).value.gc.h).metatable, check_exp((((t2).tt) == DefineConstants.LUA_TTABLE), (t2).value.gc.h).metatable, TMS.TM_EQ);
		  break; // will try TM
		}
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		default:
			return check_exp((((t1).tt) >= DefineConstants.LUA_TSTRING), (t1).value.gc) == check_exp((((t2).tt) >= DefineConstants.LUA_TSTRING), (t2).value.gc);
	  }
	  if (tm == null)
	  {
		  return 0; // no TM?
	  }
	  callTMres(L, L.top, tm, t1, t2); // call TM
	  return !((((L.top).tt) == DefineConstants.LUA_TNIL) || ((((L.top).tt) == DefineConstants.LUA_TBOOLEAN) && check_exp(ttisboolean(L.top), (L.top).value.b) == 0));
	}
	public static lua_TValue luaV_tonumber(lua_TValue obj, lua_TValue n)
	{
	  double num;
	  if ((((obj).tt) == DefineConstants.LUA_TNUMBER))
	  {
		  return obj;
	  }
	  if ((((obj).tt) == DefineConstants.LUA_TSTRING) && luaO_str2d(((string)((check_exp(ttisstring(obj), (obj).value.gc.ts)) + 1)), ref num) != 0)
	  {
		{
			lua_TValue i_o = (n);
			i_o.value.n = (num);
			i_o.tt = DefineConstants.LUA_TNUMBER;
	};
		return n;
	  }
	  else
	  {
		return null;
	  }
	}
	public static int luaV_tostring(lua_State L, lua_TValue obj)
	{
	  if (!(((obj).tt) == DefineConstants.LUA_TNUMBER))
	  {
		return 0;
	  }
	  else
	  {
		string s = new string(new char[DefineConstants.LUAI_MAXNUMBER2STR]);
		double n = check_exp((((obj).tt) == DefineConstants.LUA_TNUMBER), (obj).value.n);
		sprintf((s), DefineConstants.LUA_NUMBER_FMT, (n));
		{
			lua_TValue i_o = (obj);
			i_o.value.gc = ((union GCObject)((luaS_newlstr(L, s, s.Length))));
			i_o.tt = DefineConstants.LUA_TSTRING;
			(c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		};
		return 1;
	  }
	}
	public static void luaV_gettable(lua_State L, lua_TValue t, lua_TValue key, lua_TValue val)
	{
	  int loop;
	  for (loop = 0; loop < DefineConstants.MAXTAGLOOP; loop++)
	  {
		lua_TValue tm;
		if ((((t).tt) == DefineConstants.LUA_TTABLE))
		{ // `t' is a table?
		  Table h = check_exp((((t).tt) == DefineConstants.LUA_TTABLE), (t).value.gc.h);
		  lua_TValue res = luaH_get(h, key); // do a primitive get
		  if (!(((res).tt) == DefineConstants.LUA_TNIL) || (tm = ((h.metatable) == null ? null : (((h.metatable).flags & (1u << (TMS.TM_INDEX))) != 0) ? null : luaT_gettm(h.metatable, TMS.TM_INDEX, ((L.l_G)).tmname[(int)TMS.TM_INDEX]))) == null)
		  { // or no TM? -  result is no nil?
	  {
				lua_TValue o2 = (res);
				lua_TValue o1 = (val);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
				o1.value.CopyFrom(o2.value);
				o1.tt = o2.tt;
				(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		};
			return;
	  }
		  /* else will try the tag method */
		}
		else if ((((tm = luaT_gettmbyobj(L, t, TMS.TM_INDEX)).tt) == DefineConstants.LUA_TNIL))
		{
		  luaG_typeerror(L, t, "index");
		}
		if ((((tm).tt) == DefineConstants.LUA_TFUNCTION))
		{
		  callTMres(L, val, tm, t, key);
		  return;
		}
		t = tm; // else repeat with `tm'
	  }
	  luaG_runerror(L, "loop in gettable");
	}
	public static void luaV_settable(lua_State L, lua_TValue t, lua_TValue key, lua_TValue val)
	{
	  int loop;
	  for (loop = 0; loop < DefineConstants.MAXTAGLOOP; loop++)
	  {
		lua_TValue tm;
		if ((((t).tt) == DefineConstants.LUA_TTABLE))
		{ // `t' is a table?
		  Table h = check_exp((((t).tt) == DefineConstants.LUA_TTABLE), (t).value.gc.h);
		  lua_TValue oldval = luaH_set(L, h, key); // do a primitive set
		  if (!(((oldval).tt) == DefineConstants.LUA_TNIL) || (tm = ((h.metatable) == null ? null : (((h.metatable).flags & (1u << (TMS.TM_NEWINDEX))) != 0) ? null : luaT_gettm(h.metatable, TMS.TM_NEWINDEX, ((L.l_G)).tmname[(int)TMS.TM_NEWINDEX]))) == null)
		  { // or no TM? -  result is no nil?
	  {
				lua_TValue o2 = (val);
				lua_TValue o1 = (oldval);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
				o1.value.CopyFrom(o2.value);
				o1.tt = o2.tt;
				(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		};
		{
				if (((((val).tt) >= DefineConstants.LUA_TSTRING) && (((check_exp((((val).tt) >= DefineConstants.LUA_TSTRING), (val).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))) && ((((((union GCObject)((h))))).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))))
				{
					luaC_barrierback(L, h);
				}
		};
			return;
	  }
		  /* else will try the tag method */
		}
		else if ((((tm = luaT_gettmbyobj(L, t, TMS.TM_NEWINDEX)).tt) == DefineConstants.LUA_TNIL))
		{
		  luaG_typeerror(L, t, "index");
		}
		if ((((tm).tt) == DefineConstants.LUA_TFUNCTION))
		{
		  callTM(L, tm, t, key, val);
		  return;
		}
		t = tm; // else repeat with `tm'
	  }
	  luaG_runerror(L, "loop in settable");
	}
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on the parameter 'L', so pointers on this parameter are left unchanged:
	public static void luaV_execute(lua_State * L, int nexeccalls)
	{
	  LClosure cl;
	  lua_TValue @base;
	  lua_TValue k;
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  LUAI_UINT32 * pc = new LUAI_UINT32();
	 reentry: // entry point
	  (c)(0)((((((L.ci).func).tt) == DefineConstants.LUA_TFUNCTION) && (!(check_exp(ttisfunction((L.ci).func), ((L.ci).func).value.gc.cl)).c.isC)));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: pc = L->savedpc;
	  pc.CopyFrom(L.savedpc);
	  cl = check_exp((((L.ci.func).tt) == DefineConstants.LUA_TFUNCTION), (L.ci.func).value.gc.cl).l;
	  @base = L.@base;
	  k = cl.p.k;
	  /* main loop of interpreter */
	  for (;;)
	  {
		LUAI_UINT32 i = pc++;
		lua_TValue ra;
		if ((L.hookmask & ((1 << DefineConstants.LUA_HOOKLINE) | (1 << DefineConstants.LUA_HOOKCOUNT))) && (--L.hookcount == 0 || L.hookmask != 0 & (1 << DefineConstants.LUA_HOOKLINE)))
		{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: traceexec(L, pc);
		  traceexec(new lua_State(L), new LUAI_UINT32(pc));
		  if (L.status == DefineConstants.LUA_YIELD)
		  { // did hook yield?
			L.savedpc = pc - 1;
			return;
		  }
		  @base = L.@base;
		}
		/* warning!! several calls may realloc the stack and invalidate `ra' */
		ra = (@base + (((int)(((i) >> (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_A)) << 0)))));
		(c)(0)(@base == L.@base && L.@base == L.ci.@base);
		(c)(0)(@base <= L.top != null && L.top <= L.stack + L.stacksize);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: (c)(0)(L->top == L->ci->top || luaG_checkopenop(i));
		(c)(0)(L.top == L.ci.top || luaG_checkopenop(new LUAI_UINT32(i)) != 0);
		switch ((((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))))
		{
		  case OpCode.OP_MOVE:
		  {
			{
				lua_TValue o2 = (check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgR, @base + (((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))));
				lua_TValue o1 = (ra);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
				o1.value.CopyFrom(o2.value);
				o1.tt = o2.tt;
				(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		};
			continue;
		  }
		  case OpCode.OP_LOADK:
		  {
			{
				lua_TValue o2 = (check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgK, k + (((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << (DefineConstants.SIZE_C + DefineConstants.SIZE_B))) << 0))))));
				lua_TValue o1 = (ra);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
				o1.value.CopyFrom(o2.value);
				o1.tt = o2.tt;
				(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		};
			continue;
		  }
		  case OpCode.OP_LOADBOOL:
		  {
			{
				lua_TValue i_o = (ra);
				i_o.value.b = ((((int)(((i) >> (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))));
				i_o.tt = DefineConstants.LUA_TBOOLEAN;
		};
			if ((((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0)))))
			{
				pc++; // skip next instruction (if C)
			}
			continue;
		  }
		  case OpCode.OP_LOADNIL:
		  {
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
			lua_TValue * rb = check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgR, @base + (((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))));
			do
			{
			  ((rb--).tt = DefineConstants.LUA_TNIL);
			} while (rb >= ra);
			continue;
		  }
		  case OpCode.OP_GETUPVAL:
		  {
			int b = (((int)(((i) >> (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))));
			{
				lua_TValue o2 = (cl.upvals[b].v);
				lua_TValue o1 = (ra);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
				o1.value.CopyFrom(o2.value);
				o1.tt = o2.tt;
				(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
			};
			continue;
		  }
		  case OpCode.OP_GETGLOBAL:
		  {
			lua_TValue g = new lua_TValue();
			lua_TValue rb = check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgK, k + (((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << (DefineConstants.SIZE_C + DefineConstants.SIZE_B))) << 0)))));
			{
				lua_TValue i_o = (g);
				i_o.value.gc = ((union GCObject)((cl.env)));
				i_o.tt = DefineConstants.LUA_TTABLE;
				(c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
			};
			(c)(0)((((rb).tt) == DefineConstants.LUA_TSTRING));
			{
				L.savedpc = pc;
				{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaV_gettable(L, &g, rb, ra);
					luaV_gettable(new lua_State(L), g, rb, ra);
				};
				@base = L.@base;
			};
			continue;
		  }
		  case OpCode.OP_GETTABLE:
		  {
			{
				L.savedpc = pc;
				{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaV_gettable(L, check_exp((((enum OpArgMask)((luaP_opmodes[(((OpCode)(((i)>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP))<<0))))] >> 4) & 3))) == OpArgR, base+(((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_B))<<0))))), check_exp((((enum OpArgMask)((luaP_opmodes[(((OpCode)(((i)>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP))<<0))))] >> 2) & 3))) == OpArgK, (((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_C))<<0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k+((int)((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_C))<<0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : base+(((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_C))<<0))))), ra);
					luaV_gettable(new lua_State(L), check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgR, @base + (((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B))<<0))))), check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i)>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 2) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))), ra);
				};
				@base = L.@base;
		};
			continue;
		  }
		  case OpCode.OP_SETGLOBAL:
		  {
			lua_TValue g = new lua_TValue();
			{
				lua_TValue i_o = (g);
				i_o.value.gc = ((union GCObject)((cl.env)));
				i_o.tt = DefineConstants.LUA_TTABLE;
				(c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
			};
			(c)(0)((((check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgK, k + (((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << (DefineConstants.SIZE_C + DefineConstants.SIZE_B))) << 0)))))).tt) == DefineConstants.LUA_TSTRING));
			{
				L.savedpc = pc;
				{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaV_settable(L, &g, check_exp((((enum OpArgMask)((luaP_opmodes[(((OpCode)(((i)>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP))<<0))))] >> 4) & 3))) == OpArgK, k+(((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0)<<(DefineConstants.SIZE_C + DefineConstants.SIZE_B)))<<0))))), ra);
					luaV_settable(new lua_State(L), g, check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgK, k + (((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << (DefineConstants.SIZE_C + DefineConstants.SIZE_B))) << 0))))), ra);
				};
				@base = L.@base;
			};
			continue;
		  }
		  case OpCode.OP_SETUPVAL:
		  {
			UpVal[] uv = cl.upvals[(((int)(((i) >> (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))];
			{
				lua_TValue o2 = (ra);
				lua_TValue o1 = (uv.v);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
				o1.value.CopyFrom(o2.value);
				o1.tt = o2.tt;
				(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
			};
			{
				if (((((ra).tt) >= DefineConstants.LUA_TSTRING) && (((check_exp((((ra).tt) >= DefineConstants.LUA_TSTRING), (ra).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))) && ((((((union GCObject)((uv))))).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))))
				{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaC_barrierf(L,(((union GCObject *)((uv)))),check_exp((((ra)->tt) >= DefineConstants.LUA_TSTRING), (ra)->value.gc));
					luaC_barrierf(new lua_State(L), (((union GCObject)((uv)))), check_exp((((ra).tt) >= DefineConstants.LUA_TSTRING), (ra).value.gc));
				}
		};
			continue;
		  }
		  case OpCode.OP_SETTABLE:
		  {
			{
				L.savedpc = pc;
				{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaV_settable(L, ra, check_exp((((enum OpArgMask)((luaP_opmodes[(((OpCode)(((i)>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP))<<0))))] >> 4) & 3))) == OpArgK, (((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_B))<<0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k+((int)((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_B))<<0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : base+(((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_B))<<0))))), check_exp((((enum OpArgMask)((luaP_opmodes[(((OpCode)(((i)>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP))<<0))))] >> 2) & 3))) == OpArgK, (((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_C))<<0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k+((int)((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_C))<<0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : base+(((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_C))<<0))))));
					luaV_settable(new lua_State(L), ra, check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B))<<0))))), check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i)>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 2) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))));
				};
				@base = L.@base;
		};
			continue;
		  }
		  case OpCode.OP_NEWTABLE:
		  {
			int b = (((int)(((i) >> (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))));
			int c = (((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))));
			{
				lua_TValue i_o = (ra);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: i_o->value.gc=((union GCObject *)((luaH_new(L, luaO_fb2int(b), luaO_fb2int(c)))));
				i_o.value.gc = ((union GCObject)(luaH_new(new lua_State(L), luaO_fb2int(b), luaO_fb2int(c))));
				i_o.tt = DefineConstants.LUA_TTABLE;
				(c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
			};
			{
				L.savedpc = pc;
				{
					{
						(x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
						if ((L.l_G).totalbytes >= (L.l_G).GCthreshold)
						{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaC_step(L);
							luaC_step(new lua_State(L));
						}
				};
				};
				@base = L.@base;
		};
			continue;
		  }
		  case OpCode.OP_SELF:
		  {
			lua_TValue rb = check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgR, @base + (((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))));
			{
				lua_TValue o2 = (rb);
				lua_TValue o1 = (ra + 1);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
				o1.value.CopyFrom(o2.value);
				o1.tt = o2.tt;
				(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
			};
			{
				L.savedpc = pc;
				{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaV_gettable(L, rb, check_exp((((enum OpArgMask)((luaP_opmodes[(((OpCode)(((i)>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP))<<0))))] >> 2) & 3))) == OpArgK, (((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_C))<<0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k+((int)((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_C))<<0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : base+(((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_C))<<0))))), ra);
					luaV_gettable(new lua_State(L), rb, check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 2) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))), ra);
				};
				@base = L.@base;
		};
			continue;
		  }
		  case OpCode.OP_ADD:
		  {
			{
				lua_TValue rb = check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))));
				lua_TValue rc = check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 2) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0)))));
				if ((((rb).tt) == DefineConstants.LUA_TNUMBER) && (((rc).tt) == DefineConstants.LUA_TNUMBER))
				{
					double nb = check_exp((((rb).tt) == DefineConstants.LUA_TNUMBER), (rb).value.n);
					double nc = check_exp((((rc).tt) == DefineConstants.LUA_TNUMBER), (rc).value.n);
					{
						lua_TValue i_o = (ra);
						i_o.value.n = (((nb) + (nc)));
						i_o.tt = DefineConstants.LUA_TNUMBER;
					};
				}
				else
				{
					L.savedpc = pc;
					{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: Arith(L, ra, rb, rc, TM_ADD);
						Arith(new lua_State(L), ra, rb, rc, TMS.TM_ADD);
					};
					@base = L.@base;
				};
		};
			continue;
		  }
		  case OpCode.OP_SUB:
		  {
			{
				lua_TValue rb = check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))));
				lua_TValue rc = check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 2) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0)))));
				if ((((rb).tt) == DefineConstants.LUA_TNUMBER) && (((rc).tt) == DefineConstants.LUA_TNUMBER))
				{
					double nb = check_exp((((rb).tt) == DefineConstants.LUA_TNUMBER), (rb).value.n);
					double nc = check_exp((((rc).tt) == DefineConstants.LUA_TNUMBER), (rc).value.n);
					{
						lua_TValue i_o = (ra);
						i_o.value.n = (((nb) - (nc)));
						i_o.tt = DefineConstants.LUA_TNUMBER;
					};
				}
				else
				{
					L.savedpc = pc;
					{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: Arith(L, ra, rb, rc, TM_SUB);
						Arith(new lua_State(L), ra, rb, rc, TMS.TM_SUB);
					};
					@base = L.@base;
				};
		};
			continue;
		  }
		  case OpCode.OP_MUL:
		  {
			{
				lua_TValue rb = check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))));
				lua_TValue rc = check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 2) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0)))));
				if ((((rb).tt) == DefineConstants.LUA_TNUMBER) && (((rc).tt) == DefineConstants.LUA_TNUMBER))
				{
					double nb = check_exp((((rb).tt) == DefineConstants.LUA_TNUMBER), (rb).value.n);
					double nc = check_exp((((rc).tt) == DefineConstants.LUA_TNUMBER), (rc).value.n);
					{
						lua_TValue i_o = (ra);
						i_o.value.n = (((nb) * (nc)));
						i_o.tt = DefineConstants.LUA_TNUMBER;
					};
				}
				else
				{
					L.savedpc = pc;
					{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: Arith(L, ra, rb, rc, TM_MUL);
						Arith(new lua_State(L), ra, rb, rc, TMS.TM_MUL);
					};
					@base = L.@base;
				};
		};
			continue;
		  }
		  case OpCode.OP_DIV:
		  {
			{
				lua_TValue rb = check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))));
				lua_TValue rc = check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 2) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0)))));
				if ((((rb).tt) == DefineConstants.LUA_TNUMBER) && (((rc).tt) == DefineConstants.LUA_TNUMBER))
				{
					double nb = check_exp((((rb).tt) == DefineConstants.LUA_TNUMBER), (rb).value.n);
					double nc = check_exp((((rc).tt) == DefineConstants.LUA_TNUMBER), (rc).value.n);
					{
						lua_TValue i_o = (ra);
						i_o.value.n = (((nb) / (nc)));
						i_o.tt = DefineConstants.LUA_TNUMBER;
					};
				}
				else
				{
					L.savedpc = pc;
					{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: Arith(L, ra, rb, rc, TM_DIV);
						Arith(new lua_State(L), ra, rb, rc, TMS.TM_DIV);
					};
					@base = L.@base;
				};
		};
			continue;
		  }
		  case OpCode.OP_MOD:
		  {
			{
				lua_TValue rb = check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))));
				lua_TValue rc = check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 2) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0)))));
				if ((((rb).tt) == DefineConstants.LUA_TNUMBER) && (((rc).tt) == DefineConstants.LUA_TNUMBER))
				{
					double nb = check_exp((((rb).tt) == DefineConstants.LUA_TNUMBER), (rb).value.n);
					double nc = check_exp((((rc).tt) == DefineConstants.LUA_TNUMBER), (rc).value.n);
					{
						lua_TValue i_o = (ra);
						i_o.value.n = (((nb) - Math.Floor((nb) / (nc)) * (nc)));
						i_o.tt = DefineConstants.LUA_TNUMBER;
					};
				}
				else
				{
					L.savedpc = pc;
					{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: Arith(L, ra, rb, rc, TM_MOD);
						Arith(new lua_State(L), ra, rb, rc, TMS.TM_MOD);
					};
					@base = L.@base;
				};
		};
			continue;
		  }
		  case OpCode.OP_POW:
		  {
			{
				lua_TValue rb = check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))));
				lua_TValue rc = check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 2) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0)))));
				if ((((rb).tt) == DefineConstants.LUA_TNUMBER) && (((rc).tt) == DefineConstants.LUA_TNUMBER))
				{
					double nb = check_exp((((rb).tt) == DefineConstants.LUA_TNUMBER), (rb).value.n);
					double nc = check_exp((((rc).tt) == DefineConstants.LUA_TNUMBER), (rc).value.n);
					{
						lua_TValue i_o = (ra);
						i_o.value.n = ((Math.Pow(nb,nc)));
						i_o.tt = DefineConstants.LUA_TNUMBER;
					};
				}
				else
				{
					L.savedpc = pc;
					{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: Arith(L, ra, rb, rc, TM_POW);
						Arith(new lua_State(L), ra, rb, rc, TMS.TM_POW);
					};
					@base = L.@base;
				};
		};
			continue;
		  }
		  case OpCode.OP_UNM:
		  {
			lua_TValue rb = check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgR, @base + (((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))));
			if ((((rb).tt) == DefineConstants.LUA_TNUMBER))
			{
			  double nb = check_exp((((rb).tt) == DefineConstants.LUA_TNUMBER), (rb).value.n);
			  {
				  lua_TValue i_o = (ra);
				  i_o.value.n = ((-(nb)));
				  i_o.tt = DefineConstants.LUA_TNUMBER;
			  };
			}
			else
			{
			  {
				  L.savedpc = pc;
				  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: Arith(L, ra, rb, rb, TM_UNM);
					  Arith(new lua_State(L), ra, rb, rb, TMS.TM_UNM);
				  };
				  @base = L.@base;
		  };
			}
			continue;
		  }
		  case OpCode.OP_NOT:
		  {
			int res = ((((check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgR, @base + (((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))))).tt) == DefineConstants.LUA_TNIL) || ((((check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i)>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgR, @base + (((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))))).tt) == DefineConstants.LUA_TBOOLEAN) && check_exp(ttisboolean(check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i)>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgR, @base + (((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B))<<0)))))), (check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i)>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgR, @base + (((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))))).value.b) == 0)); // next assignment may change this value
			{
				lua_TValue i_o = (ra);
				i_o.value.b = (res);
				i_o.tt = DefineConstants.LUA_TBOOLEAN;
			};
			continue;
		  }
		  case OpCode.OP_LEN:
		  {
			lua_TValue rb = check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgR, @base + (((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))));
			switch (((rb).tt))
			{
			  case DefineConstants.LUA_TTABLE:
			  {
				{
					lua_TValue i_o = (ra);
					i_o.value.n = (((double)(luaH_getn(check_exp((((rb).tt) == DefineConstants.LUA_TTABLE), (rb).value.gc.h)))));
					i_o.tt = DefineConstants.LUA_TNUMBER;
			};
				break;
			  }
			  case DefineConstants.LUA_TSTRING:
			  {
				{
					lua_TValue i_o = (ra);
					i_o.value.n = (((double)(((check_exp((((rb).tt) == DefineConstants.LUA_TSTRING), (rb).value.gc.ts).tsv).len))));
					i_o.tt = DefineConstants.LUA_TNUMBER;
			};
				break;
			  }
			  default:
			  { // try metamethod
			  {
					L.savedpc = pc;
					{
						if (!call_binTM(L, rb, (luaO_nilobject_), ra, TMS.TM_LEN))
						{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaG_typeerror(L, rb, "get length of");
							luaG_typeerror(new lua_State(L), rb, "get length of");
						}
						;
					};
					@base = L.@base;
			}
			  }
		  break;
			}
			continue;
		  }
		  case OpCode.OP_CONCAT:
		  {
			int b = (((int)(((i) >> (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))));
			int c = (((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))));
			{
				L.savedpc = pc;
				{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaV_concat(L, c-b+1, c);
					luaV_concat(new lua_State(L), c - b + 1, c);
					{
						(x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
						if ((L.l_G).totalbytes >= (L.l_G).GCthreshold)
						{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaC_step(L);
							luaC_step(new lua_State(L));
						}
					};
				};
				@base = L.@base;
			};
			{
				lua_TValue o2 = (@base + b);
				lua_TValue o1 = ((@base + (((int)(((i) >> (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_A)) << 0))))));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
				o1.value.CopyFrom(o2.value);
				o1.tt = o2.tt;
				(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		};
			continue;
		  }
		  case OpCode.OP_JMP:
		  {
			{
				(pc) += (((((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << (DefineConstants.SIZE_C + DefineConstants.SIZE_B))) << 0)))) - MAXARG_sBx));
				{
					(L)(0)(L);
					(L)(0)(L);
				};
		};
			continue;
		  }
		  case OpCode.OP_EQ:
		  {
			lua_TValue rb = check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))));
			lua_TValue rc = check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 2) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0)))));
			{
				L.savedpc = pc;
				{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: if ((((rb)->tt) == ((rc)->tt) && luaV_equalval(L, rb, rc)) == (((int)(((i)>>(DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_A))<<0)))))
					if ((((rb).tt) == ((rc).tt) && luaV_equalval(new lua_State(L), rb, rc) != 0) == (((int)(((i) >> (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_A)) << 0)))))
					{
						(pc) += (((((int)(((*pc) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << (DefineConstants.SIZE_C + DefineConstants.SIZE_B))) << 0)))) - MAXARG_sBx));
						{
							(L)(0)(L);
							(L)(0)(L);
						};
					};
					;
				};
				@base = L.@base;
			}
			pc++;
			continue;
		  }
		  case OpCode.OP_LT:
		  {
			{
				L.savedpc = pc;
				{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: if (luaV_lessthan(L, check_exp((((enum OpArgMask)((luaP_opmodes[(((OpCode)(((i)>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP))<<0))))] >> 4) & 3))) == OpArgK, (((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_B))<<0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k+((int)((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_B))<<0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : base+(((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_B))<<0))))), check_exp((((enum OpArgMask)((luaP_opmodes[(((OpCode)(((i)>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP))<<0))))] >> 2) & 3))) == OpArgK, (((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_C))<<0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k+((int)((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_C))<<0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : base+(((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_C))<<0)))))) == (((int)(((i)>>(DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_A))<<0)))))
					if (luaV_lessthan(new lua_State(L), check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B))<<0))))), check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i)>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 2) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0)))))) == (((int)(((i)>>(DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_A)) << 0)))) != null)
					{
						(pc) += (((((int)(((*pc) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << (DefineConstants.SIZE_C + DefineConstants.SIZE_B))) << 0)))) - MAXARG_sBx));
						{
							(L)(0)(L);
							(L)(0)(L);
						};
					};
					;
				};
				@base = L.@base;
		}
			pc++;
			continue;
		  }
		  case OpCode.OP_LE:
		  {
			{
				L.savedpc = pc;
				{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: if (lessequal(L, check_exp((((enum OpArgMask)((luaP_opmodes[(((OpCode)(((i)>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP))<<0))))] >> 4) & 3))) == OpArgK, (((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_B))<<0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k+((int)((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_B))<<0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : base+(((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_B))<<0))))), check_exp((((enum OpArgMask)((luaP_opmodes[(((OpCode)(((i)>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP))<<0))))] >> 2) & 3))) == OpArgK, (((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_C))<<0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k+((int)((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_C))<<0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : base+(((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_C))<<0)))))) == (((int)(((i)>>(DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_A))<<0)))))
					if (lessequal(new lua_State(L), check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B))<<0))))), check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i)>> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 2) & 3))) == OpArgMask.OpArgK, (((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & (1 << (DefineConstants.SIZE_B - 1))) ? k + ((int)((((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))))) & ~(1 << (DefineConstants.SIZE_B - 1))) : @base + (((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0)))))) == (((int)(((i)>>(DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_A)) << 0)))) != null)
					{
						(pc) += (((((int)(((*pc) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << (DefineConstants.SIZE_C + DefineConstants.SIZE_B))) << 0)))) - MAXARG_sBx));
						{
							(L)(0)(L);
							(L)(0)(L);
						};
					};
					;
				};
				@base = L.@base;
		}
			pc++;
			continue;
		  }
		  case OpCode.OP_TEST:
		  {
			if (((((ra).tt) == DefineConstants.LUA_TNIL) || ((((ra).tt) == DefineConstants.LUA_TBOOLEAN) && check_exp(ttisboolean(ra), (ra).value.b) == 0)) != (((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0)))))
			{
				  (pc) += (((((int)(((*pc) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << (DefineConstants.SIZE_C + DefineConstants.SIZE_B))) << 0)))) - MAXARG_sBx));
				  {
					  (L)(0)(L);
					  (L)(0)(L);
				  };
			};
			pc++;
			continue;
		  }
		  case OpCode.OP_TESTSET:
		  {
			lua_TValue rb = check_exp((((OpArgMask)((luaP_opmodes[(((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_OP)) << 0))))] >> 4) & 3))) == OpArgMask.OpArgR, @base + (((int)(((i)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))));
			if (((((rb).tt) == DefineConstants.LUA_TNIL) || ((((rb).tt) == DefineConstants.LUA_TBOOLEAN) && check_exp(ttisboolean(rb), (rb).value.b) == 0)) != (((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0)))))
			{
			  {
				  lua_TValue o2 = (rb);
				  lua_TValue o1 = (ra);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
				  o1.value.CopyFrom(o2.value);
				  o1.tt = o2.tt;
				  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		  };
		  {
				  (pc) += (((((int)(((*pc) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << (DefineConstants.SIZE_C + DefineConstants.SIZE_B))) << 0)))) - MAXARG_sBx));
				  {
					  (L)(0)(L);
					  (L)(0)(L);
				  };
		  };
			}
			pc++;
			continue;
		  }
		  case OpCode.OP_CALL:
		  {
			int b = (((int)(((i) >> (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))));
			int nresults = (((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0)))) - 1;
			if (b != 0)
			{
				L.top = ra + b; // else previous instruction set top
			}
			L.savedpc = pc;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: switch (luaD_precall(L, ra, nresults))
			switch (luaD_precall(new lua_State(L), ra, nresults))
			{
			  case DefineConstants.PCRLUA:
			  {
				nexeccalls++;
				goto reentry; // restart luaV_execute over new Lua function
			  }
			  case DefineConstants.PCRC:
			  {
				/* it was a C function (`precall' called it); adjust results */
				if (nresults >= 0)
				{
					L.top = L.ci.top;
				}
				@base = L.@base;
				continue;
			  }
			  default:
			  {
				return; // yield
			  }
			}
		  }
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		  case OpCode.OP_TAILCALL:
		  {
			int b = (((int)(((i) >> (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))));
			if (b != 0)
			{
				L.top = ra + b; // else previous instruction set top
			}
			L.savedpc = pc;
			(c)(0)((((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0)))) - 1 == DefineConstants.LUA_MULTRET);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: switch (luaD_precall(L, ra, DefineConstants.LUA_MULTRET))
			switch (luaD_precall(new lua_State(L), ra, DefineConstants.LUA_MULTRET))
			{
			  case DefineConstants.PCRLUA:
			  {
				/* tail call: put new frame in place of previous one */
				CallInfo ci = L.ci - 1; // previous frame
				int aux;
				lua_TValue func = ci.func;
				lua_TValue pfunc = (ci + 1).func; // previous function index
				if (L.openupval != null)
				{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaF_close(L, ci->base);
					luaF_close(new lua_State(L), ci.@base);
				}
				L.@base = ci.@base = ci.func + ((ci + 1).@base - pfunc);
				for (aux = 0; pfunc + aux < L.top; aux++) // move frame down
				{
					  lua_TValue o2 = (pfunc + aux);
					  lua_TValue o1 = (func + aux);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
					  o1.value.CopyFrom(o2.value);
					  o1.tt = o2.tt;
					  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
				};
				ci.top = L.top = func + aux; // correct top
				(c)(0)(L.top == L.@base + check_exp((((func).tt) == DefineConstants.LUA_TFUNCTION), (func).value.gc.cl).l.p.maxstacksize);
				ci.savedpc = L.savedpc;
				ci.tailcalls++; // one more call lost
				L.ci--; // remove new frame
				goto reentry;
			  }
			  case DefineConstants.PCRC:
			  { // it was a C function (`precall' called it)
				@base = L.@base;
				continue;
			  }
			  default:
			  {
				return; // yield
			  }
			}
		  }
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		  case OpCode.OP_RETURN:
		  {
			int b = (((int)(((i) >> (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))));
			if (b != 0)
			{
				L.top = ra + b - 1;
			}
			if (L.openupval != null)
			{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaF_close(L, base);
				luaF_close(new lua_State(L), @base);
			}
			L.savedpc = pc;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: b = luaD_poscall(L, ra);
			b = luaD_poscall(new lua_State(L), ra);
			if (--nexeccalls == 0) // was previous function running `here'?
			{
			  return; // no: return
			}
			else
			{ // yes: continue its execution
			  if (b != 0)
			  {
				  L.top = L.ci.top;
			  }
			  (c)(0)((((((L.ci).func).tt) == DefineConstants.LUA_TFUNCTION) && (!(check_exp(ttisfunction((L.ci).func), ((L.ci).func).value.gc.cl)).c.isC)));
			  (c)(0)((((OpCode)(((*((L.ci).savedpc - 1)) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))) == OpCode.OP_CALL);
			  goto reentry;
			}
		  }
//C++ TO C# CONVERTER TODO TASK: C# does not allow fall-through from a non-empty 'case':
		  case OpCode.OP_FORLOOP:
		  {
			double step = check_exp((((ra + 2).tt) == DefineConstants.LUA_TNUMBER), (ra + 2).value.n);
			double idx = ((check_exp((((ra).tt) == DefineConstants.LUA_TNUMBER), (ra).value.n)) + (step)); // increment index
			double limit = check_exp((((ra + 1).tt) == DefineConstants.LUA_TNUMBER), (ra + 1).value.n);
			if (((0) < (step)) ? ((idx) <= (limit)) : ((limit) <= (idx)))
			{
			  {
				  (pc) += (((((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << (DefineConstants.SIZE_C + DefineConstants.SIZE_B))) << 0)))) - MAXARG_sBx));
				  {
					  (L)(0)(L);
					  (L)(0)(L);
				  };
		  }; // jump back
		  {
				  lua_TValue i_o = (ra);
				  i_o.value.n = (idx);
				  i_o.tt = DefineConstants.LUA_TNUMBER;
		  }; // update internal index...
		  {
				  lua_TValue i_o = (ra + 3);
				  i_o.value.n = (idx);
				  i_o.tt = DefineConstants.LUA_TNUMBER;
		  }; // ...and external index
			}
			continue;
		  }
		  case OpCode.OP_FORPREP:
		  {
			lua_TValue init = ra;
			lua_TValue plimit = ra + 1;
			lua_TValue pstep = ra + 2;
			L.savedpc = pc; // next steps may throw errors
			if (!(((init).tt) == DefineConstants.LUA_TNUMBER || (((init) = luaV_tonumber(init, ra)) != null)))
			{
			  luaG_runerror(L, "'" "for" "'" " initial value must be a number");
			}
			else if (!(((plimit).tt) == DefineConstants.LUA_TNUMBER || (((plimit) = luaV_tonumber(plimit, ra + 1)) != null)))
			{
			  luaG_runerror(L, "'" "for" "'" " limit must be a number");
			}
			else if (!(((pstep).tt) == DefineConstants.LUA_TNUMBER || (((pstep) = luaV_tonumber(pstep, ra + 2)) != null)))
			{
			  luaG_runerror(L, "'" "for" "'" " step must be a number");
			}
			{
				lua_TValue i_o = (ra);
				i_o.value.n = (((check_exp((((ra).tt) == DefineConstants.LUA_TNUMBER), (ra).value.n)) - (check_exp((((pstep).tt) == DefineConstants.LUA_TNUMBER), (pstep).value.n))));
				i_o.tt = DefineConstants.LUA_TNUMBER;
		};
		{
				(pc) += (((((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << (DefineConstants.SIZE_C + DefineConstants.SIZE_B))) << 0)))) - MAXARG_sBx));
				{
					(L)(0)(L);
					(L)(0)(L);
				};
		};
			continue;
		  }
		  case OpCode.OP_TFORLOOP:
		  {
			lua_TValue cb = ra + 3; // call base
			{
				lua_TValue o2 = (ra + 2);
				lua_TValue o1 = (cb + 2);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
				o1.value.CopyFrom(o2.value);
				o1.tt = o2.tt;
				(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
			};
			{
				lua_TValue o2 = (ra + 1);
				lua_TValue o1 = (cb + 1);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
				o1.value.CopyFrom(o2.value);
				o1.tt = o2.tt;
				(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		};
		{
				lua_TValue o2 = (ra);
				lua_TValue o1 = (cb);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
				o1.value.CopyFrom(o2.value);
				o1.tt = o2.tt;
				(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		};
			L.top = cb + 3; // func. + 2 args (state and index)
			{
				L.savedpc = pc;
				{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaD_call(L, cb, (((int)(((i)>>((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_C))<<0)))));
					luaD_call(new lua_State(L), cb, (((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0)))));
				};
				@base = L.@base;
			};
			L.top = L.ci.top;
			cb = (@base + (((int)(((i) >> (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_A)) << 0))))) + 3; // previous call may change the stack
			if (!(((cb).tt) == DefineConstants.LUA_TNIL))
			{ // continue loop?
			{
				  lua_TValue o2 = (cb);
				  lua_TValue o1 = (cb - 1);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
				  o1.value.CopyFrom(o2.value);
				  o1.tt = o2.tt;
				  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		  }; // save control variable
		  {
				  (pc) += (((((int)(((*pc) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << (DefineConstants.SIZE_C + DefineConstants.SIZE_B))) << 0)))) - MAXARG_sBx));
				  {
					  (L)(0)(L);
					  (L)(0)(L);
				  };
		  }; // jump back
			}
			pc++;
			continue;
		  }
		  case OpCode.OP_SETLIST:
		  {
			int n = (((int)(((i) >> (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))));
			int c = (((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))));
			int last;
			Table h;
			if (n == 0)
			{
			  n = ((int)((L.top - ra))) - 1;
			  L.top = L.ci.top;
			}
			if (c == 0)
			{
				c = ((int)((*pc++)));
			}
			{
				if (!((((ra).tt) == DefineConstants.LUA_TTABLE)))
				{
					break;
				}
		};
			h = check_exp((((ra).tt) == DefineConstants.LUA_TTABLE), (ra).value.gc.h);
			last = ((c - 1) * DefineConstants.LFIELDS_PER_FLUSH) + n;
			if (last > h.sizearray) // needs more space?
			{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaH_resizearray(L, h, last);
			  luaH_resizearray(new lua_State(L), h, last); // pre-alloc it at once
			}
			for (; n > 0; n--)
			{
			  lua_TValue val = ra + n;
			  {
				  lua_TValue o2 = (val);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: lua_TValue *o1=(luaH_setnum(L, h, last--));
				  lua_TValue o1 = (luaH_setnum(new lua_State(L), h, last--));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
				  o1.value.CopyFrom(o2.value);
				  o1.tt = o2.tt;
				  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
			  };
			  {
				  if (((((val).tt) >= DefineConstants.LUA_TSTRING) && (((check_exp((((val).tt) >= DefineConstants.LUA_TSTRING), (val).value.gc)).gch.marked) & ((((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))))) && ((((((union GCObject)((h))))).gch.marked) & ((1 << (DefineConstants.BLACKBIT)))))
				  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaC_barrierback(L,h);
					  luaC_barrierback(new lua_State(L), h);
				  }
		  };
			}
			continue;
		  }
		  case OpCode.OP_CLOSE:
		  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaF_close(L, ra);
			luaF_close(new lua_State(L), ra);
			continue;
		  }
		  case OpCode.OP_CLOSURE:
		  {
			Proto[] p;
			Closure ncl;
			int nup;
			int j;
			p = cl.p.p[(((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << (DefineConstants.SIZE_C + DefineConstants.SIZE_B))) << 0))))];
			nup = p.nups;
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: ncl = luaF_newLclosure(L, nup, cl->env);
			ncl = luaF_newLclosure(new lua_State(L), nup, cl.env);
			ncl.l.p = p;
			for (j = 0; j < nup; j++, pc++)
			{
			  if ((((OpCode)(((*pc) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))) == OpCode.OP_GETUPVAL)
			  {
				ncl.l.upvals[j] = cl.upvals[(((int)(((*pc) >> (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))))];
			  }
			  else
			  {
				(c)(0)((((OpCode)(((*pc) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0)))) == OpCode.OP_MOVE);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: ncl->l.upvals[j] = luaF_findupval(L, base + (((int)(((*pc)>>(((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0)<<DefineConstants.SIZE_B))<<0)))));
				ncl.l.upvals[j] = luaF_findupval(new lua_State(L), @base + (((int)(((*pc) >> (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))));
			  }
			}
			{
				lua_TValue i_o = (ra);
				i_o.value.gc = ((union GCObject)((ncl)));
				i_o.tt = DefineConstants.LUA_TFUNCTION;
				(c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
		};
		{
				L.savedpc = pc;
				{
					{
						(x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
						if ((L.l_G).totalbytes >= (L.l_G).GCthreshold)
						{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaC_step(L);
							luaC_step(new lua_State(L));
						}
				};
				};
				@base = L.@base;
		};
			continue;
		  }
		  case OpCode.OP_VARARG:
		  {
			int b = (((int)(((i) >> (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0)))) - 1;
			int j;
			CallInfo ci = L.ci;
			int n = ((int)((ci.@base - ci.func))) - cl.p.numparams - 1;
			if (b == DefineConstants.LUA_MULTRET)
			{
			  {
				  L.savedpc = pc;
				  {
					  if ((string)L.stack_last - (string)L.top <= (n) * (int)sizeof(lua_TValue) != null)
					  {
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: luaD_growstack(L, n);
						  luaD_growstack(new lua_State(L), n);
					  }
					  else
					  {
						  (x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
					  }
					  ;
				  };
				  @base = L.@base;
		  };
			  ra = (@base + (((int)(((i) >> (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_A)) << 0))))); // previous call may change the stack
			  b = n;
			  L.top = ra + n;
			}
			for (j = 0; j < b; j++)
			{
			  if (j < n)
			  {
				{
					lua_TValue o2 = (ci.@base - n + j);
					lua_TValue o1 = (ra + j);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
					o1.value.CopyFrom(o2.value);
					o1.tt = o2.tt;
					(c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
			};
			  }
			  else
			  {
				((ra + j).tt = DefineConstants.LUA_TNIL);
			  }
			}
			continue;
		  }
		}
	  }
	}
	public static void luaV_concat(lua_State L, int total, int last)
	{
	  do
	  {
		lua_TValue top = L.@base + last + 1;
		int n = 2; // number of elements handled in this pass (at least 2)
		if (!((((top - 2).tt) == DefineConstants.LUA_TSTRING) || (((top - 2).tt) == DefineConstants.LUA_TNUMBER)) || !((ttype(top - 1) == DefineConstants.LUA_TSTRING) || (luaV_tostring(L, top - 1)) != 0))
		{
		  if (!call_binTM(L, top - 2, top - 1, top - 2, TMS.TM_CONCAT))
		  {
			luaG_concaterror(L, top - 2, top - 1);
		  }
		}
		else if ((check_exp((((top - 1).tt) == DefineConstants.LUA_TSTRING), (top - 1).value.gc.ts).tsv).len == 0) // second op is empty?
		{
		  ((((top - 2).tt) == DefineConstants.LUA_TSTRING) || (luaV_tostring(L, top - 2)) != 0); // result is first op (as string)
		}
		else
		{
		  /* at least two string values; get as many as possible */
		  size_t tl = (check_exp((((top - 1).tt) == DefineConstants.LUA_TSTRING), (top - 1).value.gc.ts).tsv).len;
		  string buffer;
		  int i;
		  /* collect total length */
		  for (n = 1; n < total && ((((top - n - 1).tt) == DefineConstants.LUA_TSTRING) || (luaV_tostring(L, top - n - 1)) != 0); n++)
		  {
			size_t l = (check_exp((((top - n - 1).tt) == DefineConstants.LUA_TSTRING), (top - n - 1).value.gc.ts).tsv).len;
			if (l >= ((size_t)(~(size_t)0) - 2) - tl)
			{
				luaG_runerror(L, "string length overflow");
			}
			tl += l;
		  }
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: buffer = luaZ_openspace(L, &(L->l_G)->buff, tl);
		  buffer = luaZ_openspace(L, (L.l_G).buff, new size_t(tl));
		  tl = 0;
		  for (i = n; i > 0; i--)
		  { // concat all strings
			size_t l = (check_exp((((top - i).tt) == DefineConstants.LUA_TSTRING), (top - i).value.gc.ts).tsv).len;
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
			memcpy(buffer + tl, ((string)((check_exp((((top - i).tt) == DefineConstants.LUA_TSTRING), (top - i).value.gc.ts)) + 1)), l);
			tl += l;
		  }
		  {
			  lua_TValue i_o = (top - n);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: i_o->value.gc=((union GCObject *)((luaS_newlstr(L, buffer, tl))));
			  i_o.value.gc = ((union GCObject)(luaS_newlstr(L, buffer, new size_t(tl))));
			  i_o.tt = DefineConstants.LUA_TSTRING;
			  (c)(0)(!(((i_o).tt) >= DefineConstants.LUA_TSTRING) || ((((i_o).tt) == (i_o).value.gc.gch.tt) && !(((i_o).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
		}
		total -= n - 1; // got `n' strings to create 1 new
		last -= n - 1;
	  } while (total > 1); // repeat until only 1 result left
	}





	/* limit for table tag-method chains (to avoid loops) */


	internal static void traceexec(lua_State L, LUAI_UINT32 pc)
	{
	  byte mask = L.hookmask;
	  LUAI_UINT32 oldpc = L.savedpc;
	  L.savedpc = pc;
	  if ((mask & (1 << DefineConstants.LUA_HOOKCOUNT)) && L.hookcount == 0)
	  {
		(L.hookcount = L.basehookcount);
		luaD_callhook(L, DefineConstants.LUA_HOOKCOUNT, -1);
	  }
	  if ((mask & (1 << DefineConstants.LUA_HOOKLINE)) != 0)
	  {
		Proto p = (check_exp(((((L.ci).func).tt) == DefineConstants.LUA_TFUNCTION), ((L.ci).func).value.gc.cl)).l.p;
		int npc = (((int)((pc) - (p).code)) - 1);
		int newline = (((p).lineinfo) ? (p).lineinfo[npc] : 0);
		/* call linehook when enter a new function, when jump back (loop),
		   or when enter a new line */
		if (npc == 0 || pc <= oldpc != null || newline != (((p).lineinfo) ? (p).lineinfo[(((int)((oldpc) - (p).code)) - 1)] : 0))
		{
		  luaD_callhook(L, DefineConstants.LUA_HOOKLINE, newline);
		}
	  }
	}


	internal static void callTMres(lua_State L, lua_TValue res, lua_TValue f, lua_TValue p1, lua_TValue p2)
	{
	  ptrdiff_t result = ((string)(res) - (string)L.stack);
	  {
		  lua_TValue o2 = (f);
		  lua_TValue o1 = (L.top);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
		  o1.value.CopyFrom(o2.value);
		  o1.tt = o2.tt;
		  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  }; // push function
	  {
		  lua_TValue o2 = (p1);
		  lua_TValue o1 = (L.top + 1);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
		  o1.value.CopyFrom(o2.value);
		  o1.tt = o2.tt;
		  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
  }; // 1st argument
  {
		  lua_TValue o2 = (p2);
		  lua_TValue o1 = (L.top + 2);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
		  o1.value.CopyFrom(o2.value);
		  o1.tt = o2.tt;
		  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
  }; // 2nd argument
	  if ((string)L.stack_last - (string)L.top <= (3) * (int)sizeof(lua_TValue) != null)
	  {
		  luaD_growstack(L, 3);
	  }
	  else
	  {
		  (x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
	  }
	  L.top += 3;
	  luaD_call(L, L.top - 3, 1);
	  res = ((lua_TValue)((string)L.stack + (result)));
	  L.top--;
	  {
		  lua_TValue o2 = (L.top);
		  lua_TValue o1 = (res);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
		  o1.value.CopyFrom(o2.value);
		  o1.tt = o2.tt;
		  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
	  };
	}



	internal static void callTM(lua_State L, lua_TValue f, lua_TValue p1, lua_TValue p2, lua_TValue p3)
	{
	  {
		  lua_TValue o2 = (f);
		  lua_TValue o1 = (L.top);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
		  o1.value.CopyFrom(o2.value);
		  o1.tt = o2.tt;
		  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
  }; // push function
  {
		  lua_TValue o2 = (p1);
		  lua_TValue o1 = (L.top + 1);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
		  o1.value.CopyFrom(o2.value);
		  o1.tt = o2.tt;
		  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
  }; // 1st argument
  {
		  lua_TValue o2 = (p2);
		  lua_TValue o1 = (L.top + 2);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
		  o1.value.CopyFrom(o2.value);
		  o1.tt = o2.tt;
		  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
  }; // 2nd argument
  {
		  lua_TValue o2 = (p3);
		  lua_TValue o1 = (L.top + 3);
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: o1->value = o2->value;
		  o1.value.CopyFrom(o2.value);
		  o1.tt = o2.tt;
		  (c)(0)(!(((o1).tt) >= DefineConstants.LUA_TSTRING) || ((((o1).tt) == (o1).value.gc.gch.tt) && !(((o1).value.gc).gch.marked & ((L.l_G).currentwhite ^ ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT)))) & ((1 << (DefineConstants.WHITE0BIT)) | (1 << (DefineConstants.WHITE1BIT))))));
  }; // 3th argument
	  if ((string)L.stack_last - (string)L.top <= (4) * (int)sizeof(lua_TValue) != null)
	  {
		  luaD_growstack(L, 4);
	  }
	  else
	  {
		  (x)(0)(luaD_reallocstack(L, L.stacksize - DefineConstants.EXTRA_STACK - 1));
	  }
	  L.top += 4;
	  luaD_call(L, L.top - 4, 0);
	}


	private static int call_binTM(struct lua_State * L, const lua_TValue * p1, const lua_TValue * p2, lua_TValue * res, TMS event)
	{
	  lua_TValue tm = luaT_gettmbyobj(L, p1, event); // try first operand
	  if ((((tm).tt) == DefineConstants.LUA_TNIL))
	  {
		tm = luaT_gettmbyobj(L, p2, event); // try second operand
	  }
	  if ((((tm).tt) == DefineConstants.LUA_TNIL))
	  {
		  return 0;
	  }
	  callTMres(L, res, tm, p1, p2);
	  return 1;
	}


	private static const lua_TValue * get_compTM(struct lua_State * L, Table * mt1, Table * mt2, TMS event)
	{
	  lua_TValue tm1 = ((mt1) == null ? null : ((mt1).flags & (1u << (event))) ? null : luaT_gettm(mt1, event, ((L.l_G)).tmname[event]));
	  lua_TValue tm2;
	  if (tm1 == null)
	  {
		  return null; // no metamethod
	  }
	  if (mt1 == mt2)
	  {
		  return tm1; // same metatables => same metamethods
	  }
	  tm2 = ((mt2) == null ? null : ((mt2).flags & (1u << (event))) ? null : luaT_gettm(mt2, event, ((L.l_G)).tmname[event]));
	  if (tm2 == null)
	  {
		  return null; // no metamethod
	  }
	  if (luaO_rawequalObj(tm1, tm2) != 0) // same metamethods?
	  {
		return tm1;
	  }
	  return null;
	}


	private static int call_orderTM(struct lua_State * L, const lua_TValue * p1, const lua_TValue * p2, TMS event)
	{
	  lua_TValue tm1 = luaT_gettmbyobj(L, p1, event);
	  lua_TValue tm2;
	  if ((((tm1).tt) == DefineConstants.LUA_TNIL))
	  {
		  return -1; // no metamethod?
	  }
	  tm2 = luaT_gettmbyobj(L, p2, event);
	  if (luaO_rawequalObj(tm1, tm2) == 0) // different metamethods?
	  {
		return -1;
	  }
	  callTMres(L, L.top, tm1, p1, p2);
	  return !((((L.top).tt) == DefineConstants.LUA_TNIL) || ((((L.top).tt) == DefineConstants.LUA_TBOOLEAN) && check_exp(ttisboolean(L.top), (L.top).value.b) == 0));
	}


	internal static int l_strcmp(TString ls, TString rs)
	{
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  sbyte * l = ((string)((ls) + 1));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: size_t ll = ls->tsv.len;
	  size_t ll = new size_t(ls.tsv.len);
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	  sbyte * r = ((string)((rs) + 1));
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: size_t lr = rs->tsv.len;
	  size_t lr = new size_t(rs.tsv.len);
	  for (;;)
	  {
		int temp = strcoll(l, r);
		if (temp != 0)
		{
			return temp;
		}
		else
		{ // strings are equal up to a `\0'
		  size_t len = l.Length; // index of first `\0' in both strings
		  if (len == lr) // r is finished?
		  {
			return (len == ll) ? 0 : 1;
		  }
		  else if (len == ll) // l is finished?
		  {
			return -1; // l is smaller than r (because r is not finished)
		  }
		  /* both strings longer than `len'; go on comparing (after the `\0') */
		  len++;
		  l += len;
		  ll -= len;
		  r += len;
		  lr -= len;
		}
	  }
	}


	internal static int lessequal(lua_State L, lua_TValue l, lua_TValue r)
	{
	  int res;
	  if (((l).tt) != ((r).tt))
	  {
		return luaG_ordererror(L, l, r);
	  }
	  else if ((((l).tt) == DefineConstants.LUA_TNUMBER))
	  {
		return ((check_exp((((l).tt) == DefineConstants.LUA_TNUMBER), (l).value.n)) <= (check_exp((((r).tt) == DefineConstants.LUA_TNUMBER), (r).value.n)));
	  }
	  else if ((((l).tt) == DefineConstants.LUA_TSTRING))
	  {
		return l_strcmp(check_exp((((l).tt) == DefineConstants.LUA_TSTRING), (l).value.gc.ts), check_exp((((r).tt) == DefineConstants.LUA_TSTRING), (r).value.gc.ts)) <= 0;
	  }
	  else if ((res = call_orderTM(L, l, r, TMS.TM_LE)) != -1) // first try `le'
	  {
		return res;
	  }
	  else if ((res = call_orderTM(L, r, l, TMS.TM_LT)) != -1) // else try `lt'
	  {
		return res == 0;
	  }
	  return luaG_ordererror(L, l, r);
	}


	internal static void Arith(lua_State L, lua_TValue ra, lua_TValue rb, lua_TValue rc, TMS op)
	{
	  lua_TValue tempb = new lua_TValue();
	  lua_TValue tempc = new lua_TValue();
	  lua_TValue b;
	  lua_TValue c;
	  if ((b = luaV_tonumber(rb, tempb)) != null && (c = luaV_tonumber(rc, tempc)) != null)
	  {
		double nb = check_exp((((b).tt) == DefineConstants.LUA_TNUMBER), (b).value.n);
		double nc = check_exp((((c).tt) == DefineConstants.LUA_TNUMBER), (c).value.n);
		switch (op)
		{
		  case TMS.TM_ADD:
		  {
			  lua_TValue i_o = (ra);
			  i_o.value.n = (((nb) + (nc)));
			  i_o.tt = DefineConstants.LUA_TNUMBER;
		  };
		  break;
		  case TMS.TM_SUB:
		  {
			  lua_TValue i_o = (ra);
			  i_o.value.n = (((nb) - (nc)));
			  i_o.tt = DefineConstants.LUA_TNUMBER;
		  };
		  break;
		  case TMS.TM_MUL:
		  {
			  lua_TValue i_o = (ra);
			  i_o.value.n = (((nb) * (nc)));
			  i_o.tt = DefineConstants.LUA_TNUMBER;
		  };
		  break;
		  case TMS.TM_DIV:
		  {
			  lua_TValue i_o = (ra);
			  i_o.value.n = (((nb) / (nc)));
			  i_o.tt = DefineConstants.LUA_TNUMBER;
		  };
		  break;
		  case TMS.TM_MOD:
		  {
			  lua_TValue i_o = (ra);
			  i_o.value.n = (((nb) - Math.Floor((nb) / (nc)) * (nc)));
			  i_o.tt = DefineConstants.LUA_TNUMBER;
		  };
		  break;
		  case TMS.TM_POW:
		  {
			  lua_TValue i_o = (ra);
			  i_o.value.n = ((Math.Pow(nb,nc)));
			  i_o.tt = DefineConstants.LUA_TNUMBER;
		  };
		  break;
		  case TMS.TM_UNM:
		  {
			  lua_TValue i_o = (ra);
			  i_o.value.n = ((-(nb)));
			  i_o.tt = DefineConstants.LUA_TNUMBER;
		  };
		  break;
		  default:
			  (c)(0)(0);
			  break;
		}
	  }
	  else if (!call_binTM(L, rb, rc, ra, op))
	  {
		luaG_aritherror(L, rb, rc);
	  }
	}



	/*
	** some macros for common tasks in `luaV_execute'
	*/

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define runtime_check(L, c) { if (!(c)) break; }

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define RA(i) (base+GETARG_A(i))
	/* to be used after possible stack reallocation */
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define RB(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define RC(i) check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define RKB(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgK, ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define RKC(i) check_exp(getCMode(GET_OPCODE(i)) == OpArgK, ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define KBx(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i))


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define dojump(L,pc,i) {(pc) += (i); luai_threadyield(L);}


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Protect(x) { L->savedpc = pc; {x;}; base = L->base; }


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define arith_op(op,tm) { TValue *rb = RKB(i); TValue *rc = RKC(i); if (ttisnumber(rb) && ttisnumber(rc)) { lua_Number nb = nvalue(rb), nc = nvalue(rc); setnvalue(ra, op(nb, nc)); } else Protect(Arith(L, ra, rb, rc, tm)); }



/* ------------------------------------------------------------------------ */

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_buffer(buff) ((buff)->buffer)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_sizebuffer(buff) ((buff)->buffsize)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_bufflen(buff) ((buff)->n)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resetbuffer(buff) ((buff)->n = 0)


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resizebuffer(L, buff, size) (luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), (buff)->buffsize = size)

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_freebuffer(L, buff) luaZ_resizebuffer(L, buff, 0)


	public static string luaZ_openspace(lua_State L, Mbuffer buff, size_t n)
	{
	  if (n > buff.buffsize)
	  {
		if (n < DefineConstants.LUA_MINBUFFER)
		{
			n = DefineConstants.LUA_MINBUFFER;
		}
		((((buff).buffer) = ((string)(((cast(size_t, (n) + 1) <= ((size_t)(~(size_t)0) - 2) / (sizeof(sbyte))) ? luaM_realloc_(L, ((buff).buffer), ((buff).buffsize) * (sizeof(sbyte)), (n) * (sizeof(sbyte))) : luaM_toobig(L))))), (buff).buffsize = n);
	  }
	  return buff.buffer;
	}
	public static void luaZ_init(lua_State L, Zio z, lua_Reader reader, object data)
	{
	  z.L = L;
	  z.reader = reader;
	  z.data = data;
	  z.n = 0;
	  z.p = null;
	}

/* --------------------------------------------------------------- read --- */
	public static size_t luaZ_read(Zio z, object b, size_t n)
	{
	  while (n != null)
	  {
		size_t m = new size_t();
		if (luaZ_lookahead(z) == DefineConstants.EOZ)
		{
		  return n; // return number of missing bytes
		}
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: m = (n <= z->n) ? n : z->n;
		m.CopyFrom((n <= z.n) ? n : z.n); // min. between n and z->n
//C++ TO C# CONVERTER TODO TASK: The memory management function 'memcpy' has no equivalent in C#:
		memcpy(b, z.p, m);
		z.n -= m;
		z.p += m;
		b = (string)b + m;
		n -= m;
	  }
	  return 0;
	}
	public static int luaZ_lookahead(Zio z)
	{
	  if (z.n == 0)
	  {
		if (luaZ_fill(z) == DefineConstants.EOZ)
		{
		  return DefineConstants.EOZ;
		}
		else
		{
		  z.n++; // luaZ_fill removed first byte; put back it
		  z.p--;
		}
	  }
	  return ((int)(((byte)((*z.p)))));
	}


	public static int luaZ_fill(Zio z)
	{
	  size_t size = new size_t();
	  lua_State L = z.L;
	  string buff;
	  (L)(0)(L);
	  buff = z.reader(L, z.data, size);
	  (L)(0)(L);
	  if (buff == null || size == 0)
	  {
		  return DefineConstants.EOZ;
	  }
//C++ TO C# CONVERTER TODO TASK: The following line was determined to be a copy assignment (rather than a reference assignment) - this should be verified and a 'CopyFrom' method should be created:
//ORIGINAL LINE: z->n = size - 1;
	  z.n.CopyFrom(size - 1);
	  z.p = buff;
	  return ((int)(((byte)((*(z.p++))))));
	}


	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gt(L) (&L->l_gt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define registry(L) (&G(L)->l_registry)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BASIC_STACK_SIZE (2*LUA_MINSTACK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define curr_func(L) (clvalue(L->ci->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ci_func(ci) (clvalue((ci)->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define f_isLua(ci) (!ci_func(ci)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLua(ci) (ttisfunction((ci)->func) && f_isLua(ci))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define G(L) (L->l_G)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2ts(o) check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2ts(o) (&rawgco2ts(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2u(o) check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2u(o) (&rawgco2u(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2cl(o) check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2h(o) check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2p(o) check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2uv(o) check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ngcotouv(o) check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2th(o) check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define obj2gco(v) (cast(GCObject *, (v)))



	/*
	** $Id: print.c,v 1.55a 2006/05/31 13:30:05 lhf Exp $
	** print bytecodes
	** See Copyright Notice in lua.h
	*/


//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define luac_c

//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DYLD
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_VARARG
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_MOD
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_LSTR
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_GFIND
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_OPENLIB
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUAI_BITSINT
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUAI_BITSINT
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DLOPEN
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DLL
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_SIZET ((size_t)(~(size_t)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_LUMEM ((lu_mem)(~(lu_mem)0)-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAX_INT (INT_MAX-2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define IntPoint(p) ((unsigned int)(lu_mem)(p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (lua_assert(c), (e))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check(l,e) lua_assert(e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(c) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define check_exp(c,e) (e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define api_check luai_apicheck
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define UNUSED(x) ((void)(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast(t, exp) ((t)(exp))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_byte(i) cast(lu_byte, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_num(i) cast(lua_Number, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define cast_int(i) cast(int, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_lock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_unlock(L) ((void) 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_threadyield(L) {lua_unlock(L); lua_lock(L);}
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) ((void)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define condhardstacktests(x) x
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LAST_TAG LUA_TTHREAD
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NUM_TAGS (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TPROTO (LAST_TAG+1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TUPVAL (LAST_TAG+2)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TDEADKEY (LAST_TAG+3)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define CommonHeader GCObject *next; lu_byte tt; lu_byte marked
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define TValuefields Value value; int tt
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnil(o) (ttype(o) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisnumber(o) (ttype(o) == LUA_TNUMBER)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisstring(o) (ttype(o) == LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttistable(o) (ttype(o) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisfunction(o) (ttype(o) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisboolean(o) (ttype(o) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisuserdata(o) (ttype(o) == LUA_TUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttisthread(o) (ttype(o) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttislightuserdata(o) (ttype(o) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ttype(o) ((o)->tt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gcvalue(o) check_exp(iscollectable(o), (o)->value.gc)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pvalue(o) check_exp(ttislightuserdata(o), (o)->value.p)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define nvalue(o) check_exp(ttisnumber(o), (o)->value.n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawtsvalue(o) check_exp(ttisstring(o), &(o)->value.gc->ts)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define tsvalue(o) (&rawtsvalue(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawuvalue(o) check_exp(ttisuserdata(o), &(o)->value.gc->u)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define uvalue(o) (&rawuvalue(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define clvalue(o) check_exp(ttisfunction(o), &(o)->value.gc->cl)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define hvalue(o) check_exp(ttistable(o), &(o)->value.gc->h)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define bvalue(o) check_exp(ttisboolean(o), (o)->value.b)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define thvalue(o) check_exp(ttisthread(o), &(o)->value.gc->th)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define l_isfalse(o) (ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkconsistency(obj) lua_assert(!iscollectable(obj) || (ttype(obj) == (obj)->value.gc->gch.tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define checkliveness(g,obj) lua_assert(!iscollectable(obj) || ((ttype(obj) == (obj)->value.gc->gch.tt) && !isdead(g, (obj)->value.gc)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnilvalue(obj) ((obj)->tt=LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setnvalue(obj,x) { TValue *i_o=(obj); i_o->value.n=(x); i_o->tt=LUA_TNUMBER; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setpvalue(obj,x) { TValue *i_o=(obj); i_o->value.p=(x); i_o->tt=LUA_TLIGHTUSERDATA; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setbvalue(obj,x) { TValue *i_o=(obj); i_o->value.b=(x); i_o->tt=LUA_TBOOLEAN; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TSTRING; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setuvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TUSERDATA; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setthvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTHREAD; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setclvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TFUNCTION; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTABLE; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue(L,obj,x) { TValue *i_o=(obj); i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TPROTO; checkliveness(G(L),i_o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj(L,obj1,obj2) { const TValue *o2=(obj2); TValue *o1=(obj1); o1->value = o2->value; o1->tt=o2->tt; checkliveness(G(L),o1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjs2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2s setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2s setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sethvalue2s sethvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setptvalue2s setptvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobjt2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2t setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setobj2n setobj
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setsvalue2n setsvalue
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define setttype(obj, tt) (ttype(obj) = (tt))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscollectable(o) (ttype(o) >= LUA_TSTRING)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getstr(ts) cast(const char *, (ts) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define svalue(o) getstr(rawtsvalue(o))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ClosureHeader CommonHeader; lu_byte isC; lu_byte nupvalues; GCObject *gclist; struct Table *env
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define iscfunction(o) (ttype(o) == LUA_TFUNCTION && clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLfunction(o) (ttype(o) == LUA_TFUNCTION && !clvalue(o)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lmod(s,size) (check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define twoto(x) (1<<(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define sizenode(t) (twoto((t)->lsizenode))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaO_nilobject (&luaO_nilobject_)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ceillog2(x) (luaO_log2((x)-1) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gfasttm(g,et,e) ((et) == NULL ? NULL : ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define fasttm(l,et,e) gfasttm(G(l), et, e)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocv(L,b,on,n,e) ((cast(size_t, (n)+1) <= MAX_SIZET/(e)) ? luaM_realloc_(L, (b), (on)*(e), (n)*(e)) : luaM_toobig(L))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freemem(L, b, s) luaM_realloc_(L, (b), (s), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_free(L, b) luaM_realloc_(L, (b), sizeof(*(b)), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_freearray(L, b, n, t) luaM_reallocv(L, (b), n, 0, sizeof(t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_malloc(L,t) luaM_realloc_(L, NULL, 0, (t))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_new(L,t) cast(t *, luaM_malloc(L, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_newvector(L,n,t) cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_growvector(L,v,nelems,size,t,limit,e) if ((nelems)+1 > (size)) ((v)=cast(t *, luaM_growaux_(L,v,&(size),sizeof(t),limit,e)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaM_reallocvector(L, v,oldn,n,t) ((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define char2int(c) cast(int, cast(unsigned char, (c)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define zgetc(z) (((z)->n--)>0 ? char2int(*(z)->p++) : luaZ_fill(z))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_buffer(buff) ((buff)->buffer)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_sizebuffer(buff) ((buff)->buffsize)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_bufflen(buff) ((buff)->n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resetbuffer(buff) ((buff)->n = 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_resizebuffer(L, buff, size) (luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), (buff)->buffsize = size)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luaZ_freebuffer(L, buff) luaZ_resizebuffer(L, buff, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gt(L) (&L->l_gt)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define registry(L) (&G(L)->l_registry)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BASIC_STACK_SIZE (2*LUA_MINSTACK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define curr_func(L) (clvalue(L->ci->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ci_func(ci) (clvalue((ci)->func))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define f_isLua(ci) (!ci_func(ci)->c.isC)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define isLua(ci) (ttisfunction((ci)->func) && f_isLua(ci))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define G(L) (L->l_G)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2ts(o) check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2ts(o) (&rawgco2ts(o)->tsv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define rawgco2u(o) check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2u(o) (&rawgco2u(o)->uv)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2cl(o) check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2h(o) check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2p(o) check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2uv(o) check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ngcotouv(o) check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define gco2th(o) check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define obj2gco(v) (cast(GCObject *, (v)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pcRel(pc, p) (cast(int, (pc) - (p)->code) - 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getline(f,pc) (((f)->lineinfo) ? (f)->lineinfo[pc] : 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define resethookcount(L) (L->hookcount = L->basehookcount)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SIZE_Bx (SIZE_C + SIZE_B)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define POS_A (POS_OP + SIZE_OP)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define POS_C (POS_A + SIZE_A)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define POS_B (POS_C + SIZE_C)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define POS_Bx POS_C
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_Bx ((1<<SIZE_Bx)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_sBx (MAXARG_Bx>>1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_Bx MAX_INT
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_sBx MAX_INT
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_A ((1<<SIZE_A)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_B ((1<<SIZE_B)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXARG_C ((1<<SIZE_C)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MASK1(n,p) ((~((~(Instruction)0)<<n))<<p)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MASK0(n,p) (~MASK1(n,p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GET_OPCODE(i) (cast(OpCode, ((i)>>POS_OP) & MASK1(SIZE_OP,0)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SET_OPCODE(i,o) ((i) = (((i)&MASK0(SIZE_OP,POS_OP)) | ((cast(Instruction, o)<<POS_OP)&MASK1(SIZE_OP,POS_OP))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GETARG_A(i) (cast(int, ((i)>>POS_A) & MASK1(SIZE_A,0)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SETARG_A(i,u) ((i) = (((i)&MASK0(SIZE_A,POS_A)) | ((cast(Instruction, u)<<POS_A)&MASK1(SIZE_A,POS_A))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GETARG_B(i) (cast(int, ((i)>>POS_B) & MASK1(SIZE_B,0)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SETARG_B(i,b) ((i) = (((i)&MASK0(SIZE_B,POS_B)) | ((cast(Instruction, b)<<POS_B)&MASK1(SIZE_B,POS_B))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GETARG_C(i) (cast(int, ((i)>>POS_C) & MASK1(SIZE_C,0)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SETARG_C(i,b) ((i) = (((i)&MASK0(SIZE_C,POS_C)) | ((cast(Instruction, b)<<POS_C)&MASK1(SIZE_C,POS_C))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GETARG_Bx(i) (cast(int, ((i)>>POS_Bx) & MASK1(SIZE_Bx,0)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SETARG_Bx(i,b) ((i) = (((i)&MASK0(SIZE_Bx,POS_Bx)) | ((cast(Instruction, b)<<POS_Bx)&MASK1(SIZE_Bx,POS_Bx))))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define GETARG_sBx(i) (GETARG_Bx(i)-MAXARG_sBx)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SETARG_sBx(i,b) SETARG_Bx((i),cast(unsigned int, (b)+MAXARG_sBx))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define CREATE_ABC(o,a,b,c) ((cast(Instruction, o)<<POS_OP) | (cast(Instruction, a)<<POS_A) | (cast(Instruction, b)<<POS_B) | (cast(Instruction, c)<<POS_C))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define CREATE_ABx(o,a,bc) ((cast(Instruction, o)<<POS_OP) | (cast(Instruction, a)<<POS_A) | (cast(Instruction, bc)<<POS_Bx))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define BITRK (1 << (SIZE_B - 1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define ISK(x) ((x) & BITRK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define INDEXK(r) ((int)(r) & ~BITRK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define MAXINDEXRK (BITRK - 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define RKASK(x) ((x) | BITRK)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NO_REG MAXARG_A
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define NUM_OPCODES (cast(int, OP_VARARG) + 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getOpMode(m) (cast(enum OpMode, luaP_opmodes[m] & 3))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getBMode(m) (cast(enum OpArgMask, (luaP_opmodes[m] >> 4) & 3))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define getCMode(m) (cast(enum OpArgMask, (luaP_opmodes[m] >> 2) & 3))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testAMode(m) (luaP_opmodes[m] & (1 << 6))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define testTMode(m) (luaP_opmodes[m] & (1 << 7))

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define PrintFunction luaU_print

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define Sizeof(x) ((int)sizeof(x))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define VOID(p) ((const void*)(p))

	internal static void PrintString(TString ts)
	{
	 sbyte[] s = ((string)((ts) + 1));
	 size_t i = new size_t();
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: size_t n=ts->tsv.len;
	 size_t n = new size_t(ts.tsv.len);
	 Console.Write('"');
	 for (i = 0; i < n; i++)
	 {
	  int c = s[i];
	  switch (c)
	  {
	   case '"':
		   Console.Write("\\\"");
		   break;
	   case '\\':
		   Console.Write("\\\\");
		   break;
	   case '\a':
		   Console.Write("\\a");
		   break;
	   case '\b':
		   Console.Write("\\b");
		   break;
	   case '\f':
		   Console.Write("\\f");
		   break;
	   case '\n':
		   Console.Write("\\n");
		   break;
	   case '\r':
		   Console.Write("\\r");
		   break;
	   case '\t':
		   Console.Write("\\t");
		   break;
	   case '\v':
		   Console.Write("\\v");
		   break;
	   default:
		   if (isprint((byte)c))
		   {
				   Console.Write(c);
		   }
			else
			{
				Console.Write("\\{0:D3}",(byte)c);
			}
		break;
	  }
	 }
	 Console.Write('"');
	}

	internal static void PrintConstant(Proto f, int i)
	{
	 lua_TValue o = f.k[i];
	 switch (((o).tt))
	 {
	  case DefineConstants.LUA_TNIL:
		Console.Write("nil");
		break;
	  case DefineConstants.LUA_TBOOLEAN:
		Console.Write(check_exp((((o).tt) == DefineConstants.LUA_TBOOLEAN), (o).value.b) ? "true" : "false");
		break;
	  case DefineConstants.LUA_TNUMBER:
		printf(DefineConstants.LUA_NUMBER_FMT,check_exp((((o).tt) == DefineConstants.LUA_TNUMBER), (o).value.n));
		break;
	  case DefineConstants.LUA_TSTRING:
		PrintString(check_exp((((o).tt) == DefineConstants.LUA_TSTRING), (o).value.gc.ts));
		break;
	  default: // cannot happen
		Console.Write("? type={0:D}",((o).tt));
		break;
	 }
	}

	internal static void PrintCode(Proto f)
	{
//C++ TO C# CONVERTER TODO TASK: The following line was determined to contain a copy constructor call - this should be verified and a copy constructor should be created:
//ORIGINAL LINE: const LUAI_UINT32* code=f->code;
	 LUAI_UINT32[] code = new LUAI_UINT32(f.code);
	 int pc;
	 int n = f.sizecode;
	 for (pc = 0; pc < n; pc++)
	 {
	  LUAI_UINT32 i = code[pc];
	  OpCode o = (((OpCode)(((i) >> DefineConstants.POS_OP) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_OP)) << 0))));
	  int a = (((int)(((i) >> (DefineConstants.POS_OP + DefineConstants.SIZE_OP)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_A)) << 0))));
	  int b = (((int)(((i) >> (((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A) + DefineConstants.SIZE_C)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_B)) << 0))));
	  int c = (((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << DefineConstants.SIZE_C)) << 0))));
	  int bx = (((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << (DefineConstants.SIZE_C + DefineConstants.SIZE_B))) << 0))));
	  int sbx = ((((int)(((i) >> ((DefineConstants.POS_OP + DefineConstants.SIZE_OP) + DefineConstants.SIZE_A)) & ((~((~(LUAI_UINT32)0) << (DefineConstants.SIZE_C + DefineConstants.SIZE_B))) << 0)))) - MAXARG_sBx);
	  int line = (((f).lineinfo) ? (f).lineinfo[pc] : 0);
	  Console.Write("\t{0:D}\t",pc + 1);
	  if (line > 0)
	  {
		  Console.Write("[{0:D}]\t",line);
	  }
	  else
	  {
		  Console.Write("[-]\t");
	  }
	  Console.Write("{0,-9}\t",luaP_opnames[(int)o]);
	  switch ((((OpMode)(luaP_opmodes[(int)o] & 3))))
	  {
	   case OpMode.iABC:
		Console.Write("{0:D}",a);
		if ((((OpArgMask)((luaP_opmodes[(int)o] >> 4) & 3))) != OpArgMask.OpArgN)
		{
			Console.Write(" {0:D}", (((b) & (1 << (DefineConstants.SIZE_B - 1))) != 0) ? (-1 - ((int)(b) & ~(1 << (DefineConstants.SIZE_B - 1)))) : b);
		}
		if ((((OpArgMask)((luaP_opmodes[(int)o] >> 2) & 3))) != OpArgMask.OpArgN)
		{
			Console.Write(" {0:D}", (((c) & (1 << (DefineConstants.SIZE_B - 1))) != 0) ? (-1 - ((int)(c) & ~(1 << (DefineConstants.SIZE_B - 1)))) : c);
		}
		break;
	   case OpMode.iABx:
		if ((((OpArgMask)((luaP_opmodes[(int)o] >> 4) & 3))) == OpArgMask.OpArgK)
		{
			Console.Write("{0:D} {1:D}",a,-1 - bx);
		}
		else
		{
			Console.Write("{0:D} {1:D}",a,bx);
		}
		break;
	   case OpMode.iAsBx:
		if (o == OpCode.OP_JMP)
		{
			Console.Write("{0:D}",sbx);
		}
		else
		{
			Console.Write("{0:D} {1:D}",a,sbx);
		}
		break;
	  }
	  switch (o)
	  {
	   case OpCode.OP_LOADK:
		Console.Write("\t; ");
		PrintConstant(f, bx);
		break;
	   case OpCode.OP_GETUPVAL:
	   case OpCode.OP_SETUPVAL:
		Console.Write("\t; {0}", (f.sizeupvalues > 0) ? ((string)((f.upvalues[b]) + 1)) : "-");
		break;
	   case OpCode.OP_GETGLOBAL:
	   case OpCode.OP_SETGLOBAL:
		Console.Write("\t; {0}", ((string)((check_exp((((f.k[bx]).tt) == DefineConstants.LUA_TSTRING), (f.k[bx]).value.gc.ts)) + 1)));
		break;
	   case OpCode.OP_GETTABLE:
	   case OpCode.OP_SELF:
		if ((((c) & (1 << (DefineConstants.SIZE_B - 1)))) != 0)
		{
			Console.Write("\t; ");
			PrintConstant(f, ((int)(c) & ~(1 << (DefineConstants.SIZE_B - 1))));
		}
		break;
	   case OpCode.OP_SETTABLE:
	   case OpCode.OP_ADD:
	   case OpCode.OP_SUB:
	   case OpCode.OP_MUL:
	   case OpCode.OP_DIV:
	   case OpCode.OP_POW:
	   case OpCode.OP_EQ:
	   case OpCode.OP_LT:
	   case OpCode.OP_LE:
		if (((b) & (1 << (DefineConstants.SIZE_B - 1))) || ((c) & (1 << (DefineConstants.SIZE_B - 1))))
		{
		 Console.Write("\t; ");
		 if ((((b) & (1 << (DefineConstants.SIZE_B - 1)))) != 0)
		 {
			 PrintConstant(f, ((int)(b) & ~(1 << (DefineConstants.SIZE_B - 1))));
		 }
		 else
		 {
			 Console.Write("-");
		 }
		 Console.Write(" ");
		 if ((((c) & (1 << (DefineConstants.SIZE_B - 1)))) != 0)
		 {
			 PrintConstant(f, ((int)(c) & ~(1 << (DefineConstants.SIZE_B - 1))));
		 }
		 else
		 {
			 Console.Write("-");
		 }
		}
		break;
	   case OpCode.OP_JMP:
	   case OpCode.OP_FORLOOP:
	   case OpCode.OP_FORPREP:
		Console.Write("\t; to {0:D}",sbx + pc + 2);
		break;
	   case OpCode.OP_CLOSURE:
//C++ TO C# CONVERTER TODO TASK: The following line has a C format specifier which cannot be directly translated to C#:
//ORIGINAL LINE: printf("\t; %p",((const object*)(f->p[bx])));
		Console.Write("\t; %p",((object)(f.p[bx])));
		break;
	   case OpCode.OP_SETLIST:
		if (c == 0)
		{
			Console.Write("\t; {0:D}",(int)code[++pc]);
		}
		else
		{
			Console.Write("\t; {0:D}",c);
		}
		break;
	   default:
		break;
	  }
	  Console.Write("\n");
	 }
	}

	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define SS(x) (x==1)?"":"s"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define S(x) x,SS(x)

	internal static void PrintHeader(Proto f)
	{
//C++ TO C# CONVERTER TODO TASK: Pointer arithmetic is detected on this variable, so pointers on this variable are left unchanged:
	 sbyte * s = ((string)((f.source) + 1));
	 if (*s == (sbyte)'@' || *s == (sbyte)'=')
	 {
	  s++;
	 }
	 else if (*s == DefineConstants.LUA_SIGNATURE[0])
	 {
	  s = "(bstring)";
	 }
	 else
	 {
	  s = "(string)";
	 }
//C++ TO C# CONVERTER TODO TASK: The following line has a C format specifier which cannot be directly translated to C#:
//ORIGINAL LINE: printf("\n%s <%s:%d,%d> (%d instruction%s, %d bytes at %p)\n", (f->linedefined==0)?"main":"function",s, f->linedefined,f->lastlinedefined, f->sizecode,(f->sizecode==1)?"":"s",f->sizecode*((int)sizeof(LUAI_UINT32)),((const object*)(f)));
	 Console.Write("\n{0} <{1}:{2:D},{3:D}> ({4:D} instruction{5}, {6:D} bytes at %p)\n", (f.linedefined == 0)?"main":"function",s, f.linedefined,f.lastlinedefined, f.sizecode,(f.sizecode == 1)?"":"s",f.sizecode * ((int)sizeof(LUAI_UINT32)),((object)(f)));
	 Console.Write("{0:D}{1} param{2}, {3:D} slot{4}, {5:D} upvalue{6}, ", f.numparams,f.is_vararg != 0?"+":"",(f.numparams == 1)?"":"s", f.maxstacksize,(f.maxstacksize == 1)?"":"s",f.nups,(f.nups == 1)?"":"s");
	 Console.Write("{0:D} local{1}, {2:D} constant{3}, {4:D} function{5}\n", f.sizelocvars,(f.sizelocvars == 1)?"":"s",f.sizek,(f.sizek == 1)?"":"s",f.sizep,(f.sizep == 1)?"":"s");
	}

	internal static void PrintConstants(Proto f)
	{
	 int i;
	 int n = f.sizek;
//C++ TO C# CONVERTER TODO TASK: The following line has a C format specifier which cannot be directly translated to C#:
//ORIGINAL LINE: printf("constants (%d) for %p:\n",n,((const object*)(f)));
	 Console.Write("constants ({0:D}) for %p:\n",n,((object)(f)));
	 for (i = 0; i < n; i++)
	 {
	  Console.Write("\t{0:D}\t",i + 1);
	  PrintConstant(f, i);
	  Console.Write("\n");
	 }
	}

	internal static void PrintLocals(Proto f)
	{
	 int i;
	 int n = f.sizelocvars;
//C++ TO C# CONVERTER TODO TASK: The following line has a C format specifier which cannot be directly translated to C#:
//ORIGINAL LINE: printf("locals (%d) for %p:\n",n,((const object*)(f)));
	 Console.Write("locals ({0:D}) for %p:\n",n,((object)(f)));
	 for (i = 0; i < n; i++)
	 {
	  Console.Write("\t{0:D}\t{1}\t{2:D}\t{3:D}\n", i,((string)((f.locvars[i].varname) + 1)),f.locvars[i].startpc + 1,f.locvars[i].endpc + 1);
	 }
	}

	internal static void PrintUpvalues(Proto f)
	{
	 int i;
	 int n = f.sizeupvalues;
//C++ TO C# CONVERTER TODO TASK: The following line has a C format specifier which cannot be directly translated to C#:
//ORIGINAL LINE: printf("upvalues (%d) for %p:\n",n,((const object*)(f)));
	 Console.Write("upvalues ({0:D}) for %p:\n",n,((object)(f)));
	 if (f.upvalues == null)
	 {
		 return;
	 }
	 for (i = 0; i < n; i++)
	 {
	  Console.Write("\t{0:D}\t{1}\n",i,((string)((f.upvalues[i]) + 1)));
	 }
	}

	public static void luaU_print(Proto f, int full)
	{
	 int i;
	 int n = f.sizep;
	 PrintHeader(f);
	 PrintCode(f);
	 if (full != 0)
	 {
	  PrintConstants(f);
	  PrintLocals(f);
	  PrintUpvalues(f);
	 }
	 for (i = 0; i < n; i++)
	 {
		 luaU_print(f.p[i], full);
	 }
	}

	/*
	** $Id: lualib.h,v 1.36.1.1 2007/12/27 13:02:25 roberto Exp $
	** Lua standard libraries
	** See Copyright Notice in lua.h
	*/



//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DYLD
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT ".\\?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?\\init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?\\init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT ".\\?.dll;" LUA_CDI"?.dll;" LUA_CDIR"loadall.dll"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_LDIR LUA_ROOT "share/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CDIR LUA_ROOT "lib/lua/5.1/"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_PATH_DEFAULT "./?.lua;" LUA_LDI"?.lua;" LUA_LDIR"?/init.lua;" LUA_CDIR"?.lua;" LUA_CDIR"?/init.lua"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_CPATH_DEFAULT "./?.so;" LUA_CDI"?.so;" LUA_CDIR"loadall.so"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTEGER ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllexport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API __declspec(dllimport)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_API extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUALIB_API LUA_API
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC static
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA LUAI_FUNC
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_FUNC extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_DATA extern
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QL(x) "'" x "'"
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_QS LUA_QL("%s")
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() isatty(0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() _isatty(_fileno(stdin))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_stdin_is_tty() 1
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, ((b)=readline(p)) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) if (lua_strlen(L,idx) > 0) add_history(lua_tostring(L, idx));
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) ((void)L, free(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_readline(L,b,p) ((void)L, fputs(p, stdout), fflush(stdout), fgets(b, LUA_MAXINPUT, stdin) != NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_saveline(L,idx) { (void)L; (void)idx; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_freeline(L,b) { (void)L; (void)b; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_VARARG
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_MOD
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_LSTR
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_GFIND
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_COMPAT_OPENLIB
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; assert(o); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_apicheck(L,o) { (void)L; }
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUAI_BITSINT
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUAI_BITSINT
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 INT_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM size_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM ptrdiff_t
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UINT32 unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_INT32 long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MAXINT32 LONG_MAX
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UMEM unsigned long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_MEM long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAL_BUFFERSIZE BUFSIZ
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_NUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_UACNUMBER double
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2str(s,n) sprintf((s), LUA_NUMBER_FMT, (n))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_str2number(s,p) strtod((s), (p))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numadd(a,b) ((a)+(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numsub(a,b) ((a)-(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummul(a,b) ((a)*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numdiv(a,b) ((a)/(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numpow(a,b) (pow(a,b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numunm(a) (-(a))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numeq(a,b) ((a)==(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numlt(a,b) ((a)<(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numle(a,b) ((a)<=(b))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_numisnan(a) (!luai_numeq((a), (a)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) __asm fld d __asm fistp i
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,n) lua_number2int(i, n)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2int(i,d) ((i)=(int)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_number2integer(i,d) ((i)=(lua_Integer)(d))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_USER_ALIGNMENT_T union { double u; void *s; long l; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) throw(c)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf int
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) _longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (_setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_THROW(L,c) longjmp((c)->b, 1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUAI_TRY(L,c,a) if (setjmp((c)->b) == 0) { a }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_jmpbuf jmp_buf
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { strcpy(b, "/tmp/lua_XXXXXX"); e = mkstemp(b); if (e != -1) close(e); e = (e == -1); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_TMPNAMBUFSIZE L_tmpnam
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tmpnam(b,e) { e = (tmpnam(b) == NULL); }
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, fflush(NULL), popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)L, _popen(c,m))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)L, (_pclose(file) != -1))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_popen(L,c,m) ((void)((void)c, m), luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pclose(L,file) ((void)((void)L, file), 0)
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DLOPEN
//C++ TO C# CONVERTER TODO TASK: A test for this #define occurs before this statement, so this statement cannot be moved to the top of the file:
	#define LUA_DL_DLL
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateopen(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateclose(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatethread(L,L1) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstatefree(L) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateresume(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define luai_userstateyield(L,n) ((void)L)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_INTFRM_T long
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_upvalueindex(i) (LUA_GLOBALSINDEX-(i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pop(L,n) lua_settop(L, -(n)-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_newtable(L) lua_createtable(L, 0, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushcfunction(L,f) lua_pushcclosure(L, (f), 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_strlen(L,i) lua_objlen(L, (i))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isfunction(L,n) (lua_type(L, (n)) == LUA_TFUNCTION)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_istable(L,n) (lua_type(L, (n)) == LUA_TTABLE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_islightuserdata(L,n) (lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnil(L,n) (lua_type(L, (n)) == LUA_TNIL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isboolean(L,n) (lua_type(L, (n)) == LUA_TBOOLEAN)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isthread(L,n) (lua_type(L, (n)) == LUA_TTHREAD)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnone(L,n) (lua_type(L, (n)) == LUA_TNONE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_isnoneornil(L, n) (lua_type(L, (n)) <= 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_setglobal(L,s) lua_setfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getglobal(L,s) lua_getfield(L, LUA_GLOBALSINDEX, (s))
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_tostring(L,i) lua_tolstring(L, (i), NULL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_open() luaL_newstate()
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_getgccount(L) lua_gc(L, LUA_GCCOUNT, 0)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkreader lua_Reader
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_Chunkwriter lua_Writer
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCALL (1 << LUA_HOOKCALL)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKRET (1 << LUA_HOOKRET)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKLINE (1 << LUA_HOOKLINE)
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define LUA_MASKCOUNT (1 << LUA_HOOKCOUNT)


	/* Key to file-handle type */


	extern int(luaopen_base)(struct lua_State * L);

	extern int(luaopen_table)(struct lua_State * L);

	extern int(luaopen_io)(struct lua_State * L);

	extern int(luaopen_os)(struct lua_State * L);

	extern int(luaopen_string)(struct lua_State * L);

	extern int(luaopen_math)(struct lua_State * L);

	extern int(luaopen_debug)(struct lua_State * L);

	extern int(luaopen_package)(struct lua_State * L);


	/* open all previous libraries */
	extern void(luaL_openlibs)(struct lua_State * L);



	#if ! lua_assert
	//C++ TO C# CONVERTER TODO TASK: #define macros defined in multiple preprocessor conditionals can only be replaced within the scope of the preprocessor conditional:
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define lua_assert(x) ((void)0)
	#define lua_assert
	#endif



}